{"2023-11-21-情绪":{"title":"2023-11-21 情绪","links":[],"tags":[],"content":"人的情绪来自于从小就不能做自己：例如，男孩子不能哭，不怕苦等等。\n\n找到自我存在的价值\n夫妻关系大于亲子关系\n把应该和理所当然移除，感谢和谢谢会让关系升温\n\n"},"Atlas/Blog-MOC":{"title":"Blog MOC","links":["/","tags/map"],"tags":["map"],"content":"up:: index\ntag::map\nlist \nfrom &quot;Spaces/Resources&quot;"},"Atlas/Flash-Note-MOC":{"title":"Flash Note MOC","links":["/","tags/map"],"tags":["map"],"content":"up:: index\ntag::map\nlist\nfrom  #flash "},"Atlas/Inbox":{"title":"Inbox","links":[],"tags":[],"content":"闪念笔记目录。\nTABLE WITHOUT ID\n file.link as &quot;闪念笔记&quot;,\n (date(today) - file.cday).day as &quot;存在天数&quot;\n \nFROM &quot;Calendar&quot; and #review\n \nSORT file.cday asc\n \nLIMIT 20\nlist\nfrom #review \ntodo\nlist\nfrom #todo   "},"Atlas/Maven-MOC":{"title":"Maven MOC","links":["/","tags/map","Spaces/Areas/Maven/Maven-坐标","Spaces/Areas/Maven/Maven-依赖","Spaces/Areas/Maven/Maven-生命周期","Spaces/Areas/Maven/Maven-聚合","Spaces/Areas/Maven/Maven-继承","Spaces/Areas/Maven/Maven-插件"],"tags":["map"],"content":"up:: index\ntag::map\nMaven MOC\nmaven 的一些基本知识，在这里你可以选择你感兴趣的部分，学习相关知识。\n\nMaven 坐标\nMaven 依赖\nMaven 生命周期\nMaven 聚合\nMaven 继承\nMaven 插件\n"},"Atlas/Reivew-notes":{"title":"Reivew notes","links":[],"tags":[],"content":"list\nfrom &quot;Cards&quot; and #review "},"Atlas/Travel-MOC":{"title":"Travel MOC","links":["/","tags/travel","tags/map","Cards/Evergreen-Notes/深圳湾公园游玩指南","Cards/Evergreen-Notes/海上世界游玩指南","Cards/Evergreen-Notes/东角头游玩指南","Cards/Evergreen-Notes/深圳书店游玩指南","Cards/Evergreen-Notes/东角头花房咖啡游玩指南","Cards/Evergreen-Notes/南头古城游玩指南","Cards/Evergreen-Notes/中山公园游玩指南","Cards/Evergreen-Notes/东角头-渔人码头游玩指南"],"tags":["travel","map"],"content":"up:: index\ntag::travelmap\nTravel MOC\n旅游相关的 MOC，包含各种值的去的地方，像公园、海边、书店、咖啡店、餐馆等等。\n\n深圳湾公园游玩指南\n海上世界游玩指南\n东角头游玩指南\n深圳书店游玩指南\n东角头花房咖啡游玩指南\n南头古城游玩指南\n中山公园游玩指南\n东角头-渔人码头游玩指南\n"},"Atlas/关于-Atlas":{"title":"关于 Atlas","links":[],"tags":[],"content":"意思是「地图集」，像使用 dataview 插件可以将指定的结果进行查询展示，有点类似于导航网站。\n不同的导航网站侧重点也不一样， Atlas 也是如此，因此需要一个专门的文件夹来管理这些「导航」网站。"},"Atlas/数字花园主页🪴/Blog-MOC":{"title":"Blog MOC","links":["/","tags/map","tags/blog","Spaces/Resources/博客/国外博客翻译/停止使用-JWT-作为-Session","Spaces/Resources/博客/国外博客翻译/HTTPS-与信鸽","Spaces/Resources/博客/技术类/2023年终总结及个人复盘","Spaces/Resources/博客/技术类/2021-年终总结（技术向）","Spaces/Resources/博客/技术类/2022-年终总结","Spaces/Resources/博客/技术类/6.824分布式系统-Introduction","Spaces/Resources/博客/技术类/AI-工具使用分享","Spaces/Resources/博客/技术类/Code-Specification","Spaces/Resources/博客/技术类/Collection-不常见的重要实现和原理","Spaces/Resources/博客/技术类/Cookie","Spaces/Resources/博客/技术类/Collection","Spaces/Resources/博客/技术类/Docker-基础","Spaces/Resources/博客/技术类/Git","Spaces/Resources/博客/技术类/Git-Bisect-快速上手","Spaces/Resources/博客/技术类/GitHub-提交作业","Spaces/Resources/博客/技术类/HashMap-前世今生","Spaces/Resources/博客/技术类/Hexo博客搭建","Spaces/Resources/博客/技术类/HTML常用标签","Spaces/Resources/博客/技术类/Java-8函数式编程","Spaces/Resources/博客/技术类/Java-与命令行","Spaces/Resources/博客/技术类/Java-中的-GC","Spaces/Resources/博客/技术类/Java-内存模型","Spaces/Resources/博客/技术类/Java-包管理","Spaces/Resources/博客/技术类/Java-异常体系","Spaces/Resources/博客/技术类/Java-线程模型","Spaces/Resources/博客/技术类/JVM-基本结构","Spaces/Resources/博客/技术类/Java-正则表达式","Spaces/Resources/博客/技术类/Jenkins-自动化部署","Spaces/Resources/博客/技术类/Java-获取-GitHub-PR-信息","Spaces/Resources/博客/技术类/Maven-依赖与插件解析机制","Spaces/Resources/博客/技术类/Maven-代码插件","Spaces/Resources/博客/技术类/Linux-服务化的几种方式","Spaces/Resources/博客/技术类/Maven-包冲突解决过程","Spaces/Resources/博客/技术类/Spring-与事务","Spaces/Resources/博客/技术类/String","Spaces/Resources/博客/技术类/Web-中的-Session","Spaces/Resources/博客/技术类/interview","Spaces/Resources/博客/技术类/java9-history","Spaces/Resources/博客/技术类/《Effective-Java》---Object-通用方法","Spaces/Resources/博客/技术类/《Maven-实战》","Spaces/Resources/博客/技术类/Web-前后端基础架构原理","Spaces/Resources/博客/技术类/初识多线程","Spaces/Resources/博客/技术类/一个简单的分布式部署流程","Spaces/Resources/博客/技术类/字符串与编码","Spaces/Resources/博客/技术类/单例实现的几种方式","Spaces/Resources/博客/技术类/Stream","Spaces/Resources/博客/技术类/命令行的入门与详解","Spaces/Resources/博客/技术类/字节码加载与执行","Spaces/Resources/博客/技术类/布隆过滤器","Spaces/Resources/博客/技术类/操蛋的-Git","Spaces/Resources/博客/技术类/浅析-URL","Spaces/Resources/博客/技术类/计算机原理","Spaces/Resources/博客/技术类/线程解惑","Spaces/Resources/博客/技术类/文件与-IO","Spaces/Resources/博客/生活类/改变身份认同","Spaces/Resources/博客/生活类/肠胃镜的经验分享","财富流---个人觉察","Spaces/Resources/博客/生活类/肾结石的治疗经验分享"],"tags":["map","blog"],"content":"up:: index\ntags::mapblog\n\n停止使用 JWT 作为 Session\nHTTPS 与信鸽\n2023年终总结及个人复盘\n2021-年终总结（技术向）\n2022-年终总结\n6.824分布式系统-Introduction\nAI 工具使用分享\nCode-Specification\n-Collection 不常见的重要实现和原理\nCookie\nCollection\nDocker 基础\nGit\nGit Bisect 快速上手\nGitHub 提交作业\nHashMap 前世今生\nHexo博客搭建\nHTML常用标签\nJava 8函数式编程\nJava 与命令行\nJava 中的 GC\nJava 内存模型\nJava 包管理\nJava 异常体系\nJava 线程模型\nJVM 基本结构\nJava 正则表达式\nJenkins 自动化部署\nJava 获取 GitHub PR 信息\nMaven 依赖与插件解析机制\nMaven 代码插件\nLinux 服务化的几种方式\nMaven 包冲突解决过程\nSpring 与事务\n-String\nWeb 中的 Session\ninterview\njava9 history\n《Effective Java》 - Object 通用方法\n《Maven 实战》\nWeb 前后端基础架构原理\n初识多线程\n一个简单的分布式部署流程\n字符串与编码\n单例实现的几种方式\nStream\n命令行的入门与详解\n字节码加载与执行\n布隆过滤器\n操蛋的 Git\n浅析 URL\n计算机原理\n线程解惑\n文件与 IO\n改变身份认同\n肠胃镜的经验分享\n财富流 - 个人觉察\n肾结石的治疗经验分享\n"},"Atlas/数字花园主页🪴/读书笔记":{"title":"读书笔记","links":["/","tags/map","tags/readNote","Sources/Books/📚被讨厌的勇气","Sources/Books/📚人性的弱点","Sources/Books/📚遇见未知的自己","Sources/Books/📚遇见心想事成的自己","Sources/Books/📚这本书能让你戒烟"],"tags":["map","readNote"],"content":"up:: index\ntags::mapreadNote\n\n📚被讨厌的勇气\n📚人性的弱点\n📚遇见未知的自己\n📚遇见心想事成的自己\n📚这本书能让你戒烟\n"},"Atlas/深圳咖啡馆MOC":{"title":"深圳咖啡馆MOC","links":[],"tags":[],"content":"记录待过的深圳咖啡馆☕️"},"Calendar/2023-09-06-卡片盒写文章的实践":{"title":"2023-09-06 卡片盒写文章的实践","links":["tags/review"],"tags":["review"],"content":"tag::review\n卢曼的笔记类型分为四类：临时笔记、文献笔记、永久笔记、项目笔记，我们按照写文章的步骤来逐一讲解这四类笔记。\n临时笔记\n不用在意记录的形式和内容，只记录当下的想法，放到临时笔记的收集箱即可，记录的过程保持专注，不要分心。\n如果已经确定不只是记录这么简单，当前也有时间，则可以直接写成永久笔记。\n文献笔记\n读到一些你不想忘记的或者有可能对日后的思考和写作有帮助的东西，用自己的话写下来，注意言简意赅。\n永久笔记\n你需要做的是浏览你的临时笔记和文献笔记（理想情况是一天一次，在你忘记它们的内容之前），思考它们跟你自己的研究、思考和兴趣之间的联系。\n这一步，你浏览一遍你的卡片盒很快就可以完成，毕竟那里面都是你感兴趣的东西。\n注意！这一步有两个关键点：\n其一：你要做的不是收集，而是激发思考：\n\n\n这些笔记和你之前已有的想法或笔记相抵触吗？\n\n\n可以改正或者支撑你之前的观点吗？\n\n\n是否有新的内容可以加入你的知识库吗？\n\n\n你可以把这些想法整合一下，产生新的洞见吗？\n\n\n他们有没有触发新的问题？\n\n\n其二：**每条笔记只写一个想法，格式统一。**笔记格式就像你写给别人一样:用完整的语句，解释来源，参考了什么，但别啰嗦，用词尽量准确、清晰。\n永久笔记是和过去的自己对话，以及给未来自己留言的过程，所以要想小时候第一次交给老师批改的作业那样认认真真工工整整，老师不只会逐字逐句读，还会在写得好的句子下面画红色波浪线，遇到特别优秀的作业，还有抱在怀里的冲动，没有谁愿意抱着一堆垃圾不放吧，这就是很多人从来不回看自己笔记的原因。\n做完这一步，你就可以把第一步的临时笔记丢掉，把第二步的文献笔记放进你的文献管理系统，然后可以忘掉它们了——所有重要的东西已经在你的永久笔记（卡片盒）里了。\n封装\n把你刚完成的永久笔记按照以下步骤封装进卡片盒中：\na.归档。 把每一个笔记都归档在一个或多个相关的笔记后面（如果你用的是软件/app，你可以随意放置；如果你和卢曼一样，用纸和笔的话，你必须自己决定跟在哪条笔记后面以及给相关笔记添加手写的链接）。看看新的笔记和之前的哪个笔记相关，如果没有明显的关系的话，把它放在最后就行。\nb.添加链接。 添加相关笔记的链接，最好顺带写清楚为什么要链接到相关笔记的理由，这是写给未来自己的，因为健忘的你很可能几天后回过头来已经不记得当初链接这条笔记的原因了。而如果想更加标准化一点，可以给理由设定标准写法，比如我何一叨叨是这样设定链接类型的：B=补充、Y=延伸、X=修正、 P=评论、F=反驳、A=案例、Q=启发、T=提问\nc.留下线索。 确保你以后能够找到这个笔记：从你的索引卡片链接到这条笔记，或者用索引卡片链接到主题切入点的笔记，再在主题切入点笔记上做一个链接到这条笔记上。反正就是要留下足够的线索，确保后面你回过头来能直接找到或（通过线索提示找到）这条笔记，不要让任何一条笔记成为没爹没娘也没有兄弟姐妹的孤儿。\n迭代\n从笔记系统中让你的主题、问题和研究项目自下而上地生长壮大。看看这棵逐渐生长的主题树里有什么、还缺什么、存在什么问题。\n继续阅读，对已有观点，颠覆它或强化它，根据你新学到的东西修正，或继续“喂大”你的卡片盒。不断做笔记，不断迭代你的想法，看看最终这些笔记会走到哪里。\n你只需跟着兴趣走，就等于永远走上一条有机会获得最深刻洞见的道路。\n在已有的笔记上继续构建，即便你的卡片盒里什么东西也还没有，你也不是从零开始，因为你的大脑里已经有了等待验证的想法、需要被颠覆的观点、亟待解决的问题。把它们写成笔记，并以此为基础开始你的探索之路。\n对了，这里有一点要讨论一下，现在很多关于写作的书里会教你用头脑风暴来选题。这里要注意，卢曼笔记法不建议你为了选题搞头脑风暴，而是看一下你的卡片盒，看看哪里已经形成了笔记链，哪里的已经建立了观点集群。你对哪个想法更感兴趣就去深挖它，不要抓着手中的想法不放。你对某件事越感兴趣，你就会思考更多，写更多的笔记，也因此产生更多相关的问题。\n可能一开始你对社会心理学很感兴趣，后来在探索的过程中你发现对市场营销更痴迷，整个过程使兴趣发生了改变——就是这个过程让你产生深刻洞察的。\n选题\n用不了多久，你所发展出来的想法和写下来的笔记，早就足够你决定写什么话题的文章了，还要啥自行车啊，压根没头脑风暴啥事儿了。\n你的写作主题应该是基于你已经有什么想法，而不是基于你将要读的那些文献里可能有你想要的但还没有发现的想法（这句话比较绕，但很重要，建议多读几遍）。\n沿着笔记里的链接，整理所有相关主题的笔记（一部分的相关笔记已经被整理过了），把它们平铺到你的桌面（如果你是纸质系统）或复制到空白文档里，再整理一下。看看缺什么，哪些是多余的。\n不要等到真正成文那一刻才行动，而是要小步快跑不断迭代，给自己足够的时间回头继续阅读、做笔记、完善观点、改善论述及文章结构。\n拟稿\n把你的笔记写成初稿，但不要简单地复制粘贴，而是用笔记来构建你的论点，然后把相关笔记连贯、通顺地嵌入到你的论点的上下文中。看看还有什么没表达清楚到位的，多添少补。\n审稿\n比如文风是否统一、表达是否到位、能不能参入金句、反正这是一个优化润色的过程，审稿完事后拍拍手，完稿！接着写下一篇稿子。\n以上步骤，说得好像你每次只会写一篇文章似的。现实中，你不会只有一个想法，相反，在同一时间你可能有好几个不同阶段的想法。而这正是这个系统牛叉的地方。我们总会思考不止一个问题，而且很可能你将来也会想问题，也需要写东西。可能不是为了学术，也不是为了发表，而是为了知识成长。\n事实上，所有你读过的文章或书籍里，一般不可能只包含你寻找的特定问题的答案，肯定还有其他信息。除非你之前已经读过这它，知道里面有什么，不然你为什么还去读它？\n想知道一篇文章或一本书值不值得读的最好方式就是去读它（即便是只读一点点），花点时间，开卷有益。\n把你一路上遇到的东西沉淀下来，不要白白浪费任何一个好的想法。 你读某本书可能是希望它对你准备写的某篇文章有用。但这其中只有很少一部分会被用到打算写的那篇文章里，大部分内容都用不上，为什么白白浪费了这些精华呢？完全可以做文献笔记或永久笔记并添加到您的卡片盒里，这篇文章没用上，兴许日后哪篇文章能就派上用场。\n这些笔记会让你的卡片盒不断丰富起来。所有加入到卡片盒的笔记，你的卡片盒会被你“投喂”得越来越大，最后它不仅仅是你的想法收集库，还变成了观点生成器。\n正常的一个工作日通常会包括很多次阅读和记笔记的动作。你在卡片盒里建立笔记之间的联系，这本身就会激发出新的观点。你把它们写下来并加入卡片盒。\n它们或许让你发现正在写作的那篇文章观点中的漏洞，加一句合适的引用，或让你找到卡片盒里笔记链缺失的一环。又或者在某条笔记里加上一笔脚注，回过头继续研究。\n你想阅读的重点取决于你问题的优先级。如果你眼下有篇文章急着要完成，那不必读任何你认为不是绝对必要的东西。\n但是，写作过程中你必定还会有新的想法。花点时间，把它们添加到卡片盒，这一切大有不同，多次的偶然能成就杰出的必然，差距就是这样产生和拉大的。\n想象一下，如果我们一辈子学习到的只是我们打算学的东西或者只学习老师教我们的东西。如果这样，我想我们甚至连说话都不会。\n用我们的兴趣做过滤器，每增加一点内容，都是对我们未来理解、思考和写作的贡献。很多文章的神来一笔通常出在这个过程，因为其中蕴含着大量远程联想的机会。\n大部分人同时想着很多事。他们可能一会想这一会想那，但通常某个事情如果想到没有头绪了就会先放一边，想过段时间有头绪了再回来继续思考。\n因此，如果我们在这个过程中能够让想法可视化并有迹可循，就不必重新思考之前搁置一边的想法了，事情因此事半功倍，这也是高效人士之所以高效的原因所在\n参考\n会记笔记就会写作"},"Calendar/2023-09-09-Java-9-到-18-的变更特点":{"title":"2023-09-09 Java 9 到 18 的变更特点","links":[],"tags":[],"content":"参考\nNew language features since Java 8 to 18 - Advanced Web Machinery"},"Calendar/2023-09-10-Java-9-语法特性":{"title":"2023-09-10 Java 9 语法特性","links":["Java-Language-MOC","tags/Java语言特性"],"tags":["Java语言特性"],"content":"up:: Java Language MOC\ntag::Java语言特性\n接口中允许私有方法\nJava 8 使用了default 关键字，可以在接口中实现方法。假如要在 default 方法之间共用同一份代码，java 8 中需要将代码提到公共的 default 方法中调用。\n\tpublic interface Java8Interface {  \n\t\tdefault void methodA(int a, int b) {  \n\t\t\t// do something  \n\t\t\tbiFunction(a, b);  \n\t\t}  \n\t\t  \n\t\tdefault void methodB(String a, String b) {  \n\t\t\t// do something  \n\t\t\tbiFunction(a, b);  \n\t\t}  \n\t\t  \n\t\tdefault void biFunction(Object a, Object b) {  \n\t\t\t// do something  \n\t\t}  \n}\n问题能解决，但是却不符合接口的原则，将不必要的方法暴露出去会给调用者带来困扰。Java 9 开始接口支持使用 private 方法，代码如下：\npublic interface Java9Interface {  \n\tdefault void methodA(int a, int b) {  \n\t\t// do something  \n\t\tbiFunction(a, b);  \n\t}  \n\t  \n\tdefault void methodB(String a, String b) {  \n\t\t// do something  \n\t\tbiFunction(a, b);  \n\t}  \n\t  \n\tprivate void biFunction(Object a, Object b) {  \n\t\t// do something  \n\t}  \n}\ntry-with-resource 优化\ntry-with-resource 也是老朋友了，在 java 7 引入的，能够帮我们自动关闭流，简化代码块。\nJava 7 的 try-with-resource 当 try 括号后面的包裹的代码太多，就会变成一坨很臃肿，代码如下：\ntry (BufferedReader br1 = new BufferedReader(…);  \n\tBufferedReader br2 = new BufferedReader(…);  \n\tBufferedReader br3 = new BufferedReader(…)) {  \n\treturn br1.readLine() + br2.readLine() + br3.readLine();  \n}\nJava 9 之后，代码如下：\nBufferedReader br1 = new BufferedReader(…);  \nBufferedReader br2 = new BufferedReader(…);  \nBufferedReader br3 = new BufferedReader(…);  \ntry (br1; br2; br3) {  \n\treturn br1.readLine() + br2.readLine() + br3.readLine();  \n}\n简化了很多，但是请注意变量虽然声明在 try 外面，但是作用范围只在 try 包裹的代码块中，try 外面使用变量会导致运行时产生错误。实例代码：\nBufferedReader br1 = new BufferedReader(…);  \ntry (br1) {  \n\tSystem.out.println(br1.readLine());  \n}  \nbr1.readLine(); // 此时资源已关闭，调用会报错\n下划线 _不再是有效标识符\nJava 9 之前可以将 _ 设置为变量，虽然编译器会警告，但运行不会报错。\nint _ = 123;  \nSystem.out.println(_);\nJava 9 之后，编译器会提示\njava: 从发行版 9 开始, &#039;_&#039; 为关键字, 不能用作标识符\n菱形符号 &lt;&gt; 升级\nJava 7 引入 &lt;&gt; 让编译器推断构造器参数类型\n// java 7 之前  \nList&lt;String&gt; names = new ArrayList&lt;String&gt;();  \n  \n// java 7 之后  \nList&lt;String&gt; names = new ArrayList&lt;&gt;();\nJava 9 对类型推断进一步增强，支持匿名内部类的参数推断，实例代码如下：\n&lt;T&gt; Result&lt;T&gt; create(T content) {  \n\treturn new Result&lt;&gt;(content) {  \n\t// 实现方法  \n\t};  \n}"},"Calendar/2023-09-11-Java-17-语言特性":{"title":"2023-09-11 Java 17 语言特性","links":["Java-Language-MOC","tags/Java语言特性"],"tags":["Java语言特性"],"content":"up:: Java Language MOC\ntag::Java语言特性\nRecord Class\nJava 16 中支持了 Record 类"},"Calendar/2023-10-14-脱发带来的思考":{"title":"2023-10-14 脱发带来的思考","links":["tags/life"],"tags":["life"],"content":"tag::life\n脱发一个大多数人面临的困境，如果你只是想知道我是如何治疗脱发的，我只能给到米若地儿，非那雄胺两款药，以及植发、假发两种手段。\n如果以上的方式你都不太喜欢，那有一种一劳永逸的方法，就是改变你的心态。\n为什么会害怕脱发\n社会风气颜值高的往往会受人注意，每个人都或多或少的有「容貌焦虑」，\n害怕脱发是在害怕什么\n人生不只有脱发"},"Calendar/2023-10-15-理科生的傲慢":{"title":"2023-10-15 理科生的傲慢","links":[],"tags":[],"content":"\n理科生的傲慢，人的成功方式？\nmp.weixin.qq.com/s/PVCog6cF6-v4hz5OWZilIg\n"},"Calendar/2023-10-29-芒格之道-E110":{"title":"2023-10-29 芒格之道 E110","links":["tags/life/skill"],"tags":["life/skill"],"content":"tags::skill\n人的四种激素感觉分泌\n\n多巴胺（好吃，好看的东西）\n血清素（亲密关系的表达，拥抱）\n内啡肽（认真努力获得的奖赏，运动的方式是最容易获得的）\n肾上腺素\n\n需要最求内啡呔和血清素"},"Calendar/2023-11-14-3DCAT-公有云应用发布逻辑":{"title":"2023-11-14 3DCAT 公有云应用发布逻辑","links":[],"tags":[],"content":"\n用户上传应用到镭速服务器（深圳区域），MQ 通知其他区域去深圳区域下载用户上传的应用文件。\n创建项目，购买套餐，将项目和套餐关联起来。\n发布应用：关联项目，填写一些应用启动的配置信息。点击发布之后通过 MQ 发送指令到区域的文件服务器，区域服务器开始执行 MQ 指令，解压相应的文件，解压完成之后通知会平台修改应用状态为「已发布 」。\n创建应用的分享链接，打开链接，节点机（分配给客户的）与客户端的建立  webrtc 链接。\nmunu 根据应用发布时的配置去启动 exe 文件\n抓图程序去捕获应用画面信息，通过 webrtc 推送到客户端\n\nQ: 每个区域都有一个文件服务器，该区域的所有节点机都使用 smb 挂载该区域文件服务器下的同一个磁盘？\nQ: 应用发布时的「共享存储」和 「本地存储」的区别？\n- 节点机挂载的磁盘是「共享存储」？本地磁盘就是「本地存储」？\nQ: munu 排队发生在哪个阶段？目前排队的逻辑是怎么样的？\nQ: webrtc 链接的建立过程（一些基本的流程）\nQ: 应用启动的流程"},"Calendar/2023-12-06-快速学习一个领域":{"title":"2023-12-06 快速学习一个领域","links":[],"tags":[],"content":"结构化的思维方式：\n\n脑海中需要有一个该领域的知识框架\n\n如何建立这个框架？\n\n多问为什么？（层层追问）\n沿着时间线去梳理（过去，现在，未来）。文化类的适合。\n\n查数据，一手的信息\n\n\n按照步骤或者流程的想法\n\n如何把大象放进冰箱\n\n\n\n\n\n\n进行输出。\n"},"Calendar/2023-12-22-老妈和婶婶生日礼物":{"title":"2023-12-22 老妈和婶婶生日礼物","links":[],"tags":[],"content":"\n 丝巾\n 羊绒围巾\n 一束鲜花\n 内衣\n 金饰\n"},"Calendar/2023-12-25-2023-个人复盘-+-总结":{"title":"2023-12-25 2023 个人复盘 + 总结","links":["tags/life"],"tags":["life"],"content":"tag::life\n不知不觉工作已经 3 年了，想要好好总结复盘一下今年的一些情况。今年的生活特别有记忆点，不再像过去的时间一样枯燥单调麻木，今年是一个全新的体验。\n身体的一些小状况 1~ 4 月\n年初刚到公司换了部门。\n1 ~ 4 月如果过去的两年别无二致，机械麻木的工作，蜗居在自己的安乐窝中 ，享受着奶头乐。但不变的，依然关注着 IT 前沿的技术信息，以及未来的一些发展，开始了解 AI，学习使用 ChatGPT，并自己捣鼓一些小玩意，密切关注着 AI 发展。技术上取得的一些小成就，帮公司搭了一套 GPT 服务，在公司做过一次 AI 使用的分享。\n1 ~ 4 月技术方面成长还算凑合，但身体出了一些状况，体验查出自己有肾结石，经历了人生中第一次手术，住院，jj 插尿管的酸爽（想起来都疼）。为了不让自己害怕，看了大量的肾结石相关的科普视频，结石的产生以及现有的手术方案，各种方案的优缺点等等，让我从新认识到自己的身体处于一个什么样的状态，所以如果有关于结石方面的问题，可以来问我哈哈哈，希望大家不要有哈哈。\n开始内耗 5 ~ 8 月\n5 ~ 8 月，中间断断续续看过一些技术书籍，也特意花时间学了 Obsidian 使用、卡片笔记法、ACCESS 知识管理，现在回想起来，这是今年投入时间最多也非常值得的事情。中间学了 100 多天的英语，自我感觉语感提升，后面认识的以为猎头也是因为英语，哈哈哈，可惜后面没有继续坚持。这个时候想要润，想要出国的想法达到了顶峰。\n日子还是那么浑浑噩噩的过着，但我是乐在其中，靠着王者荣耀，各种短视频麻痹着自己，享受着自以为是的快乐。人一旦闲下来就容易胡思乱想，想的多了发展成了内耗，自己的心态出现了问题，每天都在不切实际的幻想，幻想着自己成为技术大牛后，如何如何，每天都靠美好的幻想麻痹着自己，却少有行动，只是为了让自己内心满足，真是可怜。\n发现自己的状态不对，就开始看一些心里学的书籍《不再害羞》《被讨厌的勇气》，看哲学相关的视频，《人生的意义》《如何克服虚无主义》。每次看的时候都能给到我冲击和能量，但是结束之后一切好像恢复如初。我开始怀疑书上说的知识，开始把他当做麻醉人的鸡汤文章。\n跌落谷底，触底反弹。\n改变！！刻不容缓！！9 ~ 10 月\n经历了内耗的折磨，寻找解决方法无果，9 月 9 号晚上与好朋友微信语音聊到凌晨 2 点，探讨人生哲学，那天晚上就下定决心第二天一定要出门走走，改变自己内耗的状态。\n或许是上天真的想让我改变了，我永远不会忘记这一天 2023 年 9 月 10 号，待在深圳快 3 年的我，选择了去户外感受世界，选择了离家最近的海边。那天天气格外的好，中午的大太阳，在一阵小雨之后，格外清爽，我换了一身好看的衣服，带着我的帆布包，耳机，踏出了房门。大口呼吸着新鲜空气，耳机音量调的很大，音乐响起的那一刻，我的眼泪刷地一下就出来，那一刻是我感觉特别幸福。这是一种从未有过的感觉，可能是因为自我感动，自艾自怜，但是那种感觉真的太棒了，只是去到户外就能给我这么大的能量，哇生活真美好！！！\n从这天开始后，我就打算每周都去一个没有去过的地方，于是我去了深圳湾公园、海上世界、南头古城、中山公园、四海公园、大大小小的书店、各式各样的咖啡厅、深圳美术馆、会展中心等等。\n之后的生活仿佛开了挂一般，开启了一系列的连锁反应。我开始愿意尝试新鲜事物，开始愿意主动去和别人交流（尽管这对一个曾经社恐的人士很难）。在国庆期间与之好久没联系的朋友重新联络，通过他的介绍认识了很多创业者，开始大量社交，每次都会给到我很强的能量，我开始有信心和勇气去做自己舒适圈外的事情。\n后面的时间都在一点点的突破自己的舒适圈，并每天记录一些突破舒适圈的行为。例如换穿搭风格、戴墨镜出门、参加公司活动、参加兰海老师分享会、主动与陌生人交流，发自己的丑照等等。这些积累让我开始想要追求更难的挑战，机缘巧合下我报名了公司年会的主持（这因应该是近几年我做的最大的尝试了），哇真是个巨大的进步，我爱死自己了。\n在这些尝试中，我已经没有时间去胡思乱想，自然也没有内耗了，我开始愿意去尝试自己从未接触过的东西，我结交了一些好友，结束了长达 20 多年的单身状态。\n稳步前进 11 ~ 12 月\n这两个月已经很少关注 IT 行业的事情了，慢慢地发现自己开始对设计，服装、穿搭、潮流文化感兴趣，开始关注该行业的信息，后面的时间准备开始投入更多的时间在该领域，未来会发展成什么样子也不知道，只要自己喜欢就好。\n这一两个月我更多地关注自身的心态，情绪认知，看待事物的方式等等。可能自我感觉不明显，但是身边人的一些反馈，让我意识到，哦原来我是在变化的。\n12月份公司经历了一波裁员，熟悉的同事大多数都走了，自己的心态受到了些影响，沉浸在分别的情绪当中，或许这就是自己改变之后的需要承受的东西。我也不知道自己会不会是下一个，但是没关系，事情发生了就去面对就好了，这可能是未来的自己告诉我，我需要经历这些。\n2023 一些完成的目标\n看过的电影\n\n《涉过愤怒的海》\n《名侦探柯南-黑铁的渔影》\n《好像也没有那么热血沸腾》\n《惊奇队长2》\n《惊奇队长2》\n《涉过愤怒的海》\n《河边的错误》\n《灌篮高手》\n《误杀2》\n《保你平安》\n《巴霍巴利王》\n《巴霍巴利王2》\n《饮食男女》\n《心迷宫》\n《蜘蛛侠：纵横宇宙》\n《杰伊比姆》\n\n综艺\n\n《圆桌派第三季》\n《圆桌派第二季》\n《圆桌派第一季》\n\n剧集\n\n《请回答1988》 \n《武林外传》 心中第一神剧，没有之一，不记得几刷了。\n《少年谢尔顿4》\n《时光代理人》\n《我是大哥大》\n《鹊刀门》\n《凸变英雄2》\n《模仿犯》\n《灌篮高手》 不记得几刷了，每次看完都热血沸腾\n《星期三》\n\n书籍\n\n《人性的弱点》还没有读完\n《谁动了我的奶酪》\n《谁动了我的奶酪2》\n《活着》\n《在细雨中呼喊》\n《被讨厌的勇气》\n《不再害羞》\n\n2024\n2023年就要过去了，最近常听的一个播客节目「无人知晓」，特别喜欢孟岩，这里想引用他说的一句话作为我新的一年开始：\n愿新年的阳光打在你的脸上，愿你拥有无限的热情、勇气和平静，让万物穿过自己。"},"Calendar/2024-02-29-忧虑":{"title":"2024-02-29 忧虑","links":["tags/todo","tags/忧虑","Calendar/忧虑容易导致的3大疾病","Calendar/威利斯·卡瑞尔公式","Calendar/亚里士多德法则","Calendar/忧虑减半的四个步骤"],"tags":["todo","忧虑"],"content":"tags::todo忧虑\n忧虑容易导致的身体疾病\n\n忧虑容易导致的3大疾病\n\n消除焦虑的方法\n\n威利斯·卡瑞尔公式\n亚里士多德法则\n忧虑减半的四个步骤\n让自己一直不停地忙着（让忙碌消除你的忧虑）\n你的生活只有今天\n运动也可以解优\n不要让自己因为一些小事情烦心：生命太短促了，不要再为小事烦恼\n根据以往的记录去计算平均概率，然后问问自己，所担心的事情发生的概率有多大？\n接收不可避免的事实\n\n告别忧虑的法则\n\n对前途要有信心\n要能睡得安稳\n喜欢好的音乐\n从滑稽的一面来看待生活\n"},"Calendar/2024-03-07-一款用于检测网站语法的工具":{"title":"2024-03-07 一款用于检测网站语法的工具","links":[],"tags":[],"content":"对于一些网站，没有办法检测出文档的字符间距，文档的规范。可以开发一个工具用来做这个事情。"},"Calendar/2024-03-07-消费者更愿意为故事和经历买单":{"title":"2024-03-07 消费者更愿意为故事和经历买单","links":[],"tags":[],"content":"星巴克、奢侈品包、以及一些溢价高的产品、遥遥领先等等。"},"Calendar/2024-03-07-通过别人的故事武装自己":{"title":"2024-03-07 通过别人的故事武装自己","links":[],"tags":[],"content":"那个\n需要使用别人的故事，来赋予我的意义。\nQ: 为什么不使用自己的故事呢？\nA: 代价太大，需要勇气和成本。\n勇气：不要来告诉我我是谁，我来告诉你我是谁。\n磕 CP\n磕 CP 本质上是用别人的故事，来填补自己的内心"},"Calendar/2024-04-03-17-42-写卡片的原则":{"title":"2024-04-03 17-42 写卡片的原则","links":[],"tags":[],"content":"\n\n卡片只记一件事，用简介的方式清晰的记录下来。\n\n\n不要一味复制粘贴、需要用自己的语言去描述信息，描述的过程就在帮助我们思考🤔\n\n\n笔记不应该所属某一类具体的事物：人、书、影视等等。应该根据笔记的概念，所要表达的东西类型去分类\n\n\n不要以分享的目的去写卡片。这样容易让自己产成炫耀的想法，从而让自己的笔记增加许多无用的修辞，违背了步骤一的原则，同时炫耀的心里也会扭曲自己的学习目的。\n\n\n记录的数量不必求多，只要产成有价值的卡片即可。\n\n\n来源：📋 为何要写卡片 | flomo 101"},"Calendar/2024-04-03-看到的一个感悟":{"title":"2024-04-03 看到的一个感悟","links":[],"tags":[],"content":"了解更多东西并不会让你变得更聪明 —— 相反，是你运用你所知道的东西的方式，让你变得更聪明"},"Calendar/2024-04-07-16-53-该获取什么样的知识":{"title":"2024-04-07 16-53 该获取什么样的知识","links":[],"tags":[],"content":""},"Calendar/2024-04-08-16-41-展现真我的特质":{"title":"2024-04-08 16-41","links":["tags/flash","tags/遇见未知的自己/真我"],"tags":["flash","遇见未知的自己/真我"],"content":"tags::flash真我\n\n任何能丢弃自己不实的身份认同，而且不被自己的思想、情绪以及身体所限制和阻碍的人，都能展现出真我的特质\n\n从小到大，我从好像没有见过真实的自我是什么样子，现在知道了如何展现真实的自我。\n\n不实的身份认同\n\n我的身份认同是什么呢？ 它到底是不是我真实的身份？\n方案：去复盘自己的身份认同，深度思考🤔\n\n\n不被思想、情绪限制\n\n思想情绪，影响我做事的结果\n方案：学习好的思想、学习和情绪共处。\n\n\n不被身体限制\n\n我需要良好的身体承载我所做的事情\n方案：加强身体素质。\n\n\n"},"Calendar/2024-04-09-15-03-与真我连接":{"title":"2024-04-09 15-03","links":["tags/flash","tags/遇见未知的自己/真我"],"tags":["flash","遇见未知的自己/真我"],"content":"tags::flash真我\n身体的障碍\n身体的障碍，阻碍了我们与真我的连接\n建立与身体的连接\n\n运动与呼吸\n饮食与健康\n健走与身体连接\n\n全神贯注观察自己的身体\n\n\n"},"Calendar/2024-04-09-15-58-担心是最差的礼物":{"title":"2024-04-09 15-58","links":["tags/flash","tags/遇见未知的自己/担心","负面能量"],"tags":["flash","遇见未知的自己/担心"],"content":"tags::flash担心\n世界上只有三件事情，我的事、他的事、老天的事。\n我们能做的只有自己的事情。家人、伴侣、孩子、朋友的事情都是他人的事。\n担心身边的人，需要明白担心的是到底是什么？真的是担心他么，还是只是用用担心当挡箭牌，其实还是为了满足自己。\n- 审视自己担心的到底是什么？\n- 担心的事情是不是属于老天的事？\n- 过度担心就是给她负面能量\n- 用提醒和祝福来代替我们的担心。"},"Calendar/2024-04-11-15-12-思想从何而来":{"title":"2024-04-11 15-12","links":["tags/flash","tags/遇见未知的自己"],"tags":["flash","遇见未知的自己"],"content":"tags::flash遇见未知的自己\n\n受了这么多的‘应该’的理想，我们于是产生了很多的信念、价值观、态度、标准，来约束自己，也来衡量、批判他人。这些就是我们每日所思所想的基础，可是我们从来不去检测我们思想的正确性。\n\n\n价值观、态度、信念来源于从小接触到的教育和思想。\n对待事情的看法，都是基于自身的价值观、态度、信念。\n需要审视过自己的价值观、思想。\n"},"Calendar/2024-04-13-17-51臣服已经发生的事情":{"title":"2024-04-13 17-51","links":["tags/flash","tags/遇见未知的自己"],"tags":["flash","遇见未知的自己"],"content":"tags::flash遇见未知的自己\n「所有已经发生的事情」都是我们需要去臣服的，因为他已经发生了，且我们没有办法去改变过去，切记，虽然这是个常识，但是很多人都会执着于过去，包括我自己。\n所有发生的事情都是有利于我的，切记！！！\n对于我们不能接受的事实，我们情绪上的反抗和反对无异于「拿头撞墙」无济于事，伤害的只有自己。"},"Calendar/2024-04-13-19-10-一切都是我们内在的投射":{"title":"2024-04-13 19-10","links":["tags/flash","tags/遇见未知的自己"],"tags":["flash","遇见未知的自己"],"content":"tags::flash遇见未知的自己\n\n所有的人、事、物都是你内在的投射，就像镜子一样地反映你的内在。\n\n我们的内在又是和价值观、态度有关系，因此我们的价值观决定了我们对人、事、物的看法，当我们习惯性用我们的价值观和态度去看待事情的时候，需要提醒自己：我的价值观和态度他是正确的吗？"},"Calendar/2024-04-14-16-42-我们都生活在自己思想观念的牢笼之中，却浑然不觉":{"title":"2024-04-14 16-42","links":["tags/flash","tags/遇见未知的自己","tags/output"],"tags":["flash","遇见未知的自己","output"],"content":"tags::flash遇见未知的自己output\n\n「生活在思想的牢笼之后却浑然不觉」\n\n因为我们的大脑已经被身边人的思想和观念驯化，已经成为习惯，大脑会下意识的用已有的思想来处理事情，看待事物。\n「吃饭不能吧唧嘴」这个观念是从哪里来的，从哪里习得的。于我而言，我是在成长过程中，被教育被驯化被告知我不能吧唧嘴的。\n我们的行为，都是为了满足自己脑中的思想。例如：我们常说的「吃饭不吧唧嘴」，吧唧嘴会被旁人当做是一种没有「教养」缺乏「餐桌礼仪」的行为。\n问题就产生了，为什么吧唧嘴会被人认为是没有教养的行为。为什么？答案可能是父母是这样教的、大家都是这样、声音大影响其他人吃饭。\n前两个答案都是有没有自己思考的过程，不予解答。声音大影响其他人吃饭，这个是个人选择，如果一直考虑到别人，自然会下意识的控制自己的行为，但这也恰恰说明了我们受自己思想的控制。\n很多人吧唧嘴都是无意识的、被人提醒之后才后知后觉，我也如此。经过查看一些资料，吧唧嘴就是人对食物满意，咀嚼之后才发出的声音，是一种无意识的行为，并非刻意的。因此，吧唧嘴实际上就是人自带的属性，选择不吧唧其实就是在克制自己。\n吧唧嘴溯源\n吧唧嘴是从什么时候被认为是没有「教养」的，还是说从人类诞生之初就是了？这里有偏文章作者就发现了吧唧嘴并无文献记载，反而是恐因症群体，因为受不了咀嚼的声音而讨厌吧唧嘴群体，从而把吧唧嘴变成一种没有教养的行为。\n为了照顾该群体，吃饭不让吧唧嘴便当做了「礼仪」的一部分，但经过演化，严厉的言传身教变成了「教养」的问题，成为大多数人站在道德制高点抨击他人的武器。但本质上，他只是一个「礼仪」罢了，上升不到「教养」。\n看待吧唧嘴\n吧唧嘴是一个「礼仪」，可以有也可以没有，缺乏礼不代表道德有瑕疵，不代表他是一个没有教养的人。我会允许别人吧唧嘴，倘若我听不惯别人吧唧，我会友善告知他：谢谢你能好好地享受食物，但是我对吧唧的声音敏感，会让我烦躁不能好好享受这一餐，我也想好好享受食物的快乐，需要你帮我，谢谢。\n在外吃饭，我还是会选择避免吧唧嘴，不是为了所谓「有教养」、而是想让自己有礼，为了照顾不吧唧的其他群体，是我的高尚品德的体现。自己一个人的时候，爱吧唧就吧唧，满足自己作为人最本质的欲望。"},"Calendar/2024-04-28-14-27-为什么我会想哭":{"title":"2024-04-28 14-27","links":[],"tags":[],"content":"在和女友日常相处的过程当中，经常因为一些日常事情想哭，眼泪绷不住，心里有一种委屈感。\n日常事情包括：\n\n女友说了一些，感到我的话\n我其实内心不太想让她做的事情，但迫于对她的喜爱，还是会积极的支持她，知道她说他不做那件事情了\n被一些日常生活的瞬间感动到\n\n我的疑问如下：\n\n我为什么会有这种委屈感？\n我真的委屈吗？\n想哭是为什么？\n哭真的是我在那个时刻想要表达的感受么？\n"},"Calendar/2024-04-30-15-52-出行准备":{"title":"2024-04-30 15-52","links":[],"tags":[],"content":"\n 身份证、充电宝、墨镜🕶\n 洞洞拖鞋，ps 需要宝宝帮忙贴可爱的贴片\n 一条牛仔裤👖、一条黑色短裤🩳、一条灰色短裤、蓝色衬衫、白色 T 恤、线条小狗的衬衫\n[ ]\n"},"Calendar/2024-05-09-16-37-凡是聚焦之处，能量就会放大":{"title":"2024-05-09 16-37","links":["tags/遇见心想事成的自己"],"tags":["遇见心想事成的自己"],"content":"tags::遇见心想事成的自己"},"Calendar/2024-05-10-17-15-认识自己的职业框框":{"title":"2024-05-10 17-15","links":[],"tags":[],"content":"想要框\n这个框里应该装着所有你想要的职业\n\n 程序员👨🏻‍💻\n 服装穿搭博主\n 服装设计师\n 自我成长型博主\n\n现实框\n这里面应该装着所有可能的职业，或者你的潜力能够达到的职业。这取决于你在不同领域的潜能，以及在各个领域取得成功的普遍难度\n\n 程序员👨🏻‍💻\n 服装穿搭博主\n 自我成长型博主\n"},"Calendar/2024-05-13-11-19-看《歌手》学营销":{"title":"2024-05-13 11-19","links":[],"tags":[],"content":"最近这几天被歌手刷屏了，这滔天的流量，让我一个不关注内娱的人，也开始关注歌手了。emmm 可见营销之成功。\n我现在就用一个普通人的视角，来看看歌手的营销到底有多牛。\n歌手的前期宣发没有太大感觉，我甚至都不知道今年有《歌手》。直到第一期竞演结束，热搜才蹭蹭往上涨，\n\n看起来这个案例涉及到了数个有趣的心理和社会现象的动态。让我尝试分析一下： 1. 群体比较与身份认同： 当人们看到国内歌手与国际歌手的比拼，他们可能会将这种比较看作是一种身份的象征，这反映了他们的集体对比意识和民族自豪感。国内歌手在比赛中的失利可能会让人们感觉到一种失落感和挫败感，所以他们会去寻找能够改变这种局面的方式。 2. 自我效能与努力： 观众们对寻找更有实力的唱将这样的自发行动，显示出他们对改变未来结果的信心。这种情况是自我效能感的一种体现，即个体对自我能力的认知和信任，认为自己有能力影响事对象或者改变某种情况的信念。 3. 从众行为与社会动员： 当观众们集体行动起来寻找新的唱将参加节目时，这背后反映的是从众行为的影响力。这种行为有时可以推动社会变革和进步。 然而在这里也存在一些可能的问题。举例来说，无论国内歌手的实际表现如何，过分强调竞争和比较可能会导致过度压力和对艺术的纯粹享受的失去。另外，一味地追求群体认同也可能容易导致解构主义心态，即缺乏对个体优点和特性的认识和欣赏。 所以在这样的情况下，既要鼓励提升水平，同时也应保持应有的尊重和欣赏。并且要理解，歌唱比赛只是比较个体或者队伍在特定时间和地点的状态，它并不能完全决定一个国家整体的歌唱水平或艺术成就。\n\nQ: 为什么观众会选择寻找新的唱将而不是支持国内歌手改进呢?\n\n这个问题很好，涉及到各种心理和社会影响层面。以下是一些可能的原因： 1. 期望和悲观主义： 观众可能认为，给现有国内歌手提升到与国际歌手一样的水准所需的时间和资源远大于找到新的、已经具备相当实力的歌手。因此，他们可能会觉得寻找新的唱将更为有效。 2. **更好的选择：**观众可能认为国内有更多具备潜力和实力的歌手，他们没有参加这个节目只是因为没有得到机会。因此，他们寻找新的唱将，意味着寻找到供广大观众认识、欣赏和支持的新的艺术家。 3. **改变与积极干预：**寻找新的唱将可以让观众感觉到他们能够对结果产生直接的影响。这种感觉可能基于我们人类的一种基本需求，那就是对环境进行控制并影响其未来的发展。 4. **心理安慰：**在赛后谴责国内歌手可能提供了观众一种心理安慰的方式，即寻找对失败的责任人，而选择寻找新的唱将则是他们试图矫正这种情况的方式。 以上所述只是可能的原因之一，具体情况可能会因为文化、社会和个体差异而不同。而最终，每一个观众都有他们自己的想法和原因。\n\nQ: 该节目由歌手之间的对抗，上升到国家和国际之间的对抗?\n\n当娱乐节目的竞争元素上升到国家与国际间对抗的程度时，它不再仅仅是对艺术能力的竞赛，而开始涉及到更深层次的身份认同问题和民族自豪感。以下是我对这个现象的一些分析： 1. 民族自豪感与国家荣誉： 事态升级可能使节目对观众变得更有吸引力，他们开始将比赛的结果与国家荣誉相联系。在这里，任何胜利都不再只是个人或团体的胜利，而是整个国家在国际舞台上的胜利。 2. 情绪投射和認同： 看待比赛的同时，观众可能会将自己的情绪，如欢乐、紧张、悲伤或满足感投射到国内歌手身上。因此，他们可能对比赛的结果有非常强烈的反应。 3. 社会凝聚力和集体身份： 把节目从个人比赛提升为一场国际对抗，可以提高团体的凝聚力，增强集体身份感。观众们可能会觉得他们是一个团队的一部分，共同努力实现一个目标。 然而，需要注意的是，这种计划在一些情况下可能有潜在的不利影响。例如，过度地强调国家比赛可能会引发过度的民族主义情绪，甚至导致文化偏见和冲突。此外，将这种比赛视为国家荣誉的象征，可能给参与者带来额外的压力，影响他们的表现。 总的来说，虽然这种情况可以带来激动人心的节目，并对观众产生强烈的吸引力，但是节目制作人员和投资人需要谨慎地处理这种挑战，防止产生任何负面的社会影响。\n\nQ：这些营销策略的影响\n\n营销策略对观众的影响主要通过观众的认知、情感和行为反应体现出来。以下是一些可能的影响： 1. 认知影响： 高质量的营销策略能够使观众对节目有着更深入的理解，这有助于塑造观众对节目的看法和对象的认知。 2. 情感反应： 营销策略如分享参赛者的背景故事，制造紧张点，可以引发观众的情绪反应，如激动，愤怒，喜悦，悲伤，情感的寄托也会使观众形成对节目的忠诚度。 3. 观众行为： 当营销策略成功地触动了观众的情感时，将导致观众的行为改变。这些行为可能表现为频繁观看节目，参与节目举办的线上或线下活动，如投票，分享节目内容等，并通过口碑推荐节目给他人。 4. 社会影响： 当节目从娱乐升级为国家或国际之间的竞争，可以引发社会的共鸣和民族认同感，同时也可能带来质疑和负面的争议。 5. 文化影响： 通过节目的传播，可能会产生文化交流和文化影响，影响观众的价值观和行为。 然而，值得注意的是，虽然这些营销策略将极大地影响节目的成功，但负责任地使用营销策略是至关重要的。例如，策划人员需要考虑到观众的多样性和节目内容可能对观众产生的负面影响。\n"},"Calendar/亚里士多德法则":{"title":"亚里士多德法则","links":[],"tags":[],"content":"1.弄清事实；\n2．分析事实；\n3．达成决定——然后依此行事"},"Calendar/关于-Calendar":{"title":"关于 Calendar","links":[],"tags":["readme"],"content":"以时间和日期为依据所建立的笔记，具有一定时效性。\n可以是以下几类：\n\n日常笔记\n会议笔记\n工作笔记\n日志笔记\n追踪笔记\n输出材料：文章、演讲等\n"},"Calendar/喝汤":{"title":"喝汤","links":[],"tags":[],"content":"\n玉米排骨汤\n紫菜蛋花汤\n西红柿鸡蛋汤\n"},"Calendar/如何休息":{"title":"如何休息","links":[],"tags":[],"content":""},"Calendar/威利斯·卡瑞尔公式":{"title":"威利斯·卡瑞尔公式","links":["Calendar/2024-02-29-忧虑","tags/忧虑"],"tags":["忧虑"],"content":"up:: 2024-02-29 忧虑\ntag::忧虑\n\n问你自己：“可能发生的最坏的情况是什么？”\n\n● 如果你必须接受的话，就准备接受它。\n● 然后镇定地想办法改善最坏的情况。"},"Calendar/忧虑减半的四个步骤":{"title":"忧虑减半的四个步骤","links":[],"tags":[],"content":"\n出了什么问题？\n产成该问题的原因是什么？\n问题有哪些解决方法？\n你自己建议使用哪一种？\n"},"Calendar/忧虑容易导致的3大疾病":{"title":"忧虑容易导致的3大疾病","links":["Calendar/2024-02-29-忧虑","tags/忧虑"],"tags":["忧虑"],"content":"⚠️upload failed, check dev console\nup:: 2024-02-29 忧虑\ntag::忧虑\n忧虑容易导致三大病\n生活中的有些事情会让我们恐惧，而恐惧的是事情不得不去做，会导致我们焦虑，焦虑会让我们紧张，神经紧绷。而紧张又会影响胃部神经，使胃里的胃液由正常变得不正常。\n忧虑导致的过度紧张而引起心脏病、消化系统溃疡和高血压。\n忧虑容易导致神经和精神问题\n忧虑的带来的情绪：焦虑、烦躁、悲观、恐惧、挫败、颓丧。长期处于这些情绪下，会产生神经和精神的问题，影响我们的身体健康。\n忧虑带来的情绪，也会影响我们的「行动」。\n忧虑容易导致关节炎和其他疾病\n关节炎\n康奈尔大学医学院的罗素·塞西尔博士是世界知名的治疗关节炎权威，列举了四种「最容易」得关节炎的情况：\n1．婚姻破裂。\n2．财务上的不幸和难关。\n3．寂寞和忧虑。\n4．长期的愤怒。\n\n蛀牙\n由于焦虑、恐惧等产生的不快情绪，可能影响到一个人身体的钙质平衡，而使牙齿容易受蛀。\n容貌\n忧虑会使我们的表情难看，会使我们咬紧牙关，会使我们的脸上产生皱纹，会使我们老是愁眉苦脸，会使我们头发灰白，有时甚至会使头发脱落。忧虑会使你脸上的皮肤发生斑点、溃烂和粉刺，这些都在影响着我们的容貌。\n甲状腺发应过度"},"Calendar/文件描述符":{"title":"文件描述符","links":[],"tags":[],"content":"from chatgpt:\n在Linux操作系统中，文件描述符（File Descriptor）是用于访问文件、套接字（sockets）、管道（pipes）和其他I/O资源的抽象概念。每个打开的文件、设备或者网络连接都会被分配一个唯一的文件描述符。文件描述符是非负整数，通常表示为整数值。\n在Linux中，前三个文件描述符是预留的：\n\n文件描述符 0：标准输入（stdin）\n文件描述符 1：标准输出（stdout）\n文件描述符 2：标准错误输出（stderr）\n\n当程序需要读取或写入文件、设备或网络连接时，它需要通过文件描述符进行操作。文件描述符可以通过系统调用（如open()、read()、write()、close()等）来创建、读取、写入和关闭文件。例如，通过open()系统调用打开一个文件会返回一个文件描述符，然后可以使用这个文件描述符来执行读取和写入操作。\n文件描述符的值在进程级别是唯一的，这意味着不同进程可以有相同的文件描述符值，但它们实际上代表不同的资源。文件描述符的管理由操作系统内核负责，它会在每个进程中维护一个文件描述符表，记录着每个文件描述符与相应资源的关联。\n总之，文件描述符在Linux中是一种用于管理文件、设备和其他I/O资源的抽象概念，它允许程序通过唯一的整数值来访问这些资源。\n参考\n\nChatGPT\n\n"},"Calendar/日记/2023-09-10-东角头徒步海岸线日记":{"title":"2023-09-10 东角头徒步海岸线日记","links":[],"tags":[],"content":"出门徒步拍视频这个想法已经存在脑海中很久了，但是这三年来一次都没有出门过。昨晚和朋友通宵聊天，才真正做这个决定，真正开始迈出第一步。\n咬咬牙，狠下心买了 300 多一顶的 New Era 帽子，自己也喜欢很久了。\n下午 1.2 点的时候下起了雨，刚好为我的徒步带来了凉爽。自已一个人出门徒步也是下了非常大的决心，还使用了手机拍摄了很多第一人称是视角的视频，想学着国外的 youtuber，把视频传到平台中上去，让我自己的徒步也有了目标，同时也能治愈自己，真正体会到生活的美好。\n遇到了和我撞衫的潮流爷爷、一对恩爱的情侣、孩子们的笑声、跑友、海浪声、香港给我发来的入境短信、以及贩卖机前准备支付时关机的手机、在美宜佳门口奢了一瓶橙汁。一切都感觉到非常美好，让我没有时间去想其他烦恼的事情。3点 40 左右出门，快 7点才回家，腿是累的精神却非常愉悦。\n在 B 站上上传了自己的第一人称视频，写日记时视频还在审核中，希望尽快审核通过。\n我不知道今后的我会变成怎么样，至少从这一次开始，我想要真正的改变自己。\n下一站设想的是徒步 深圳湾公园，期待我的下一个日记。"},"Calendar/日记/2023-09-17-周末深圳湾公园及海上世界-walk-日记":{"title":"2023-09-17 周末深圳湾公园及海上世界 walk 日记","links":[],"tags":[],"content":"热情没有退却，深圳湾公园还是去了，难得下定决心的事情可以坚持到现在，为自己点一个赞。\n上周和公司的一位小伙伴聊了很久，发现我们有类似的童年经历和性格，于是我们谈论了很多东西，包括家庭，性格，童年，音乐，等等，像一位素未谋面的故人。\n听说了我的深圳湾 walk 计划，他也饶有兴趣和我一起去深圳湾公园徒步。对了，为了和妹子缓和气氛，也大方的邀请妹子一起，可惜她没有空，还好我心里有提前预期，并没有打乱我的计划，希望下一次能够约到她。\n深圳湾公园的人特别多，徒步、跑去、骑行、拍婚纱照、遛娃等等。周边的洋溢的幸福笑脸，时不时吹来的海风，闲聊声、骑车声嘈杂的声音却使我内心安静，好想在那块草坪躺一个下午，享受自由自在的感觉。\n周日晚上去拍了深圳的夜景，来到了海上世界，晚上很热闹，车展、模特秀、灯光、音乐喷泉、拍照的人、成对的情侣、酒吧里的老外，在嘈杂声中获得心灵的自由。\n下一站还不确定是哪里，可能去室内景点逛逛，图书馆或者纪念馆。"},"Calendar/日记/2023-09-24-周末日记":{"title":"2023-09-24 周末日记","links":[],"tags":[],"content":"周六为了赶项目进度去了公司加班，在我的怂恿下我的测试同事也跟着来了。haha，中午和同事商量好要去楼下的川菜馆，99元吃的很饱，第一次尝到兔子肉的味道，巴适。\n晚上一个人回家吃烧烤，尝试了一些从来没有试过的菜品，味道不错。而且我一个人一张独立的桌子，但我却不尴尬，那时候我感觉非常勇敢，吃烧烤遇到少串的情况也多次和服务员反馈，又一次的突破了自己的舒适圈，而且效果都意外的不错。\n周日的日子也安排的满满当当，本来计划好去东角头老街的几个书店逛逛，吃吃。但计划赶不上变化，为了预约包皮手术，上午的时间耗在了医院，不过也挺佩服自己的，现在一个人看病自己可以完全搞定，虽然手术时间并不太理想但是我也能欣然接受。\n中午的时候本来约同事来东角头逛逛，但是被同事反向邀请到了宝安中心，在那边吃了个午饭，然后在附近的覔图书馆坐了一下午，把余华的《活着》看完了，本来没想着能完成的，最后竟然一口气看完了这 200 多页的书，真佩服自己的毅力。我发现自己的毅力没有我想的那么差，超出自己的预期很多。在书店的时间很舒服，各式各样的图书，眼花缭乱，一杯咖啡，一本书度过一个愉快的下午。\n看完书在书店闲逛的时候，发现了一对男女在学习Java，hhh 有点绷不住。\n和同事告别之后，自己顺路去了俞欣书店看看，书店挺漂亮的但是太小了，适合打卡拍照。拍完照在书店外面一楼的草坪坐着很舒服解压。\n最后回到了东角头，去吃了八宝牛杂，小刘炸豆腐。八宝牛杂也不赖，但是感觉没有旺角的好吃，旺角的牛杂肉香味很足，更推荐。\n下周这个时候估计是手术做完，在家里躺着。也有可能恢复的不错，和同事一起出去逛逛，可能是书店或者其他地方，多出去走走感觉自己变的越来越好了。"},"Calendar/日记/2023-10-06-国庆假期日记":{"title":"2023-10-06 国庆假期日记","links":["Calendar/日记/财富流---个人觉察"],"tags":[],"content":"9 月 29\n国庆假期的第一天，也是中秋节。因为前几天做了一个包皮手术，所以需要时间修养，今天没有什么其他安排，自己一人要留在深圳过节了，晚上实在是无聊，于是自己买了一张电影票去看了《好像也没有那么热血沸腾》，笑点密集近几年难得的国产喜剧片，电影院的观众也是非常的配合，笑点也感染到了我，让我感到没有那么孤单。\n电影看完，自己就一个人去了麦当劳解决晚餐的问题，路上顺便和赏月的家人打了一通视频电话，也聊了一段时间。吃完晚饭自己一个人在闲逛，计划着假期后面的安排，享受着当下自由的感觉。\n这么热闹的夜晚不舍得让自己这么早回去，于是又跑去海上世界看看夜景，去了之前没有爬过的二楼，去的太晚没有看到有什么活动，不过又在周边转了转，折腾的差不多了就回去了，明天还要去医院换药。\n9 月 30 \n今天因为有任务再身上，需要去医院换药，赶到医院医生开了一个换药的单子，快速换完药之后就离开了医院。不想浪费这个出门的机会，于是去车公庙吃了解决了午饭，上午的时间就这样结束了。\n下午在家打游戏躺尸，什么事情也没有做，哈哈时间有的时候就是拿来浪费的。\n总觉得自己待在家里太浪费时间了，于是想方设法的想让自己走出去，晚上就将就一下打卡了在东角头附近的一个「老顾客煲仔饭」，26 元挑选 4 样，吃的很饱味道也不错，值得二刷。\n吃饱了就去理发店剪了一个头，tony 实在是不给力，以后不去找那个托尼了。猛然想起，换一个理发店其实对于我来说也是突破舒适圈的过程，所以这个事情值得我去做。\n晚上，上家公司的同事联系到了我。换做之前我可能会尽量避免与他交流的，但是现在我想着要改变自己，于是我积极的回应，跟他约好了第二天去水湾创意社区玩。\n10 月 1\n上午还是一如既往的很晚醒，简单的吃了一个午饭。下午也是打打游戏，一直熬到了和朋友约定好的时间 4 点，去了水湾创意社区，看了一下周边的建筑，沾朋友的光参观了一下「现代办公室」，自信的人优势还挺大的，哈哈。\n和同事参观之后，在外面的一个小的休闲区域畅谈，聊了很多东西心里以及之前的经历，不知不觉天就黑了，我发现自己还是非常能聊的，没有我自己臆想的那样话不多，我现在就在践行之前的理论，走出自己的舒适圈，建立自己的自信。这天下午的谈话，让我坚信自己的想要做的事情，增强了改变自己的决心。\n聊到很晚，跑去海上世界的文创中心看，吹着海风欣赏周边的人群。人非常多的多，很热闹可能是我来深圳最热闹的一次。看完艺术中心，在附近的商圈吃了一个人均 200 多的自助（第一次吃这么贵的哈哈，这也是一种新鲜的尝试），味道是还行，不过确实有点贵。吃完又在附近逛逛消消食，结束了愉快的一天。\n10月 2\n今天是非常普通的一天，非常符合自己的人设，死宅哈哈。在家待了一整天，那也没有去，想着不能让自己太平凡，晚餐的时候让自己去了附近一家麦当劳哈哈。\n10 月 3\n今天是包皮手术的第二次换药，又去了一趟医院换药，医生额外的开了一些药，不出意外的话之后就不用再去医院了等待伤口自动恢复就好了。\n今天下午出门了，出门前还在犹犹豫豫的，发现只有出门了一切都是值得的，哈哈。来到想要来的咖啡店感受这里的氛围，真的很棒，灯光环境真的让人非常的放松，非常想要办公不知道为什么。果然有一个合适的环境是非常重要的。一个下午把今天的日记和之前的日记一次性补完了，如果是在家，不知道要拖延到什么时候才会开始写。\n这也启发了我，如果真的想要学习就需要去到一个非常适合学习的地方，比如咖啡店。对了，之前去的书店又有这种感觉。\n10 月 4\n上午又是无聊的度过，因为头一天已经计划好去南头古城了，所以打算今天下午 4 点钟去。没想到后面睡了一觉，又不想起，拖延到 4 点半才出门，不过好在最后还是出门了，出门真的所有的情绪都抛在脑后了，真的非常享受出门的感觉。\n跟着攻略去到南头古城，没想到假期快结束了还是人挤人的，没有仔细逛，去看了一些动物的展馆深圳历史的展馆，主要还是去看人的吧，哈哈，没有太多闲情逸致，最后走出去走到中山公园去了，还是公园好逛。非常的大，给人一种非常空旷的感觉，各种散步的大爷大妈，野餐的一家，聊天的情侣，草地上的风筝，耳机的音乐，哈哈人生从未有过的体验，感觉非常的棒。兜了一圈下来，体验非常好。这次没有走完，下次有空约朋友一起去。\n回来以后简单的在东角头附近吃了一个烧腊饭，味道还行，但是有一点小贵，今天就结束了。\n10 月 5\n必须说，这是我从小到大最勇敢的一次行为。舒适圈突破最大的一次，今天真的让我受益匪浅，让我大开眼界。\n因为 1 号的时候约了朋友一起吃饭，然后朋友顺便邀请我参加一个活动「财富流」，其实一开始的时候我就想着拒绝的（非常符合我的之前的性格哈哈），还内耗了一下会，如果换做之前的我肯定要内耗更久，我发现最近这段时间我真的有所进步，哈哈哈。\n约好的时间是今天的下午 2 点，我内心的渴望战胜了恐惧，参加了这个活动。活动的地点离我很远，而且都是陌生人，算是 debuff 叠满了。这也是我最近遇到最具有挑战的事情，活动的感觉给我非常棒，虽然都是陌生朋友，但我发现大家都非常的热情，所以我能说的我想表达的都能够得到倾述，我的表现也让我的朋友感到意外，哈哈，我就是一个自信的人 I am the  really confident guy。\n思想的共鸣，大家的讨论各种给与到我的能量，在这次的活动中让我真正能够感受自己的存在，让我真正开始热爱和喜欢自己的全新生活，我不是一个程序员，我是一个活脱脱的人。\n这次活动还有很多感悟，我还打算专门写一篇这个活动感悟，可以看我另一篇的财富流 - 个人觉察。\n活动结束，婵姐送了我两张给人觉察卡片，这是通过旁观者的视角给与我的一些看法。我觉得非常的受用。\n「你意识到自己是有价值的，变得越来越自信，机会也随之多了起来」\n「你意识到自己是一切问题的根源，于是不再抱怨，开始负担起责任，机会也越来越多」\n对了，还有茂哥给我的建议：「身份认同」「场」「机会的给与」，写日记的这一天正在消化和吸收这些，加油奥利给。\n10 月 6\n花房咖啡店的码字，将之前的日记在补一补，把自己昨天的感受写一写。我发现自己真的在一点点变化，生活中的人和事情给我的反馈都是那么的美好。\n在咖啡店待了 4 个小时，遇到一个漂亮的妹子，还坐我对面确实挺开心的。只是还缺少一点上去要微信的勇气，这个算是意外之喜吧。后面打算常来这个咖啡店学东西，真的很有 feel。\n国庆几天好像从来没有这么充实过，"},"Calendar/日记/财富流---个人觉察":{"title":"财富流 - 个人觉察","links":["tags/life"],"tags":["life"],"content":"tag::life\n我没有想到一款「游戏」能让我有非常不一样的体验。\n接触之前\n我像大多数人一样，初听这个名字会以为这仅仅是一个教你如何积累财富的「骗局」。\n我为什么会认为是「骗局」？因为我觉的这是成功人士，为了教你成功，创建的一款游戏仅此而已。我认为每个人的成功都不可复制的，所以他们给出成功经验更像是一种安慰穷人的做法，让你以为你可以成功。\n正式因为持有这样的「偏见」，我一开始才会有一些抵触甚至是讨厌。但迫于朋友的邀请，以及自己想要突破舒适圈的渴望，还是如约的参加这个游戏。\n\n写下这些的时候，又引发了我的思考🤔？\n\n为什么我会对自己不熟悉的领域有偏见？\n我的偏见是怎么来的？\n为什么有的时候我愿意为自己的偏见买单？\n这些偏见阻碍了我什么？\n\n\n游戏前期的体验\n来都来了是吧，该做的事情还是要做。听完游戏介绍和规则后随机抽取自己的角色（抽到了医生），开始了游戏。\n游戏有两个目标\n\n出圈：从平民的圈子跳出来成为富人圈（被动收入和精力达到角色要求即可）\n终极梦想：实现自己所追求的梦想。（钱 + 精力）\n\n游戏的终极目标实现自己的梦想（万人演讲、环球旅行等），从平民的圈子跳出来成为富人也是可以的，因为跳出来之后，富人想要去实现自己的梦想会很简单，大多都是时间和精力问题。\n游戏是分为三个人生阶段的：20 ~ 30（青年）、30 ~ 50（中年）、50 ~ 60（老年）。每个时期能做的事情有限制，每个人都是拿着自己的薪水和初始的精力，以及少许银行存款开始自己的游戏，游戏中的设定和规则都是贴近真实生活的。\n一开始还在熟悉规则，以及处于一个陌生的圈子中，触发了我的社恐 buff，表现的会比较拘束一点，遇到不懂的地方,也是大多数去问我旁边的审计（朋友）。\n\n写到「触发我的社恐 buff」的时候，我又发现自己将自己定义成了一个「社恐人士」，虽然我之前确实有社恐，但是我好想一直都喜欢给自己贴上这个标签，哪怕别人都不这么觉得。所以标签有的时候是你意识不到的，你想摘却看不见。\n\n在游戏的青年时期和中年时期，经历了人生低谷「失业」、也迎来了自己的高光「结婚」、「生娃」。但是对于「出圈」这个目标还是差的很远，因为自己的「被动收入」为 0，而恰巧自己的角色对被动收入的要求更高。但是值得庆幸的是，自己累积了一些收入、以及有足够的精力去做足够多的事情，还与其他玩家建立了合作关系，有了一定的人脉基础，只是自己还从未使用过。\n在前中期复盘的时候发现了自己的问题：虽然与其他玩家建立了人脉，但是缺少合作，以及开口的勇气，导致机会从自己手上流失，自己却没有察觉到。到了自己老年的时候，就需要善用已经存在的资源，否则单靠自己去实现破圈的目标是非常难的。\n不过好在前中期已经也有积累，现在只需要主动出击便可以将机会利用起来，帮助自己破圈。\n游戏后期的体验\n游戏后期，到了自己的老年时期了。直到这个时候我才真正的有目标感，想要为了破圈去做一些努力，向建立关系的玩家进行借贷，以及通过自己的努力去争取那最后的破圈机会。都说厚积薄发，我成为全场剩余的平民中最适合出圈的人，我拿到了最后出圈的机会，顺利出圈。\n在富人圈中与其他富人合作，开启了一场豪赌，最后直接赢得两个亿，此时终极目标已经显的没有那么重要了，追逐的过程已经证明了一切。\n游戏结束后，每个玩家都开始了对自己游戏的复盘。\n我的复盘\n「人脉」：我知道需要达到破圈的目的是避免不了与他人合作的，因此「人脉」在游戏一开始我遇到能够成就别人的机会就会积极的给到别人，从而建立起人脉关系。\n「自信」：虽然我早早的与他人建立了关系，但是却一直没有使用过，因为自己缺乏一些自信，不太敢与他人开口这也就导致别人不清楚你的情况，即使他能够帮助你，但你不开口她就永远不知道。收获了一个经典句子：开口就有 50% 的机会。\n「厚积薄发」：当你像我一样，前中期没有把握好机会的话，不要放弃不要怨天尤人，做好自己的积累与提升，这样机会来的时候才能把握住。只需要从自己身上做一些突破，便可以使用积累的资源实现破圈。\n「放平心态」：不以物喜，不以己悲，酸甜苦辣咸才是人生百味，只品尝一个味道就太单调了。生活就是这样可以很丰富也可以很平淡，选择固然重要，面对选择之后带来的不确定性更重要。\n我的收获，以及引申的思考\n在我总结了自己复盘之后，在场的玩家也给了我很多可能性，让我开始思考一些事情。\n教练通过他的上帝视角给与我的建议:\n\n你意识到自己是有价值的，变得越来越自信，机会也随之多了起来\n你意识到自己是一切问题的根源，于是不再抱怨，开始负担起责任，机会也越来越多\n\n收获到一些其他小伙伴的建议：\n\n身份认同\n场的概念\n机会的给与\n敢于试错\n\n上面的建议，有些有意识到的，有些则是来没有了解的，但是建议好像都没有转成实践。因此虽然我懂得一些道理，但还是在原地踏步，就像油箱里面装满了油，但是你却不启动发动机，尽管不会离目的地越来越远，却也永远达不到目标。\n写到最后，再再一次引发了我的思考，除了旁观者清外，为什么别人能够发现你的问题，并且给出恰到好处的建议。而当我去评价别人的时候，好像觉得别人很完美了，但其他人评价他的时候我也非常认同这个评价。\n简而言之，就是发现不了问题，或者意识不到问题所在。说起来会觉得有点可笑，认知不够连存在的问题都会看不到。因此提升自己的认知很有必要，他会让你意识到什么是问题，以及如何处理这些问题。\n最后的最后，也是非常感谢邀请我参加活动的小伙伴，没有他的邀请我也不会参加这个活动，也不会带给我这么多的思考了。"},"Calendar/身份认同的一些感悟":{"title":"身份认同的一些感悟","links":["tags/life","Spaces/Resources/博客/生活类/财富流---个人觉察"],"tags":["life"],"content":"tag::life\n工作三年的感悟\n不知不觉，已经出来工作三年了。三年来我也有过很多思考，像：技术能有什么大的突破、优秀的程序员都在干嘛、我以后的生活会更好吗？我以后怎么找到远程工作等等。\n我发现自己的精力都是在思考：作为程序员的我是如何规划自己的未来的。别人常说有职业规划是好事情，但在我身上我却发现这种规划成了束缚自我的枷锁，我更少的关注生活，更少的社交，更少的有突破舒适圈的行为。\n一直到最后我惊奇的发现，我好像什么事情都没有做成，还让自己陷入了内耗深渊。\n最近一两个月来，为了不让自己过多内耗，不让自己受原生家庭自卑的影响，阅读和收藏了一些经典的心里学书籍《不再害羞》《被讨厌的勇气》《当下的力量》，看过油管和 B 站大大小小数百个让你变得更好的自己的视频，所有的点最后都会指向「勇气」。\n「勇气」？当我看《被讨厌的勇气》最后几章的时，作者就提到了勇气，当时就在想可能又是一部理论书籍，因为道理我都懂但真要付诸实践还是算了。这些道理像麻醉剂一样，麻痹着我，我以为只要理解了这些就会变得更好。\n直到一个月前，我开始走出去，我才找到了我的生活。丰富的生活占据着我的精力，平日里莫名紧绷的神经在那一次得到了释放，出来后第一次感受到生活的美好。\n在 10 月 5 号参加的财富流游戏让我有了更多的感悟和思考。一个思考的点就是「身份认同」，我了解完之后发现了这个东西其实一直在影响着我，只是我一直没有察觉到。\n什么是身份认同\n维基百科中是这样定义：\n\n身份认同（英语：self-identity），又称为自我认同，是心理学和社会学的一个概念，指一个人对于自我特性的表现，以及与某一群体之间所共有观念（国籍或者文化）的表现。身份认同的类型大致可分为：拒绝、漂流、搜寻、保卫和坚定。身份与鉴定不同，身份是自我的标签，而鉴定是指一个分类的过程。身份是在心理学上构成一个人（自我身份）或群体（特定的社会类别或社会群体）的特质，信念，个性，相貌和/或表达。身份认同会因历史、文化和政治而改变。对身份进行分类可以是正面的或具有破坏性的\n\n我们每个人都有很多身份，像「儿子」「程序员」「司机」「老板」等等，把自己置身一个场景中，你就会开始诠释这个身份。\n例如：当你在工作中，你会是一个程序员，你就会做你认为程序员该做的事情，学技术，改bug 等等。在家庭中，你是一个儿子，你就会做儿子这个身份该做的事情。\n发现了吗？身份认同在影响着你的行为，甚至让你产成行为依赖，你会慢慢开始理解不了别人做的身份以外的尝试，慢慢你会发展成讥讽，嫉妒等心里。\n所以此时此刻，你需要好好想一想，身份认同给你带来了什么？好的一面是什么？坏的一面又是什么？\n身份认同会给你带来什么\n身份认同在我身上的体现就是，我强烈的认同自己程序员的身份。\n我发现，我做任何事情都喜欢用「程序员」的思维去思考问题，用程序员思维思考没有问题，相反，还能帮我挖掘事情的底层逻辑。\n但是，我发现自己好像只会用「程序员思维」去思考问题，所以看任何事情只有一个角度，这还不是要命的。更要命的是，我没有意识到自己一直以来只使用一种方式来思考，仿佛全世界只剩下这种思考方式。我还曾固执的以为程序员思维是高于其他思维方式的，因此也会拒绝或者是不屑使用其他方式思考，最终一直被「程序员」这个身份裹挟着前进。\n当然，身份认同不是一件坏事，他能让我们有认同感并在该身份下做自我诠释。问题在于不断的在特定身份做自我诠释，你会熟悉这个身份并且越来越依赖这个身份，若你没有独立思考的能力的话，你只会越陷越深。当你不再拥有这个身份时，你会发现自己失去了前进的动力，不知所措。\n因此我们需要身份认同，但也不能太依赖他，需要经常脱离已有的身份，尝试一些新的身份，扮演一些新的角色，这些会带给你很新的思考。世界不能只有一种声音，同样也不能只有一种思考。\n身份认同让我诠释了「程序员」这个职业，帮助我在现在的工作中能够游刃有余。\n但相反的，强烈的认同让我觉得程序员就应该缺少社交、就应该不爱说话、就应该不擅长与人打交道、就应该不太擅长表达和演讲。「就应该」3 个字是多么可怕，让我理所当然的认为自己所做的事情是对的，却毫无察觉到，我已经离「拥有优秀品质的人」这个目标越来越远了。\n如何去改变自己的身份认同\n在做改变之前，你必须得先意识到自己的身份认同，以及想要做改变的决心。身份认同可能会让你产生强烈的依赖，会成为你逃避或害怕改变的枷锁，当你需要跳脱当前身份时，你往往会退缩，然后给自己找借口安慰自己，更进一步强化自己不愿改变身份的意愿。最终自己囚禁在自己编织的茧房里面，越缠越紧。\n我一直都是以「程序员」这个身份自居，甚至会有点引以为傲，对其他行业的事情不太关心，甚至有的时候会有一些鄙视。我也不太清楚自己为什么会有这种行为，我好像很认同自己程序员的身份，后来发现强烈的身份认同是导致我自傲的原因，我决定要改变这种情况。\n说到改变，无一例外都是不舒服甚至是痛苦的过程。理论其实大家都知道，只是真要付诸行动，会发现怯懦无比。因此寻求改变也不能急于求成，需要通过完成一个一个的小挑战，突破一次又一次突破舒适圈，等你积累到战胜困难的自信，在向下一个更大的困难去发起挑战，此时改变已在你的身上悄无声息的发生了。\n小的挑战可以是很多日常的行为，例如：\n\n经常换早餐店吃早餐\n与陌生人打一个招呼\n换一种穿搭风格\n一个人去图书馆看书\n\n以上这些都是一些有一点难度，需要打破你原有的舒适圈，但是又不会让你想要放弃。当你积少成多，你也就有了脱离当前身份的勇气，走出去最大的收获在于「走出去」，So just do it。\n身份认同带来的思考\n安于现状和不断地做重复的事情，就是在编织自己的茧房。世界是多元的，人也应该是丰富的。\n我希望程序员的你，万一不幸被裁，你会像多啦 A 梦一样，从口袋里拿出一个新的赚钱的技能，来应对这个多变的社会。\nRelated\n身份认同 - 维基百科，自由的百科全书"},"Cards/Evergreen-Notes/CPU-中断":{"title":"CPU 中断","links":[],"tags":[],"content":"系统程序必须维护一份中断向量表，每一个表项纪录一个中断处理程序(ISR，Interrupt Service Routine)的地址\n当外部事件或异常产生时，由硬件负责产生一个中断标记，CPU根据中断标记获得相应中断的中断向量号，然后由CPU根据中断向量表的地址和中断向量号去查找中断向量表获得相应中断号的中断程序地址，进一步执行对应的中断处理程序。\n参考\n中斷向量 - 维基百科，自由的百科全书"},"Cards/Evergreen-Notes/DMA":{"title":"DMA","links":[],"tags":[],"content":"DMA 控制器（Direct Memory Access Controller）是计算机硬件的一部分，它允许某些类型的硬件子系统在不需要进行 CPU 的交互的情况下，直接访问系统内存。\n这就提供了一种快速的数据传输方式，数据可以直接从磁盘驱动器或其他设备（例如声卡、显卡等）传输到内存中，或者从内存直接传输到这些设备中，这样就避免了通过 CPU 进行数据传输的瓶颈，从而降低了 CPU 的负载并提高了整体系统性能。\nDMA 控制器就是使用了所谓的 直接内存访问（DMA）技术的硬件元件，将数据的传输责任从 CPU 转移到了 DMA 控制器本身。"},"Cards/Evergreen-Notes/QPS":{"title":"QPS","links":[],"tags":[],"content":"QPS 全称 Queries-Per-Second，即每秒查询数，是对 Web 领域网络相关的服务器的流量速率的度量。\n可以作为 web 应用系统性能评估的一项指标。"},"Cards/Evergreen-Notes/SPACE-学习法":{"title":"SPACE 学习法","links":["tags/学习方法"],"tags":["学习方法"],"content":"tag::学习方法\nS: Scan 粗看文档\nP: Problem 找问题\nA: Aim 定目标\nC: Code 写代码\nE: Endear 做分享\n使用 SPACE 学习 Docker\n\nScan 粗看 Docker 官方文档\nproblem 找问题：新手没机会使用 Docker\nAim 定目标：让新手使用 Docker\nCode 写代码：oh-my-docker\nEnder 做分享：上传代码，分享文章\n"},"Cards/Evergreen-Notes/东角头-渔人码头游玩指南":{"title":"东角头-渔人码头游玩指南","links":["Atlas/Travel-MOC","tags/travel"],"tags":["travel"],"content":"up:: Travel MOC\ntag::travel\ndates:: 2023-10-09\n渔人码头\n📍位置：🚉地铁 2 号线，东角头地铁站 A 口，随后跟着导航即可。\n🎒出门装备：帆布袋、墨镜、防晒。\n🗺️游玩指南：\n✔️海边散步、拍照、吹海风。\n✔️适合和家人朋友一起徒步。\n预览\n\n东角头-渔人码头 Walk_哔哩哔哩_bilibili\n"},"Cards/Evergreen-Notes/东角头游玩指南":{"title":"东角头游玩指南","links":["Atlas/Travel-MOC","tags/travel"],"tags":["travel"],"content":"up:: Travel MOC\ntag::travel\ndates:: 2023-09-25\n东角头\n📍位置：🚉地铁 2/8 号线东角头站，推荐 B 出口\n🎒出门装备：防晒、运动鞋、帽子（防止海风吹乱发型）、水（可选，公园也有贩卖机）\n🗺️游玩指南：\n✔️可以在去附近的蛇口老街或者蛇口新街吃东西\n✔️ 旺角牛仔（肉香味十足）、八宝牛杂、小刘炸豆腐、一个老阿姨的炸串、百草堂糖水\n✔️附近有海岸线，高德地图导航搜索关键字「灯塔」，步行前往即可，到达地点即可在海岸线 Walk\n预览\n\n东角头 Walks 1_哔哩哔哩_bilibili\n东角头 Walks 2_哔哩哔哩_bilibili\n"},"Cards/Evergreen-Notes/东角头花房咖啡游玩指南":{"title":"东角头花房咖啡游玩指南","links":["Atlas/Travel-MOC","tags/travel"],"tags":["travel"],"content":"up:: Travel MOC\ntag::travel\ndates:: 2023-10-09\n花房咖啡\n📍位置：🚉地铁 2 号线宝东角头站 A 或 B 出口，导航搜索花房咖啡即可。\n🎒出门装备：📚，或者笔记本。\n🗺️游玩指南：\n✔️咖啡店不大，有两层。窗外就是码头，风景很美，推荐去二楼。\n✔️二楼座位都有插座，适合带电脑去办公，看书。也有不少漂亮的小姐姐来打卡。\n✔️扫码点单，但是好像没有强制要求消费。\n预览\n\n暂无。\n"},"Cards/Evergreen-Notes/中山公园游玩指南":{"title":"中山公园游玩指南","links":["Atlas/Travel-MOC","tags/travel"],"tags":["travel"],"content":"up:: Travel MOC\ntag::travel\ndates:: 2023-10-09\n中山公园\n📍位置：🚉地铁 12 号线中山公园地铁站，根据导航选择一个最近的地铁口即可。\n🎒出门装备：帆布袋、墨镜、防晒。\n🗺️游玩指南：\n✔️一个非常大的公园，无需太多只指南，跟着路标行动即可。\n✔️有大片的草坪，适合野餐或者约会。\n预览\n\n中山公园 Walk-1\n中山公园 Walk\n"},"Cards/Evergreen-Notes/传统-Java-读取文件通过网卡发送过程":{"title":"传统 Java 读取文件通过网卡发送过程","links":["Disk_to_Kernel-2022-12-19-1014-2.excalidraw","kernel_to_JVM-2022-12-19-1014.excalidraw","JVM-to-Socket-2022-12-19-1014.excalidraw","Socket-to-NetworkCard.excalidraw"],"tags":[],"content":"Java 程序发起调用 FileInputStream.read 读取磁盘文件，使用 byte[] 对象接受数据，内存调用的全过程。\n文件数据从磁盘 copy 到内核缓冲区。\nTransclude of Disk_to_Kernel-2022-12-19-1014-2.excalidraw\n内核缓冲区将文件数据 copy 到 JVM 内存空间，byte[] 数组有了文件数据。\nTransclude of kernel_to_JVM-2022-12-19-1014.excalidraw\nJVM 将 byte 数组数据 copy 到 Socket 内核缓冲区\nTransclude of JVM-to-Socket-2022-12-19-1014.excalidraw\n内核缓冲区将数据 copy 到网卡发送。\nTransclude of Socket-to-NetworkCard.excalidraw"},"Cards/Evergreen-Notes/关注的-Telegram-群组信息":{"title":"关注的 Telegram 群组信息","links":[],"tags":["share/telegram"],"content":"\nt.me/V2EXPro  v2ex 交流群\nt.me/PlutoPlayer xiaoyapro\nt.me/yppshare 阿里云盘资源交流群\nt.me/yunpanpan 阿里云盘资源\nt.me/xhqcankao 风向旗参考快讯\nt.me/abskoop A 姐资源分享群\nt.me/tnews365 竹新社\nt.me/FreeChinese free中文\nt.me/OutsightChina 看鉴中国\nt.me/MCBooks Zlibrary.com\nt.me/warpplus wrap plus\nt.me/geekshare 极客分享\nt.me/TimeHorizonX time 经济观察\nt.me/chiguadalao 吃瓜大佬\nt.me/caozsay  caoz\nt.me/shareAliyun 阿里云盘机器人\n@DropmailBot 临时邮箱机器人\n@mcbooksbot 电子书机器人\n+16266670840 顺丰前运营\n@generatewarpplusbot  wrap key 机器人\n"},"Cards/Evergreen-Notes/判断-MacBook-是否第一次开机":{"title":"判断 MacBook 是否第一次开机","links":[],"tags":["鉴别/MacBook"],"content":"来自 v 友的鉴别 macbook 是否开过机，他本人也在从事  apple 产品的销售\n"},"Cards/Evergreen-Notes/南头古城游玩指南":{"title":"南头古城游玩指南","links":["Atlas/Travel-MOC","tags/travel","Cards/Evergreen-Notes/中山公园游玩指南"],"tags":["travel"],"content":"up:: Travel MOC\ntag::travel\ndates:: 2023-10-09\n南头古城\n📍位置：🚉地铁 12 号线中山公园 D 出口，往前一直走就能看到。\n🎒出门装备：帆布袋、墨镜、防晒。\n🗺️游玩指南：\n✔️去的那天人特别多，建议避开人多的时段\n✔️走进去两边大多都是有特色的商铺，有植物展和动物展。\n✔️有一个深圳经商历史的小展馆也可以看看，一直往前走可以去中山公园游玩\n预览\n\n暂无。\n"},"Cards/Evergreen-Notes/国内外博主视频风格差异":{"title":"国内外博主视频风格差异","links":["Sources/People/🙎🏻‍♂️方应杭"],"tags":["视频"],"content":"平台差异\n国外：YouTube 简称「油管」\n国内：bilibili 简称 「B 站」\n开场动画\n油管中的大多数技术博主都有使用开场动画，会给人一种带入感，给观众预热的时间。\nB 站的技术博主则很少使用开场动画，一些比较硬核，大 up 会有开场动画。\n背景音乐\n油管中的背景音乐使用很多，而且背景音乐大多数都是以轻音乐为主，会给观众一种舒缓的感觉。并且大多数的博主都有自己的选曲风格，视频风格多样。\nB 站中的大部分 up 也会使用背景音，up 之间的曲子都相似，使观众新鲜感降低。\n语言和表情\n这部分也是差异最大的地方。\n油管技术博主面对镜头都比较自然随意，且面部表情丰富。能通过博主的表情，感受到他的真诚。\nB 站则较少有能面对镜头这么自然的 技术 up，都是侧脸居多手部动作较少，语速和神情会相对差一些。技术领域比较满意的 up 主，目前看到了🙎🏻‍♂️方应杭。"},"Cards/Evergreen-Notes/提高自信心的方法":{"title":"提高自信心的方法","links":["tags/life/skill"],"tags":["life/skill"],"content":"tag::skill\ndates:: 2023-09-24\n只有一种可靠的方法可以让我们重拾信心\n尝试我们从未做过的事情。其实去做一些从未做的事情是在突破我们的舒适圈，突破舒适圈的行为必然会让你有一点困难，但正是如此，完成一件困难的事情才会让你真正的拥有自信。\n当遇到自己做不到的事情时，我们要做的不是去找做不到的理由，相反思考并找到我们能做到的原因。有的时候困难其实能突破，但是自己给自己设限，总觉得自己做不到，然后给自己找理由自我安慰，这其实也是一种逃避。"},"Cards/Evergreen-Notes/海上世界游玩指南":{"title":"海上世界游玩指南","links":["Atlas/Travel-MOC","tags/travel"],"tags":["travel"],"content":"up:: Travel MOC\ntag::travel\ndates:: 2023-09-24\n海上世界\n📍位置：🚉地铁 2/8 号线海上世界站，推荐 A 出口，出地铁就能看到大轮船，夜景优秀，建议夜间出门。\n🎒出门装备：无。\n🗺️游玩指南：\n✔️出地铁口直走，到头左转，可以看到很多国外餐厅，可以绕游轮一周。\n✔️夜间有音乐喷泉，一般时间为晚上 7 点开始，每隔半小时一次。\n预览\n\n海上世界 Walks - 地铁口一镜到底_哔哩哔哩_bilibili\n深圳海上世界 walk - 中段视角_哔哩哔哩_bilibili\n海上世界 walk - 音乐喷泉_哔哩哔哩_bilibili\n"},"Cards/Evergreen-Notes/深圳书店游玩指南":{"title":"深圳书店游玩指南","links":["Atlas/Travel-MOC","tags/travel"],"tags":["travel"],"content":"up:: Travel MOC\ntag::travel\ndates:: 2023-09-25\n覔书店\n📍位置：🚉地铁 5 号线宝安中心站，F 口出门就是商场负二楼，书店在3 楼 。\n🎒出门装备：无。\n🗺️游玩指南：\n✔️书店所在的商场非常大，美食集中在负二楼，各种小吃，人也是非常多。\n✔️书店附近有咖啡店和奶茶店，店内免费阅读，无强制消费。\n愈欣书店\n📍位置：🚉地铁 5 号线铁路公园站 B 口，书店就在附近。\n🎒出门装备：无，有相机记得带相机。\n🗺️游玩指南：\n✔️书店所处位置人较少，在二层，店内无强制消费（听说茶水很贵），内有自习室（收费），整个书店面积很小。\n✔️书店比较精致，适合拍照打卡，不适合阅读。\n预览\n\n暂无。\n"},"Cards/Evergreen-Notes/深圳湾公园游玩指南":{"title":"深圳湾公园游玩指南","links":["Atlas/Travel-MOC","tags/travel"],"tags":["travel"],"content":"up:: Travel MOC\ntag::travel\ndates:: 2023-09-24\n深圳湾公园\n📍位置：🚉地铁9号线深圳湾公园站，推荐 D2 出口（网红打卡点，出地铁就是海）\n🎒出门装备：防晒、运动鞋、帽子（防止海风吹乱发型）、水（可选，公园也有贩卖机）\n🗺️游玩指南：\n✔️沿海岸线右走可以偶遇海鸥，跟海鸥来一场亲密接触\n✔️沿海岸线向左走是红树林和大片草地，合适野餐、遛弯、拍婚纱\n预览\n\n深圳湾公园 Walk - 红树林\n深圳湾公园 Walk - 海岸线\n"},"Cards/Evergreen-Notes/表扬努力的两个方法":{"title":"表扬努力的两个方法","links":[],"tags":[],"content":"\n表扬过程\n\n表扬他们在某件事上的努力\n表扬过程可以潜意识让的孩子将结果和努力之间产生关联\n\n\n赞美具体而真诚\n\n孩子可以识别不真诚的赞美\n赞美孩子为了增强他们的自尊\n表扬尽可能具体，对孩子有意义\n\n\n"},"Cards/Evergreen-Notes/赞扬孩子努力而不是能力":{"title":"赞扬孩子努力而不是能力","links":["tags/life/habit","Cards/Evergreen-Notes/表扬努力的两个方法"],"tags":["life/habit"],"content":"tag::habit\ndate created:  2023-08-14\n表扬是孩子成长的一个非常重要的因素，他用于激励和鼓励儿童。但不要表扬孩子的天赋，而是要赞扬他们为实现目标做的努力。\n表扬天赋，孩子以后受挫时会更容易产生对失败的恐惧。\n表扬努力，有利于帮助孩子拥有承担风险，面对失败的能力。\n表扬努力的两个方法\n参考\nPraising Children For Effort Rather Than Ability"},"Cards/Evergreen-Notes/锻炼英语思维的几种方式":{"title":"锻炼英语思维的几种方式","links":["tags/english/skill"],"tags":["english/skill"],"content":"tag::skill\ndate:: Tue Oct 22:54\n使用简单的词汇\n停下来看看四周，使用简单的词语去描述你身边的物品，描述的同时需要注意发音（尽可能参考英语母语者的发音）。\n记下并查找那些不知道怎么说的词语，学习他们的英文表达，你所处的场景会帮助你记住它。\n使用简单的句子描述自己\n想一个以「我」开头的句子：我累了、我饿了等等。\n可以使用简单的句子，描述当前的所处的场景，例如电视没有关、桌面很乱等等。\n使用英语与自己对话\n每天花一段固定的时间去自己和自己对话（2 分钟或者 5 分钟），坚持 30 天。坚持成功之后，再坚持 30 天。\n将一件日常生活的事情转化为英语\n使用英文的月份和星期、用英文写下你要去哪里、要做哪些事情、使用英文系统、说明书等等。\n持之以恒\n继续坚持，确保每天都在做这件事情。用英语描述你学习英语的心得，可以在睡觉前用英语回顾自己的一天。\n扩展\n看英语资料、视频等。\nRelated\nThinking in English"},"Cards/Evergreen-Notes/零拷贝-mmap":{"title":"零拷贝 mmap","links":["zero_copy_mmp.excalidraw","Cards/Evergreen-Notes/DMA"],"tags":["零拷贝/mmap"],"content":"将用户缓冲区的一块空间和内核缓冲区的空间进行映射。这样 cpu 不需要在内核缓存区和用户缓存区之间 copy 数据。\nTransclude of zero_copy_mmp.excalidraw\n具体执行过程：\n\nDMA 读取磁盘数据到内核缓冲区，用户的应用程序共享该缓冲区\ncpu 将内核缓冲区数据 copy 到 Socket 缓冲区\nDMA 将 Socket 缓冲区数据 copy 到网卡中发送\n\nJava 中对应的实现\nJava 中使用了 MappedByteBuffer 实现 mmap。"},"Cards/Evergreen-Notes/零拷贝-sendfile":{"title":"零拷贝 sendfile","links":["Cards/Evergreen-Notes/传统-Java-读取文件通过网卡发送过程","zero_copy_sendfile.excalidraw","Cards/Evergreen-Notes/DMA","Calendar/文件描述符","zero_copy_sendfile_upgrade.excalidraw"],"tags":["零拷贝/sendfile"],"content":"相比传统 Java 读取文件通过网卡发送过程中，省略了内核缓冲区 copy 到用户缓冲区的过程。\n直接把数据在内核空间进行拷贝，减少了上下文切换（内核空间切换到用户空间）。\n由内核缓冲区将数据拷贝到 Socket 缓冲区，然后通过网卡发送数据。\nTransclude of zero_copy_sendfile.excalidraw\n具体执行过程：\n\nDMA copy 数据到内核缓冲区\ncpu copy 数据到 socket 缓冲区\nDMA 将 Socket 缓冲区数据 copy 到网卡发送\n\n改进\n由内核缓冲区直接拷贝到网卡发送，少了一次内核缓冲区 copy 到 Socket 缓冲区的过程。Socket 缓冲区只需要接受文件描述符数据和数据长度即可。\nTransclude of zero_copy_sendfile_upgrade.excalidraw\n具体执行过程：\n\nDMA copy 数据到内核缓冲区\n将文件描述符和数据长度传给 Socket 缓冲区\nDMA Gather copy 将数据 copy 到网卡发送\n\n缺点\nsendfile 的实现中，文件的数据都没有拷贝到用户空间，因此用户程序无法对读取的文件数据进行修改。\nJava 中对应的实现\nJava 中使用了 FileChannel.transferTo 的方法实现 sendFile。"},"Cards/Evergreen-Notes/零拷贝-splice":{"title":"零拷贝 splice","links":["Calendar/文件描述符","zero_copy_sendfile_pipeline.excalidraw"],"tags":["零拷贝/splice"],"content":"splice 系统调用就是实现零拷贝的一种方式，它可以将数据从一个文件描述符移动到另一个文件描述符，这两个文件描述符都可以指向网络套接字或者磁盘文件。将数据从一个文件描述符移动到另一个文件描述符时，实际的数据移动操作完全在内核空间完成，所以不需要进行额外的数据复制操作，这就实现了零拷贝。\n在内核空间建立 Pipeline，内核缓冲区和 Socket 缓冲区之间建立管道，避免拷贝。\nTransclude of zero_copy_sendfile_pipeline.excalidraw"},"Cards/Evergreen-Notes/零拷贝":{"title":"零拷贝","links":["Cards/Evergreen-Notes/传统-Java-读取文件通过网卡发送过程","Cards/Evergreen-Notes/DMA","Cards/Evergreen-Notes/CPU-中断","Cards/Evergreen-Notes/零拷贝-mmap","Cards/Evergreen-Notes/零拷贝-sendfile","Cards/Evergreen-Notes/零拷贝-splice"],"tags":["零拷贝"],"content":"传统上，数据从一个地方传输到另一个地方，通常会涉及到多次内存拷贝操作。像传统 Java 读取文件通过网卡发送过程中涉及到数据的拷贝有 4 次。\n为了避免占用太多 cpu 时间，使用了 DMA 代替 cpu 做 I/O 设备和内存之间的数据传输，使用 CPU 中断进一步压缩 cpu 的使用时间。\n但以上的操作无法减少「拷贝次数」，零拷贝则减少了文件拷贝次数。\n零拷贝的几种实现\n\n零拷贝 mmap\n零拷贝 sendfile\n零拷贝 splice\n\n参考\n零拷贝wiki"},"Cards/Pending/Kafka":{"title":"Kafka","links":["Cards/Pending/kafka-的消息分区","Cards/Pending/kafka-的消息分片","Cards/Pending/kafka-消费数据","kafka-数据的副本"],"tags":["MQ","中间件","review"],"content":"Kafka 的功能\n\nkafka 的消息分区\nkafka 的消息分片\nkafka 消费数据\nkafka 数据的副本\n\nKafka 的问题\n\n分区是并发的单位，分区数量限制并发度（读 / 写）\n增加分区会增大不稳定性 / 延迟，降低性能\n每个 topic 包含固定数量的分区，Topic 数量受到限制\n\n引用\n如何选择 kafka topics 分区的数量"},"Cards/Pending/RocketMQ":{"title":"RocketMQ","links":[],"tags":["review"],"content":"功能\n\n订阅与发布\n顺序消息：全局有序和分区有序\n消息过滤\n事务消息\n消息重投\n流量控制\n\n架构\n\nName Server\n\n无状态的命名空间管理\n每个 broker 将自己注册到所有 Name server\n\n\nBroker\n\n异步复制\n同步双写\n\n\nProducer\n\n无状态，写 master\n\n\nConsumer\n\n可与 master / slave 交互，master 建议下次 pull 的位置\n\n\n"},"Cards/Pending/kafka-消费数据":{"title":"kafka 消费数据","links":[],"tags":["review"],"content":"消费模型\n\npull / push\n\n消费数据肯存在的问题\n\n消息重复消费\n消息丢失\n解决方法：使用手动 commit 和 自动 commit。\n"},"Cards/Pending/kafka-的消息分区":{"title":"kafka 的消息分区","links":["Spaces/Projects/消息队列/消息队列"],"tags":["review","mq/kafka"],"content":"每个 Topic 都有分区\n\n生产者可以指定分区，也可以自动分区\n\n可以指定消息存放的分区\n可以根据 mq 自动选择存放分区\n\n\n数据以分区为单位进行并发和持久化\n同一个分区保证消费顺序\n同一个消费者只投递一次（）\n\nTopic 中的消息被平均分配到同组的消费者\n每个消费组都会得到 Topic 中的所有消息\n\n\n\n"},"Cards/Pending/kafka-的消息分片":{"title":"kafka 的消息分片","links":["Spaces/Projects/消息队列/消息队列"],"tags":["review"],"content":"使用集群定时同步 Broker 之间的消息。"},"Cards/关于-Cards":{"title":"关于 Cards","links":[],"tags":[],"content":"任何可以称之为「事物」或「关于事物的陈述」的知识。\n随着时间的推移，你可能还会在这里建立一些子文件夹。如果我是一个业余厨师，菜谱笔记越来越多，我会在这里放一个「菜谱」文件夹。如果我正在建立一个重要练习的个人图书馆，我可能会建立一个「练习」文件夹。"},"Excalidraw/Drawing-2023-08-21-17.20.54.excalidraw":{"title":"Drawing 2023-08-21 17.20.54.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠"},"Excalidraw/Drawing-2024-03-15-10.38.47.excalidraw":{"title":"Drawing 2024-03-15 10.38.47.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nText Elements\n共享 \n校库 \n拒绝，无操作 \n通过，copy 一样的数据，并且\nopenStatus 为公开类型 \n存在历史版本 \n否 \n版本记录表添加一条记录数据，关联源实训id和共享出去的实训id \n是 \n根据源实训id查记录表 \n查找当前使用的版本，修改实训为关闭状态，然后添加一条公开的实训 \n版本记录表，添加一个，使用标记字段，标记当前使用的版本是哪一个 "},"Sources/Articles/未命名":{"title":"未命名","links":[],"tags":[],"content":""},"Sources/Books/📚人性的弱点":{"title":"📚人性的弱点","links":[],"tags":[],"content":"70% 的烦恼与金钱有关系\n公司有专门的人员来管理公司的财务信息，以免陷入财务危机。作为自己的唯一负责人，我们应当更需要这个技能，学会如何管理金钱。\n\n记录自己的支出（从大到小每一笔都要记录，可以记录 1~3 个月的）。\n根据记录的支出，拟出适合自己的预算\n\n预算的意义：预算的意义，并不是要把所有的乐趣从生活中抹煞。真正的意义在于给我们物质安全感。从很多情况下来说，物质安全感就等于精神安全和免于忧虑。依据预算来生活的人，比较快乐。\n如何根据开支拟定自己的预算？\n\n书上提到的是找专业的人士求助\n现实中，寻找一些优质博主他们的经验\n\n\n\n\n聪明地花钱\n\n学习使用钱得到最高的价值\n\n\n当收入增加时，需要注意自己所支出是否存在很多非必要支出。\n教育子女对金钱负责的态度\n\n如何教育的问题？\n\n\n不要赌博 never，当你真正知道赌博失败的概率就会知道自己的行为有多愚蠢。\n如果无法改善经济情况，不放宽恕自己\n\n放平自己的心态，不要陷入攀比，虚荣的陷阱。\n不要让金钱的忧虑，影响我们的生活。一个人生活上的快乐，应该来自尽可能减少对外来事物的依赖。\n\n\n"},"Sources/Books/📚被讨厌的勇气":{"title":"📚被讨厌的勇气","links":[],"tags":[],"content":""},"Sources/Books/📚这本书能让你戒烟":{"title":"📚这本书能让你戒烟","links":[],"tags":[],"content":""},"Sources/Books/📚遇见心想事成的自己":{"title":"📚遇见心想事成的自己","links":[],"tags":[],"content":""},"Sources/Books/📚遇见未知的自己":{"title":"📚遇见未知的自己","links":[],"tags":[],"content":"list \nfrom #遇见未知的自己 "},"Sources/Courses/About-Courses":{"title":"About Courses","links":[],"tags":[],"content":"关于一些网络课程产生的笔记。"},"Sources/People/🙎🏻‍♂️方应杭":{"title":"🙎🏻‍♂️方应杭","links":[],"tags":["IT","全栈"],"content":"一个知名的全栈工程师，前阿里、腾讯员工，目前自己创业做教育培训（主要是前端相关的技术栈）。\n直播和视频有自己的风格，是一个擅长讲知识的博主。\n你可以从这些地方了解他\n\n[B 站主页🔗](space.bilibili.com/4349808）\n知乎主页🔗\n一位普通前端开发对方应杭的印象\n"},"Sources/Podcasts/别让情绪夺走你的魂魄":{"title":"别让情绪夺走你的魂魄","links":["tags/情绪"],"tags":["情绪"],"content":"tags::情绪\nlinks:: VOL.087：别让情绪夺走你的魂魄 - 肥话连篇 | 小宇宙 - 听播客，上小宇宙\n\n先处理情绪，再处理问题。\n"},"Sources/Podcasts/张云帆《芒格之道》：对知识诚实，是你能给自己的最好礼物":{"title":"张云帆《芒格之道》：对知识诚实，是你能给自己的最好礼物","links":[],"tags":[],"content":"E110 与张云帆聊《芒格之道》：对知识诚实，是你能给自己最好的礼物 - 知行小酒馆 | 小宇宙 - 听播客，上小宇宙\n面对知识的方法论：\n\n消化（把知识变成自己的版本，用自己熟悉的，人生经历匹配的东西将它消化）\n"},"Sources/Podcasts/情绪自救座谈会实录":{"title":"情绪自救座谈会实录","links":["tags/情绪"],"tags":["情绪"],"content":"tags::情绪\nlink:: www.xiaoyuzhoufm.com/episode/64b6dfebd0844ea812f18164\n\n 情绪不好的时候，情绪理不清的时候，可以用笔写下来自己的情绪和感受，帮助自己理清自己的情绪。\n 表达自己的消极情绪，也是为自己在纾解，精确地表达情绪更棒。\n\n完成比完美重要\n\n小事情，可以一件一件的拆分，一步一步去做。就像爬山一样，有劲只顾往上爬就好了。\n取得一些成果之后，把自己的成果记录下来，记录的方式可以帮你确认自己做过的东西是有价值的（可以拿出来用来提醒自己）\n焦虑的反义词是「具体」\n心里问题是有正反两样性的\n\n从理论变成实践（郑重的承诺，和强烈的改变动机）\n\n得把自己所学的东西，想要去时间的时候，当成一个郑重的承诺。\n\n明白自己为什么想要做出改变？\n当前的状态有什么好的地方，以及不好的地方？\n改变的话，我能得到什么好处？\n改变的代价有那些？（时间，金钱）能接受改变并不好使的情况。\n\n\n\n一个改变的案例\n\n体检发现自己的颈椎曲度变值，确定会影响健康，而且自己确实想要去调整，这就是改变的动机\n放下自己的怀疑，不要对自己所做的改变有太大的期待（否则会有很大的挫败感），坚持去做就好了\n做的过程中，不要给自己太完美的目标。例如：你想要养成跑步习惯，你给自己的目标可以是，每天出门跑3分钟就好，因为核心是开始跑步。\n\n有效休息\n\n找一些给自己积极体验，又能够恢复精力的事情。比如：出去和朋友聊天，做自己爱好的事情，不要定的太慢，去体验过程中的放松，自在的感觉。\n无所事事的时候，不要有罪恶感，允许自己发呆、放空的度过这段时间\n\n书单\n\n《打破焦虑循环》\n《自我关怀的51项练习》\n《幸福的陷阱》\n"},"Sources/关于-Sources":{"title":"关于 Sources","links":[],"tags":[],"content":"一些资源，也可以称作「文献笔记」。用于收集一些文献资料，给自己的常青笔记提供理论支持。\n文献笔记需要用自己的话翻译一遍，这会迫使自己充分阅读所记录的内容，能够在下次需要的时候快速记起并使用。"},"Spaces/Areas/Areas-MOC":{"title":"Areas MOC","links":["Spaces/Areas/日落咖啡-Sunset-Garden","花房咖啡"],"tags":[],"content":"个人形象管理\nlist\nfrom #穿搭 \n深圳咖啡馆\n\n日落咖啡 Sunset Garden\n花房咖啡\n\nlist\nfrom &quot;Spaces/Areas/深圳咖啡馆&quot;"},"Spaces/Areas/Maven/Maven-依赖":{"title":"Maven 依赖","links":["Atlas/Maven-MOC","tags/maven/依赖","Spaces/Areas/Maven/Maven-坐标","Spaces/Areas/Maven/依赖范围","Spaces/Areas/Maven/传递性依赖","Spaces/Areas/Maven/可选依赖","Spaces/Areas/Maven/依赖冲突解决原则"],"tags":["maven/依赖"],"content":"up:: Maven MOC\ntag::依赖\ndates::  2023-09-08\nmaven 的每个依赖包都可以修改下列属性：\n\ntype： 依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，默认为 jar。\nscope： 依赖的作用范围。\noptional： 标记依赖是否可选。\nexclusions： 用来排除传递性依赖。\n\n上面的属性标签可以添加在 Maven 坐标中，示例如下。但大多数情况依然只需要 groupId、artifactId、versioin 这三个即可。\n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n    &lt;artifactId&gt;guava&lt;/artifactId&gt;\n    &lt;version&gt;32.1.2-jre&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n\n依赖范围\n传递性依赖\n可选依赖\n依赖冲突解决原则\n"},"Spaces/Areas/Maven/Maven-坐标":{"title":"Maven 坐标","links":["Atlas/Maven-MOC","tags/maven/坐标"],"tags":["maven/坐标"],"content":"up:: Maven MOC\ntag::坐标\ndates::  2023-09-08\nmaven 的坐标，每个依赖包都有一个唯一的坐标，像地图一样用经纬度可以对应唯一的点。\nmaven 的坐标包含以下信息：\n\ngroupId：命名通常为域名反向一一对应。比如 google.com 可以命名为 com.google。\nartifactId：命名推荐的做法是使用实际的项目名称作为 artifactId 的前缀。比如项目名是 demo，下面有个 hello 模块，就可以命名为 demo-hello。\nversion：定义当前项目的版本信息。\npackaging：定义元素打包方式，打包方式通常与所生成的构件文件扩展名对应。例如指定为 jar 则构件的文件扩展名为 .jar，war 也如此。不定义 packaging 时，默认打包为 jar。打包方式会影响到构建的生命周期，比如 jar 和 war 打包会使用不同的命令。\nclassifier：定义构建输出的一些附属构建。例如项目打包生成 demo.jar 文件，打包过程中可能还需要 javadoc 文件，就可以配置对应的插件来生成 javadoc 文件。\n\n通常定义一个外部依赖，只需要 groupId、artifactId、version 。例如，项目中需要引用一个 guava 的依赖包，添加的依赖坐标如下：\n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n    &lt;artifactId&gt;guava&lt;/artifactId&gt;\n    &lt;version&gt;32.1.2-jre&lt;/version&gt;\n&lt;/dependency&gt;"},"Spaces/Areas/Maven/Maven-插件":{"title":"Maven 插件","links":["Atlas/Maven-MOC","tags/maven/插件","Spaces/Areas/Maven/插件的基本概念","Spaces/Areas/Maven/插件配置"],"tags":["maven/插件"],"content":"up:: Maven MOC\ntag::插件\ndates:: 2023-09-09\nmaven 的插件是 maven 的一大特色，可以说 maven 插件才是 maven 的灵魂所在。\n\n插件的基本概念\n插件配置\n"},"Spaces/Areas/Maven/Maven-生命周期":{"title":"Maven 生命周期","links":["Atlas/Maven-MOC","tags/Maven","Spaces/Areas/Maven/Maven-插件","Spaces/Areas/Maven/clean-生命周期","Spaces/Areas/Maven/default-生命周期","Spaces/Areas/Maven/site-生命周期"],"tags":["Maven"],"content":"up:: Maven MOC\ntag::Maven\nmaven 的生命周期其实就是软件从初始化到发布上线经历的一系列过程。maven 将这个过程抽象化了，每个周期所执行的操作都是交给 Maven 插件完成。\nmaven 拥有三套相互独立的生命周期，分别是如下：\n\nclean 生命周期\ndefault 生命周期（主要）\nsite 生命周期\n\n每个生命周期都包含一些阶段（phase），这些阶段都是有顺序的，并且后面的阶段依赖于前面的阶段。比如 clean 生命周期包含: pre-clean，clean，post-clean 阶段，当用户调用 pre-clean，只有 pre-clean 阶段会执行，当调用 post-clean 时，pre-clean，clean，post-clean 都会执行。由于三个生命周期互不影响，当调用某个生命周期的某个阶段时，对其他的生命周期没有任何影响。\n命令行与生命周期\n一些常见的 Maven 命令，解释其执行生命周期：\n\nmvn clean 调用 clean 生命周期的 clean 阶段，即执行 pre-clean 和 clean阶段。\nmvn test 调用 default 生命周期的 test 阶段，即执行 validate、compile、test 阶段。\nmvn clean install 调用 clean 生命周期的 clean 阶段，以及 default 生命周期的 install 阶段。即执行 pre-clean和 clean阶段，以及 validate到 install的所有阶段。\nmvn clean deploy site-deploy 调用 clean 生命周期的 clean 阶段，default 生命周期的 deploy 阶段，以及 site 生命周期的 site-deploy 阶段，实际执行过程按照上面类推。\n"},"Spaces/Areas/Maven/Maven-继承":{"title":"Maven 继承","links":["Atlas/Maven-MOC","tags/maven/继承","Spaces/Areas/Maven/Maven-聚合","Spaces/Areas/Maven/可继承的父类-pom元素","Spaces/Areas/Maven/选择性继承"],"tags":["maven/继承"],"content":"up:: Maven MOC\ntag::继承\ndates::  2023-09-08\n继承如同 Java 的继承一般，子类继承父类的属性，最大程度的消除重复。\n假如有 A，B两个模块都需要 spring-core 2.0 版本的依赖，正常的做法就是在两个模块中分别声明同一个 spring-core 依赖。\n使用继承消除重复配置，新建一个模块 C，修改打包方式为 pom (与Maven 聚合操作一致)，接着引入 spring-core 依赖，即可。这时 A，B 模块只需要继承 C 的 pom 即可，代码如下。\n&lt;parent&gt;\n  &lt;groupId&gt;C 模块groupId&lt;/groupId&gt;\n  &lt;artifactId&gt;C 模块artifactId&lt;/artifactId&gt;\n  &lt;version&gt;C 模块version&lt;/version&gt;\n  &lt;relativePath&gt;C 模块pom.xml路径（相对路径）&lt;/relativePath&gt;\n&lt;/parent&gt;\n引入 C 模块的坐标信息，并使用 relativePath 指向 C 模块的 pom 文件路径。Maven 会首先根据 relativePath 找 pom，找不到就去本地仓库找，如果不配置 realtivePath，那默认值是 ../pom.xml，也就是说 Maven 默认父模块在当前模块的上一层目录。\n在上面的例子中 A，B 模块可以不用声明 gruopId 和 version，这些信息都从 C 模块中继承过来了，如果子模块要使用自己的 groupId 和 version 直接显示的声明即可。\n\n父类的哪些元素可以继承，可以查看 可继承的父类 pom元素。\n子类可以选择继承部分父类依赖，可以参考选择性继承。\n"},"Spaces/Areas/Maven/Maven-聚合":{"title":"Maven 聚合","links":["Atlas/Maven-MOC","tags/maven/聚合"],"tags":["maven/聚合"],"content":"up:: Maven MOC\ntag::聚合\ndates::  2023-09-08\n为了方便使用命令管理多个模块，就需要用到聚合。例如：项目中有 A，B 两个模块，需要对两个项目都执行 clean 操作，因此你需要跑到 A 模块下执行 mvn clean 命令，然后再跑到 B 模块下执行相同的命令，模块较多的话就比较繁琐。\n使用聚合就可以解决上述问题。新建一个聚合模块，然后将模块的打包方式修改成 pom，并使用标签 modules引入模块 A，B，然后对只需要在聚合模块使用 mvn clean  操作即可。示例代码：\n&lt;packaging&gt;pom&lt;/packaging&gt;\n&lt;modules&gt;\n  &lt;module&gt;A模块目录名称&lt;/module&gt;\n  &lt;module&gt;B模块目录名称&lt;/module&gt;\n&lt;/modules&gt;\n聚合模块可以与其他模块同级，同级只需要将 module 改为 &lt;module&gt;../A模块目录名称&lt;/module&gt; ，特别注意的是聚合模块的打包方式一定要修改成pom。"},"Spaces/Areas/Maven/clean-生命周期":{"title":"clean 生命周期","links":["Spaces/Areas/Maven/Maven-生命周期","tags/maven/生命周期"],"tags":["maven/生命周期"],"content":"up:: Maven 生命周期\ntag::生命周期\ndates:: 2023-09-08\nclean 生命周期负责清理上一次项目构建产生的文件，例如编译后的 class 文件。\n生命周期阶段\n\npre-clean 执行清理前做的工作\nclean 清理工作\npost-clean 执行清理后做的工作\n"},"Spaces/Areas/Maven/default-生命周期":{"title":"default 生命周期","links":["Spaces/Areas/Maven/Maven-生命周期","tags/maven/生命周期"],"tags":["maven/生命周期"],"content":"up:: Maven 生命周期\ntag::生命周期\ndates::  2023-09-08\ndefault 生命周期负责构建项目，包括编译运行部署等。\n生命周期阶段\n\nvalidate 验证项目是否正确并且所有必要的信息都可用\ncompile 编译项目的源代码\ntest 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求打包或部署代码\npackage 将编译后的代码打包成可分发的格式，例如 JAR。\nverify 对集成测试的结果进行任何检查，以确保满足质量标准\ninstall 将包安装到本地存储库中，作为本地其他项目的依赖项\ndeploy 在构建环境中完成，将最终包复制到远程存储库以与其他开发人员和项目共享。\n"},"Spaces/Areas/Maven/site-生命周期":{"title":"site 生命周期","links":["Spaces/Areas/Maven/Maven-生命周期","tags/maven/生命周期"],"tags":["maven/生命周期"],"content":"up:: Maven 生命周期\ntag::生命周期\ndates::  2023-09-08\nsite 用于建立和发布项目的站点。\n生命周期阶段\n\npre-site 执行生成项目站点前需要完成的工作\nsite 生成项目站点文档\npost-site 执行生成项目站点后需要完成的工作\nsite-deploy 将生成的项目站点发布到服务器上\n"},"Spaces/Areas/Maven/传递性依赖":{"title":"传递性依赖","links":["Spaces/Areas/Maven/Maven-依赖","tags/maven/依赖","Spaces/Areas/Maven/依赖范围"],"tags":["maven/依赖"],"content":"up:: Maven 依赖\ntag::依赖\n假设存在依赖关系 A --&gt; B --&gt; C，A 依赖 B，B 依赖 C。称 A 对于 B 是第一直接依赖,B 对于 C 是第二直接依赖，A 对于 C 是传递性依赖。\n依赖范围影响传递性依赖\n依赖范围会对传递性依赖产生影响，如下表所示，最左边的一行表示第一依赖范围，最上面的一行表示第二直接依赖范围\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncompiletestprovidedruntimecompilecompile——runtimetesttest——testprovidedprovided—providedprovidedruntimeruntime——runtime\n助记规律：\n\n当第二直接依赖范围是 compile 时，传递性依赖范围与第一直接依赖范围一致。\n当第二直接依赖范围是 test 时，依赖不会得以传递。\n当第二直接依赖范围是 provided 时，只传递第一依赖范围也为 provided的依赖。\n当第二直接依赖范围是 runtime 时，传递性依赖范围与第一直接依赖范围一致，但 compile 除外，此时传递性依赖范围为 runtime。\n"},"Spaces/Areas/Maven/依赖冲突解决原则":{"title":"依赖冲突解决原则","links":["Spaces/Areas/Maven/Maven-依赖","tags/maven/依赖"],"tags":["maven/依赖"],"content":"up:: Maven 依赖\ntag::依赖\n假设项目中存在依赖关系：A --&gt; B --&gt; C(1.0)，A --&gt; B --&gt; D --&gt; C(2.0)，两条依赖关系都使用了 C。\n\n\n就近原则：项目根据 C 到 A 的距离，来决定使用哪一个依赖关系，前者的路径长度为2，后者为3，因此 C(1.0) 被解析使用。\n\n\n先声明先使用：如果距离一样，无法使用就近原则，就根据声明顺序，先声明的先解析使用。\n\n声明顺序即 C 依赖坐标在 maven pom 文件的位置，越靠前越先解析。\n\n\n"},"Spaces/Areas/Maven/依赖范围":{"title":"依赖范围","links":["Spaces/Areas/Maven/Maven-依赖","tags/maven/依赖"],"tags":["maven/依赖"],"content":"up: Maven 依赖\ntag::依赖\nMaven 编译项目主代码的时候使用一套 classpath，在编译执行测试的时候使用另一套 classpath，而实际运行 Maven 项目时候又会使用一套 classpath，因此总共有三套 classpath。\n依赖范围就是来控制与这三种 classath（编译 classpath，测试 classpath，运行 classpath）的关系。如果没有指定依赖范围，就会默认使用 compile依赖范围。\n依赖范围和三种  classpath 的关系如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n依赖范围 （Scope）对于编译 classpath 有效对于测试 classpath有效对于运行时 classpath 有效例子compileYYYspring-coretest—Y—JUnitprovidedYY—servlet-apiruntime—YYJDBC 驱动实现systemYY—本地的 maven 仓库外的类库文件"},"Spaces/Areas/Maven/可继承的父类-pom元素":{"title":"可继承的父类 pom元素","links":["Spaces/Areas/Maven/Maven-继承","tags/maven/可继承的父类pom"],"tags":["maven/可继承的父类pom"],"content":"up:: Maven 继承\ntag::可继承的父类pom\n\ngroupId 项目组 ID ，项目坐标的核心元素。\nversion 项目版本，项目坐标的核心元素。\ndescription 项目的描述信息。\norganization 项目的组织信息。\ninceptionYear 项目的创始年份。\nurl 项目的 url 地址。\ndeveloers 项目的开发者信息。\ncontributors 项目的贡献者信息。\ndistributionManagerment 项目的部署信息。\nissueManagement 缺陷跟踪系统信息。\nciManagement 项目的持续继承信息。\nscm 项目的版本控制信息。\nmailingListserv 项目的邮件列表信息。\nproperties 自定义的 Maven 属性。\ndependencies 项目的依赖配置。\ndependencyManagement 醒目的依赖管理配置。\nrepositories 项目的仓库配置。\nbuild 包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等。\nreporting 包括项目的报告输出目录配置、报告插件配置等。 ****\n"},"Spaces/Areas/Maven/可选依赖":{"title":"可选依赖","links":["Spaces/Areas/Maven/Maven-依赖","tags/maven/依赖"],"tags":["maven/依赖"],"content":"up:: Maven 依赖\ntag::依赖\n假设存在依赖关系 A 依赖 B，B 依赖 X 或 Y，B 对于 X 和 Y 的依赖是可选依赖。A ⇒ B，B ⇒ X（可选），B ⇒ Y（可选），可选依赖不会得到传递，换句话说选择 X 或者 Y，对于 A 都不会有任何影响。\n在Maven 依赖中有提到，将依赖声明为可选依赖，需要在依赖坐标中添&lt;optional&gt;true&lt;/optional&gt; 即可。\n当需要指定所使用的依赖时，需要在外层声明需要使用的依赖，上面的例子就需要在 A 中引入 X 或者 Y 的依赖。在理想的情况下，尽量避免可选依赖的使用。"},"Spaces/Areas/Maven/插件的基本概念":{"title":"插件的基本概念","links":["Spaces/Areas/Maven/Maven-插件","tags/maven/插件的基本概念"],"tags":["maven/插件的基本概念"],"content":"up:: Maven 插件\ntag::插件的基本概念\n插件目标\n一个插件往往能执行多个任务，因此插件具有多个功能，每个功能就是一个插件目标 (goal)。\nmaven-dependency-plugin 插件就有十多个 goal，每个 goal 对应一个功能，例如常用的两个功能：\n\ndependency:list\ndependency:tree\n\n冒号前面是插件前缀，冒号后面是该插件的目标。\n插件绑定\nmaven 的生命周期与插件相互绑定，具体而言就是生命周期的阶段与插件的目标相互绑定。例如 mvn compile就是 default 生命周期 compile 阶段与 maven-compiler-plugin 插件的 compile目标绑定。\n内置绑定\n为了简化配置，maven 为一些核心的生命周期阶段绑定了很多插件的目标。当用户调用对于的生命周期阶段时，绑定的插件目标就会执行相应的任务。\n例如：clean 生命周期的 clean 阶段，就绑定了 maven-clean-plugin插件的 clean 目标绑定。site 生命周期的 site 阶段绑定 maven-site-plugin 插件的 site 目标，site-deploy 阶段绑定到 maven-site-pugin插件的 deploy目标。\n由于项目的打包类型会影响构建的具体过程，因此 default 的生命周期阶段与插件的目标绑定关系与打包类型有关系。\ndefault 生命周期的内置插件绑定关系（打包类型为 jar）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n生命周期阶段插件目标执行任务process-resourcesmaven-resources-plugin:resources复制主资源文件至输出目录compilemaven-compiler-plugin:compile编译主代码至输出目录process-test-resourcesmaven-resources-plugin:testResources复制测试资源文件至测试输出目录test-compilemaven-compiler-plugin:testCompile编译测试代码至测试输出目录testmaven-surefire-plugin:test执行测试用例packagemaven-jar-plugin:jar创建项目 jar 包installmaven-install-plugin:install将项目构建输出到本地仓库deploymaven-deploy-plugin:deploy将项目构建输出到远程仓库\n上面只是列举了 default 生命周期绑定了插件的阶段，并非 default 的所有阶段。\n自定义绑定\n除了上面的内置绑定外，插件还支持自定义绑定，拿 maven-compiler-plugin插件举例\n \n &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n               \t &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;diy-compile&lt;/id&gt;\n                        &lt;phase&gt;verify&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;testCompile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n&lt;/plugins&gt;\n \n上面代码将 maven-compiler-plugin插件的 testCompile目标绑定到 default 上面周期的 verify 阶段。当运行 mvn verify 时，该插件的 testCompile 目标就会执行。phase 表示绑定的声明周期阶段，因为插件可以在一个生命周期阶段运行多个方法，所以可以配置多个目标，即多个 goal。\n有的时候，没有使用 phase，插件目标目标也能绑定到声明周期的阶段中去。这是因为很多插件在目标的编写时候已经定义好了默认绑定的阶段。可以使用命令查看 mvn help:describe -Dplugin=compiler  -Ddetail 查看插件的详细信息，默认绑定的阶段等。\n当一个阶段有多个插件目标绑定时，执行顺序与插件的声明顺序有关，先声明先执行。"},"Spaces/Areas/Maven/插件配置":{"title":"插件配置","links":["Spaces/Areas/Maven/Maven-插件","tags/maven/插件配置"],"tags":["maven/插件配置"],"content":"up:: Maven 插件\ntag::插件配置\n插件目标像 Java 中的函数一样，执行相应的功能，并且还有参数，这些参数的具体值，我们可以配置，传递给插件目标。\n命令行插件配置\n命令行插件配置算是比较经典的配置手段了，在 Java 中可以使用 -D 参数配置系统属性。Maven 简单的重用了该参数，在检查插件的时候检查系统属性，实现了插件参数的配置。\n例如：maven-compiler-plugin 插件就提供了一个 maven.test.skip的系统属性，通过配置是否跳过测试。以下是该插件 testCompile目标的 skip 参数详细信息。\n skip\n      User property: maven.test.skip\n      Set this to &#039;true&#039; to bypass compilation of test sources. Its use is NOT\n      RECOMMENDED, but quite convenient on occasion.\n \n可以看到该参数可以使用 maven.test.skip，因此可以编写命令 maven install -Dmaven.test.skip=true 用来跳过测试。\nPOM 插件配置\n对于一些固定常用的参数，可以直接在 pom 文件中配置，使用 configuration 配置 参数，如下：\n    &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;warSourceExcludes&gt;WEB-INF/classes&lt;/warSourceExcludes&gt;\n                &lt;/configuration&gt;\n   &lt;/plugin&gt;\n如果需要插件在不同声明周期执行相同的目标，但是执行的参数不一样，就需要另外配置。\n &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n               \t &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;diy-compile&lt;/id&gt;\n                        &lt;phase&gt;install&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;testCompile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                        &lt;configuration&gt;\n                  \t\t\t\t\t…\n                \t\t\t  &lt;/configuration&gt;\n                    &lt;/execution&gt;\n                   \n                      &lt;execution&gt;\n                        &lt;id&gt;diy-test&lt;/id&gt;\n                        &lt;phase&gt;verify&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;testCompile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                        &lt;configuration&gt;\n                  \t\t\t\t\t…\n                \t\t\t  &lt;/configuration&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n&lt;/plugins&gt;\n如上同一插件的同一目标绑定了不同的声明周期阶段，具体的参数配置只需要在各自的 configuration 配置即可。"},"Spaces/Areas/Maven/选择性继承":{"title":"选择性继承","links":["Spaces/Areas/Maven/Maven-继承","tags/maven/选择性继承"],"tags":["maven/选择性继承"],"content":"up:: Maven 继承\ntag::选择性继承\nMaven 继承说到依赖可以继承，但是并不是每一个模块都需要引入父模块的所有依赖。例如一个工具模块，就不太需要 spring这些依赖包，但是因为继承关系，导致工具模块也引入了这些包，为了避免这种情况就需要使用新的元素 dependencyManagement。\ndependencyManagement 可以让子类自行的选择继承父模块的依赖，只需要将父模块的依赖用元素 dependencyManagement包裹起来即可。例如父模块依赖代码如下：\n&lt;dependencyManagement&gt;\n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n      &lt;version&gt;2.5.6&lt;/version&gt;\n    &lt;/dependency&gt;\n    \n     &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;/groupId&gt;\n      &lt;artifactId&gt;junit&lt;/artifactId&gt;\n      &lt;version&gt;5.0&lt;/version&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n子模块引用父模块依赖，代码如下：\n &lt;dependencies&gt;\n     &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;/groupId&gt;\n      &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n子模块 pom 直接引用所需要的依赖坐标即可，上面代码只引用了父模块的 junit 依赖，因此 spring-core 不会被引入。子模块还去掉了依赖的 version 和 scope 信息，这是因为继承了父模块的 pom，完整的依赖声明已经在父 pom 中了，因此子模块只需要 groupId 和 artifactId 就能获取对应的依赖信息，这样使用也能使所有子模块统一依赖版本，降低依赖冲突概率。"},"Spaces/Areas/个人形象管理/4-种穿搭配色技巧":{"title":"4 种穿搭配色技巧","links":["Spaces/Areas/Areas-MOC","tags/穿搭/服装","tags/配色"],"tags":["穿搭/服装","配色"],"content":"up:: Areas MOC\ntag::服装配色\n百搭色系：黑、白、灰、深蓝、深绿、卡其\n大面积使用同一颜色\n优势：全身上下大部分地方穿同一颜色，比较容易穿出风格和氛围。\n缺点：颜色覆盖过多，容易穿成制服的感觉。\n使用八二法则可以规避缺点。八二法则：身上 80% 使用主要的颜色，20% 使用辅助的颜色。\n选择套装之类的衣服灰很容易达到八二法则，例如西装，长版大衣\n同色系 one-tone 的方式\n像全黑搭配、全灰搭配等等。\n值得注意的点是：需要找到你觉得穿在身上好看的颜色或色系。可以使用上面提到的「基本色系」\n全身不使用超过 3 个颜色\n黑白灰是否算在这 3 个颜色中，需要根据他的使用面积，面积小可以忽略，否则就算在该 3 个颜色中。\n颜色呼应\n不同的单品之间的颜色呼应很重要，这样你的穿搭会有一种设计过，搭配过的感觉。\n全身要有穿搭亮点\n颜色有深有浅很重要，像上深下浅，上浅下深。"},"Spaces/Areas/个人形象管理/自信的肢体语言":{"title":"自信的肢体语言","links":["Spaces/Areas/Areas-MOC","tags/气质"],"tags":["气质"],"content":"up:: Areas MOC\ntag::气质\n自信人的特质\n自信的表现范围很广：个人的姿态、容貌、打扮、下巴的位置、眼睛看哪里望向哪里、姿势放松且顺畅、行进时要像为了某个目标而前进。\n另一项有自信的人能做到的是，对时间的掌控。例如：缓缓的出场现身、不疾不徐的回答问题，回答的问题的速度、语气、时间都是由我决定的，这样也能展现自信，对事物的掌握。\n一些大男人的举动和刻意的权利展现，通常会让人误以为他很自信，其实自信是可以非常低调的。\n自信的动作和表现\n\n给人指路：用手指指路会招来厌烦、用整个手掌指路更自信。\n语调：用肢体语言加强，我们想要表达的信息。\n说话节奏：机关枪式的说话，时间久了听众不会想继续听下去。当说话有节奏的时候，听者会更想听下去。把控好说话的节奏，就可以抓住听众的注意力，让他们专注，并期待你的下一句是什么。在无意识中，让他们知道这是掌握全场的人，因为你懂得控场，不匆忙。\n空间和时间的掌控：精准的回答问题，同时确定对方有没听懂自己的话，我是要传达信息而不是说服你。很多时候缺乏自信的人会想要说服你，说赢你。\n肢体动作：动作需要顺畅，不急促。\n\n公众演讲的技巧\n公众演讲的紧张感任何人都会有，以下3个方法可以让你表现的更好\n\n永远不要压抑自己\n\n诚实面对自己，这个过程本身就是不自然的\n\n\n提醒自己，只要自己准备的充分，就一定比台下的人懂的更多\n事先做彩排，当你第一次听到自己的回音时，才不会被吓到。\n\n找一面墙，双手趴上去像做俯卧撑一样，它能释放肌肉的紧绷，会感觉更有力掌控感\n走向演讲台，望向观众，然后做一个停顿，整理自己然后开始演讲\n\n\n\n结论\n人天生就是没有自信的，通过父母的鼓励我们能够获得自信、获得成就变得自信、跳出舒适圈也能变得自信。\n自信可以发展和养成的。\n如果想要获得自信，需要了解自己、获取知识、增进技术、努力达到对事物和自己的精通，就能展现你的自信。\n参考\n如何走路自帶氣場？FBI探員分析「自信」的肢體語言"},"Spaces/Areas/个人形象管理/鞋子搭配三个原则":{"title":"鞋子搭配三个原则","links":["Spaces/Areas/Areas-MOC","tags/穿搭/鞋子"],"tags":["穿搭/鞋子"],"content":"up:: Areas MOC\ntags::鞋子\n鞋款轮廓\n\n裤口宽要宽于鞋身（长裤短裤均适用）\n搭配短裤，腿部比例过短时，要更换为膝上裤搭配\n搭配短裤，与鞋款分量感有落差时，穿长袜平衡\n\n配色\n\n使用基本色搭配，鞋款颜色特殊，其他颜色使用基本色（黑白灰）\n相近色，呼应色搭配。与身上的着装或配饰，呼应和相近\n\n风格调性\n\n搭配时，鞋款调性/风格至少与身上一款单品呼应，整体才不会过于突兀\n\n参考\n那个矮子#三招讓你什麼鞋都會搭"},"Spaces/Areas/关于Areas":{"title":"关于Areas","links":[],"tags":[],"content":"目前正在持续进行中的笔记，可以包含多个领域，例如：个人健康、个人形象管理等。"},"Spaces/Areas/学做菜/主食类":{"title":"主食类","links":["Cook-MOC","tags/cook"],"tags":["cook"],"content":"up:: Cook MOC\ntag::cook\n\n清汤面\n酸汤水饺\n炝锅面\n"},"Spaces/Areas/学做菜/汤类":{"title":"汤类","links":["Cook-MOC","tags/cook"],"tags":["cook"],"content":"up:: Cook MOC\ntag::cook\n\n玉米排骨汤\n肉丸汤\n金针菇肉汤\n小碗豆肉汤\n萝卜干排骨汤\n椰子鸡汤\n玉米鸡汤\n"},"Spaces/Areas/学做菜/炒菜类":{"title":"炒菜类","links":["Cook-MOC","tags/cook"],"tags":["cook"],"content":"up:: Cook MOC\ntag::cook\n\n榨菜炒肉\n青椒炒肉\n水蒸蛋\n紫苏炒虾\n紫苏花甲\n红薯叶\n白灼虾\n凉拌黄瓜\n凉拌莲藕\n凉拌牛肉\n西红柿炒蛋\n萝卜干肉末\n干炒四季豆\n青椒腊肉\n孜然土豆\n空心菜\n空心菜杆炒蛋\n香菇炒上海青\n口蘑虾滑\n青椒酿肉\n手撕包菜\n花菜虾仁\n可乐鸡翅\n榨菜炒蛋\n辣椒炒蛋\n炒莲藕\n"},"Spaces/Areas/日落咖啡-Sunset-Garden":{"title":"日落咖啡 Sunset Garden","links":["Atlas/深圳咖啡馆MOC","tags/coffeeshop","日咖夜酒"],"tags":["coffeeshop"],"content":"up:: 深圳咖啡馆MOC\ntags::coffeeshop\n体验\n位置：深圳市宝安区上川路 304 号\n体验感受：咖啡店是日咖夜酒的形式，柜台陈列了不少洋酒。位置就在路边，店外也有位置，适合几个人闲谈。店内不大，桌子大概有 7.8 张，整体环境较嘈杂，不适合去办公和看书人群。内部装修不错，整体色调是像夕阳的橙红色\n预览图"},"Spaces/Areas/深圳咖啡馆/About":{"title":"About","links":[],"tags":[],"content":"列举自己去过的深圳咖啡馆，分享一些自己的感受。"},"Spaces/Areas/视频拍照/Youtuber---The-Shorty-手机拍照技巧分享":{"title":"Youtuber - The Shorty 手机拍照技巧分享","links":["Spaces/Areas/视频拍照/拍照角度","画面构图","正确曝光","后期修图"],"tags":[],"content":"拍照四要素\n\n拍照角度\n画面构图\n正确曝光\n后期修图\n\n穿搭照片拍照\n静物拍摄"},"Spaces/Areas/视频拍照/拍照角度":{"title":"拍照角度","links":[],"tags":[],"content":""},"Spaces/Projects/Obsidian-插件学习笔记/Dataview-插件":{"title":"Dataview 插件","links":[],"tags":[],"content":"简介\n把所有的资料库信息当做数据库，使用数据库的语言去查询资料信息\nObsidian 查询依据包含：YAML 数据 、MetaInfo\n每个  Obsidian 文件都有相对应的属性，类似于数据库表格的字段。\nObsidian 文件的 MetaInfo 属性如下：\n\nfile.name 文件标题\nfile.folder 文件所属的文件夹路径\nfile.path 文件路径\nfile.size 文件大小\nfile.ctime 文件的创建时间 （包含日期和时间）\nfile.mtime 文件的修改时间\nfile.cday 文件的创建日期\nfile.mday 文件的修改日期\nfile.tags 笔记中的所有标签数组\nfile.etags root 标签\nfile.inlinks 此文件的传入链接数组\nfile.outlinks 此文件的出站链接数组\nfile.aliases 文件别名数组\nfile.day 如果文件名中有日期，那么该字段会显示。\n\nObsidian 中支持的  YAML 格式：\n系统自带的 YAML 字段\n\ntags\npublish\ncssclass\naliases\n\n自定义字段\n\ncategory\ndate\ntime\ntitle\nrating\n\nDataview 中的查询语法\n[ list | table | task ]\nfrom [ #tag | 文件夹 | [入链接] | [出链接] ]\nwhere fileld [ &gt; | &gt;= | &lt; | &lt;= | = | &amp; | &#039; | &#039; ]\nsort field\n查询使用示例\n查询指定文件夹下的文件\nlist \nfrom &quot;代办事项&quot;\n查询文件中标签包含 Jenkins 的文件\nlist\nfrom #Jenkins \n查询文件中 tags 包含 maven 且 category 为 学习笔记 的文件\nlist\nfrom #Maven \nwhere category = &quot;学习笔记&quot;\n标签包含 HashMap 文件中的所有标签\nlist file.tags\nfrom #HashMap \n使用 table 表格的形式展示标签为 年终总结 的文件，展示 file.name 和 file.size\ntable file.name as 文件名,file.size as &quot;文件大小&quot;, tags as 标签\nfrom #Maven  \n展示 待办事项 文件夹下的子文件 生活类博客 中的所有 task\ntask\nfrom &quot;代办事项/生活类博客&quot;"},"Spaces/Projects/Obsidian-插件学习笔记/Excalidraw-插件":{"title":"Excalidraw 插件","links":[],"tags":[],"content":"待补充"},"Spaces/Projects/小红书🍠账号运营/账号定位":{"title":"账号定位","links":[],"tags":[],"content":"结合自身定位，目前定位与给人学习成长相关的。\n以一个普通人的视角和经验去学习一个新领域的东西，比如：学习穿搭、学习拍照、学习营养学、学习生活、学习跑步、学习剪辑、学习设计等等。\n通过文字和图片记录自己的学习成长过程，并分享到平台。通过学习不同领域的知识，锻炼自己的学习能力，以及做账号的能力。"},"Spaces/Projects/消息队列/消息队列":{"title":"消息队列","links":["Cards/Evergreen-Notes/QPS","强一致性","最终一致性"],"tags":["MQ"],"content":"消息队列，即消息的队列。用于进程间通信或同一进程不同线程间的通行方式。消息具\n使用消息队列的优势\n\n削峰填谷\n\n应对瞬时高流量\n吞吐量高，10w ~ 100w QPS\n\n\n异步提高性能\n\n减少接口的延时\n\n\n系统之间的模块进行解耦\n\n消息队列缺点\n\n成为单点故障的瓶颈\n消息会变得乱序\n重复消费\n某个步骤失败，其他步骤成功\n\n消息队列使用场景\n\n高吞吐量、延时不敏感\n不要求强一致性\n\n只需要最终一致性\n\n\n生产者不在乎\n\n消息队列的术语\n\nProducer\n\n消息的生产者（语言无关）\n\n\nConsumer\n\n消息的消费者（语言无关）\n\n\nBroker ^b4ff72\n\n消息队列服务端（即他自己）\n\n\nTopic ^8c3700\n\n消息的主题/频道（像电视一样，有多个频道）\n\n\n\n消息队列的功能/指标\n\n吞吐量：每秒能处理的消息数量\n\n10 ~ 100w 每秒\n\n\n延迟\n可用性 / 集群\n发布 / 订阅\n持久化\n消息堆积\n优先级 / 顺序和重复消息\n分布式事务\n\n消息队列的高级特性\n\n最终一致性\n\n明确业务需求\n丢消息 &lt;&gt; 消息的重复\n消费确认\n\n\n消息的保证顺序\n\n保证处理消息的顺序\n\n\n"},"Spaces/Projects/虚拟仿真项目/服务器申请":{"title":"服务器申请","links":["tags/虚拟仿真"],"tags":["虚拟仿真"],"content":"tag::虚拟仿真\n区域：深圳 \nCPU：8 核\n内存：16G\n系统：Liunx Centos7\n两台服务器需要挂载一块数据盘，数据盘大小500GB\n另外，还需要开通两个子域名，以及提供相应的证书。虚拟仿真域名：preview-vse.3dcat.live 3dcat域名：preview-vse-prictice.3dcat.live"},"Spaces/Projects/虚拟仿真项目/虚拟仿真-1.3-需求分析---后台实现逻辑":{"title":"虚拟仿真 1.3 需求分析 - 后台实现逻辑","links":["tags/虚拟仿真"],"tags":["虚拟仿真"],"content":"tags::虚拟仿真\n题库管理\n\n 创建试题\n\n 填空题的优化：主观填空题、客观填空题\n 客观填空题需要做如下优化：\n\n 题目表 tb_question 中需要增加 “enable_order_mark”\n 选项表中需要添加字段 “enable_case_sensitive”\n\n\n\n\n 删除题目\n\n 通过题目 id 反查已经引用的「考试」和「作业」，考试和作业需要冗余题目 id\n 题目删除，查找关联的试卷，去删除该条关联信息\n\n\n 编辑题目\n\n 题目类型不可修改（增加编辑接口）\n\n\n 题目正确率 （增加字段 accuracy）\n\n 主观题不做正确率统计\n 客观题：答题正确人数 / 答题总人数。\n\n 何时计算？对已完成的考试和作业进行计算？\n\n\n\n\n 题目使用量 （增加字段 used_num）\n\n 考试发布的时候需要将  used_num 递增。\n\n\n 同步到考试\n\n 题目详情接口 + 引用的考试接口\n 同步记录的接口\n 需要展示 copy 之后的详情数据。\n\n\n\n考试\n\n 原来的引用试卷，试题的逻辑需要修改 - 改成 copy 形式的\n 考试详情的展示同步修改\n 涉及到统计接口，需要仔细排查\n\n学生作答详情\n\n 添加发布成绩接口 - 批量\n\n 成绩发布后，学生端才能看到自己的成绩\n\n\n 成绩发布需要添加设置「手动发布」「自动发布」，考试表新增 publish_score_config\n\n 自动发布，老师批阅完后自动更新成绩发布状态\n 学生作答详情添加 ‘publish_status’ 发布状态\n 学生查看考试详情，根据发布状态展示学生成绩信息\n\n\n 批阅成绩 - 需要根据考试的 publish_score_config 设置，更新 publish_status 状态。\n 公布试卷设置 (考试后台增加一个 open_config 公开状态，open_time 开放时间)\n\n 与用户前台的考试详情展示有关联，需要同步修改学生查看考试详情接口\n\n\n 批阅详情新增了答题学生的信息，需要做修改。\n 学生首页考试详情查看，需要提供批阅状态和发布成绩状态。\n\n修改的 sql\n \ntb_prep_paper 新增字段 `type` 0 不展示 1 展示\n \n新增表 tb_tmp_test_apper\n \ntb_test_paper  增加了题目相关信息 新增 options 字段\n \n新增问题同步记录表 tb_question_sync_record\n \ntb_answer_test_paper 新增字段 openScore\ntb_test 增加 open_score_config 字段 open_paper_config 公布 open_paper_time\ntb_question 增加 options 字段\n所有的 score 字段改成浮点数\n删除了 tb_answer_test_paper 无效字段\n删除了 tb_answer_test_paper_detail 无效字段\n \n\n 虚拟仿真新建考试需求优化\n\n 暂存接口拆分\n 字段优化，不必要字段简化\n\n\n"},"Spaces/Resources/Output/个人心理问题咨询":{"title":"个人心理问题咨询","links":["tags/V2ex"],"tags":["V2ex"],"content":"tag::V2ex\n第一次鼓起勇气加女同事微信，但给我的感觉很冷\n与妹子的聊天情况：如题，本人是一个内向带一点自卑的程序员，从上大学开始到现在差不多 6.7 年时间，基本没有和异性朋友接触，而且本人和妹子聊天极易脸红。公司有一个妹子很漂亮，自己关注了一段时间但是不敢去加微信，昨天内心挣扎了很久，还是决定勇敢一点，加了妹子的微信（通过群聊）。和妹子的聊天内容大概介绍一下自己，然后表达想交个朋友的意图，等了很长时间猜才得到一个「你好」的回复，最后祝她周末愉快，她也对我说了周末愉快，第一天就结束了。\n然后今天，早上10点左右，就问了个早上好，问了一下她周末一般干啥，她的回答是「躺平睡觉」，时间隔了很久，后面我问了一句「不会睡到现在才醒吧doge」，就尬住了没有再回我了。\n个人情况：个人的外形条件不差，个人身高长相中等偏上一点点（别人评价），但是摆脱不了自卑（源于家庭成长环境）。从大学到现在工作 3 年，周末基本没有出过门，异性朋友几乎没有，同性朋友也是少的可怜，我害怕社交，害怕尴尬，在其他朋友面前从来没有真正打开自己，还好目前有 2 个非常知心的朋友，什么话都会和他们聊。\n现在面临的问题：由于和妹子没有再说话，我内心焦虑的却不是妹子的冷漠，而是在公司遇到妹子该如何自处，该如何面对这种尴尬情况。遇到妹子，我该打招呼吗？打招呼我又很容易脸红，导致自己内心更为恐惧，以后遇到这种情况会更加害怕打招呼。\n我想要寻求的帮助：如何让自己不那么「害怕社交」，不那么「害怕尴尬」，让自己内心变得更强。当遇到自己喜欢的人时，能够比较大方得体的展现自己。我渴望爱情，却也害怕爱情。这些问题困扰我几年了，我特别希望爱情来的时候，自己能够真正把持住，所以特地来 V 站发帖，希望有过来人能帮我解答，感激不尽。"},"Spaces/Resources/博客/国外博客翻译/HTTPS-与信鸽":{"title":"HTTPS 与信鸽","links":[],"tags":["HTTPS","翻译"],"content":"\n本文翻译自国外的技术文章，原文链接。\n\n密码学是一门很复杂的学科，全是数学证明。除非你要开发加密相关的系统，不然没有必要了深解的太深入。\n如果你想通过这篇文章，来创建下一代 HTTPS 协议，这是远远不够的。若你有了觉悟，泡杯茶，然后开始学习鸽子通信。\nAlice, Bob and … pigeons\n作者声明：关于 Alice 和 Bob 等名称未做本土化翻译处理，目的是让读者能够在脑海中将密码学和前面的名称联系起来。\n你在网上的做的任何操作（阅读文章，逛淘宝，分享宠物照片），本质上是向服务器发送消息，和接收服务器发来的消息。\n这似乎有点抽象，我们假设消息都使用信鸽传输。这个比喻可能有点随意，但是 HTTPS 的原理就和信鸽一样，只不过比信鸽传输消息更快。\n我们使用 Alice、Bob 和 Mallory 来代指服务器、客户端和黑客。如果你不是第一次学加密相关的知识，那么你应该对这些名称很熟悉，因为它们在技术文献中被广泛使用（译者注：技术文献中出现 Alice、Bob，就像高中英语作文中的「李华」一样）。\n第一次简单的交流\nAlice 向 Bob 发送消息，她需要把写好的信绑在鸽腿上。Bob 收到 Alice 的信，一次简单的交流就完成了。\n假如鸽子飞行过程中，被一个叫 Mallory 的坏逼抓住并篡改了信息呢？Bob 是不可能知道消息被篡改了。\n这就是  HTTP 的工作原理。很可怕吧？我不会通过 HTTP 来发送我的私密数据，你也不应该。\n加密交流\nAlice 和 Bob 很聪明，他们协商用密码写信。他们将在字母表中将每个字母移动3个位置。例如 D → A，E → B，F → C。纯文本消息 ” secret message” 应该是 “pbzobq jbppxdb”。\n现在 Mallory 抓住了鸽子，但由于他不知道密码，因此并不理解信的内容，他也不能把消息篡改成有意义的东西。但是 Bob 可以反推出消息内容，在 A →D，B → E，C → F 的地方解密消息。密码文本 “pbzobq jbppxdb” 将被解密回 “secret message”。\n成功了！\n这就是所谓的对称密钥加密，即如果你知道如何加密消息，你也知道如何解密它。\n上面描述的加密方法通常被称为凯撒密码。在现实生活中，我们使用更复杂的加密方法，但主要思想是一样的。\n如何商定加密方法\n如果除了发送方和接收方之外没有人知道使用了什么密钥，那么对称加密是非常安全的。在凯撒密码中，密钥是我们移动每个字母的数量的偏移量。在上面的示例中，我们使用了 3 的偏移量，但也可以使用 4 或 12。\n问题是，如果 Alice 和 Bob 在开始用鸽子发送消息之前没有见面，他们就没有办法安全地商定一个密钥。如果他们把钥匙放进信封里 Mallory 就会拦截信息并找到钥匙。然后通过钥匙获取消息内容，再篡改消息，发给 Bob。\n这就是一个典型的中间人攻击例子，唯一避免方法是改变现在的加密方式。\n信鸽带盒子\n所以 Alice 和 Bob 想出了一个更好的办法。 当 Bob 想向 Alice 发送消息，应该遵从以下原则：\n\nBob 放飞一只鸽子给到 Alice。\nAlice 在鸽子腿上绑一个盒子和一个打开的锁，然后自己留着钥匙。\nBob 把消息放到盒子里，并用锁锁住盒子，发给 Alice。\nAlice 收到盒子，用钥匙打开盒子，读到 Bob 发的消息。\n\n由于 Mallory 没有钥匙，就算抓到了鸽子，也无法打开盒子篡改消息。Alice 向 Bob 发送消息也遵循相同的原则。\nAlice 和 Bob 通信使用了非对称密钥加密。顾名思义，它是非对称，即使你可以加密一条消息（锁上盒子） ，你也不能解开它（打开盒子）。在技术语言中，盒子被称为公钥，打开它的钥匙被称为私钥。\n盒子值的相信吗？\n如果足够细心，你可能已经注意到通信过程仍有一个问题。因为 Mallory 可以拦截鸽子，并把盒子换成自己的，当 Bob 收到那个打开的盒子时，他无法确定是 Alice 的盒子，还是 Mallory 的。\nAlice 决定在盒子上签名，当 Bob 收到盒子并检查签名，就知道是 Alice 发来的。\n有人可能在想，Bob 一开始是怎么认出爱丽丝的签名的？好问题，Alice 和 Bob 当然知道这个问题，所以他们决定，让 Ted 代替 Alice 签名。\nTed 是谁？Ted 是一个非常有名，且值得信赖的人。Ted 会给每个合法的人签名，大家都相信他。\nTed 会先确定要签名的人是 Alice，才会给 Alice 盒子签名。Mallory 无法让 Ted 签 Alice 的盒子，Bob 会知道盒子不是 Alice 的，因为 Ted 只有在验证了身份之后，才会在盒子上签名。\nTed 在技术术语中被称为证书颁发机构，您正在阅读本文的浏览器附带了各种证书颁发机构的签名。\n因此，当你访问一个网站时，你会相信它的输入框，因为你相信 Ted，并且 Ted 告诉你这个输入框是合法的。\n盒子太笨重了\n现在 Alice 和 Bob 可以安全可靠的交流了，但同时他们也意识到鸽子带着盒子传消息比只带信封慢很多。\n他们协商一个对称加密秘钥（还记得上面的凯撒密码吗?），并把它放进盒子里。另一方收到消息后，就知道对方要用什么加密方法，加密接下来的消息。\n在现实世界中没有一直绑盒子的鸽子，使用非对称加密技术加密消息比使用对称加密技术加密消息要慢，所以我们只使用它来交换对称加密密钥。\n现在你知道 HTTPS 是如何工作的了，你的咖啡也应该准备好了，尽情享受吧。"},"Spaces/Resources/博客/国外博客翻译/停止使用-JWT-作为-Session":{"title":"停止使用 JWT 作为 Session","links":["Spaces/Resources/博客/技术类/Web-中的-Session"],"tags":["Session","JWT","翻译"],"content":"\n翻译自国外的文章\n\n停止使用 JWT 作为 Session\n最近，我看到越来越多的人推荐使用 JWT（JSON Web Tokens）来管理 web 程序中用户的 session。这是一个非常糟糕的主意，我将在这篇文章中解释原因。\n为了防止一些歧义，我首先定义一些术语：\n无状态 JWT：一个包含 session data 的 JWT 令牌，数据直接编码到令牌中。\n有状态 JWT：一个只包含 session 引用或 ID 的 JWT 令牌，session data 存储在服务器端。\nSession token / cookie：一个标准的（可选签名的）会话 ID，就像网络框架已经使用了很长时间，session data 存储在服务器端。\n清楚地说：这篇文章并非不让你使用 JWT，只是说它不适合作为 Session 机制，使用它有风险。在其他领域，对它们确实存在有效的用途。在文章的最后，我将简单介绍。\n前言\n很多人错误地比较”cookies 与 JWT”，这种比较完全没有意义，好比拿苹果与橙子相比。cookies 是一种存储机制，而 JWT 是经过加密签名的 token。\n它们并非对立关系，相反，它们可以一起使用也可以独立使用。正确的比较应该是 「Session 与 JWT」和「cookies 与本地存储」。\n在这篇文章中，我将比较 session 和 JWT token，并在需要的地方涉及 「cookies 与本地存储」的比较。\n大家谈论的 JWT 优势\n当人们推荐 JWT 时，他们通常会跟你说如下优势：\n\n更易于（水平）扩展\n更易于使用\n更灵活\n更安全\n内置过期功能\n不需要用户 “Accept Cookie”\n防止跨站请求伪造（CSRF）\n在移动设备上使用效果好\n禁止 cookie 的场景很适用\n\n我将对这些优势一一剖析解答，它们为什么是错误或误导性的。下面的一些解释可能有点含糊，主要是因为这些优势本身就很模糊。\n更易于（水平）扩展\n这是唯一一个从技术上说的过去优势，但只有在无状态 JWT token 的情况下才适用。然而实际上，几乎没有人真正需要这种扩展性。有许多更简单的扩展方法，除非你的操作范围达到 Reddit 的大小，你不需要 无状态会话。\n扩展有状态会话的一些例子：\n\n当你在一个服务器上运行多个后台进程：在该服务器上使用 Redis 存储 Session 数据。\n当你在多个服务器上运行：使用一个专门存储 Session 数据的 Redis 服务器\n当你在多个服务器上，在多个集群中运行：粘连 Session\n\n这些场景，现有软件都提供很好地支持，你开发的应用程序很大概率只能达到第二种情况。\n也许你在想，你应该为你的应用程序以后做好准备，以防超越了那个界限。然而在实践中，切换 Session 机制是相当简单的，唯一的成本就是在你过渡的时候将每个用户注销一次，需要将所有用户一次性注销登录。从一开始就实施 JWT 并不值得，特别是考虑到我稍后将要讲到的缺点。\n更易于使用\n并非如此，你将不得不自己处理 session 管理，在客户端和服务器端都要进行，而标准的 session 和 cookies 搭配是开箱即用的。在任何方面，JWT 都不会更易用。\n更灵活\n我还没有看到有人真正解释 JWT 是如何更灵活的。几乎每一个主要的会话实现都允许你存储任意的 session data，这与 JWT 的工作方式没有任何区别。就我所知，这只是被当作一个热门词汇使用的。如果你有异议，随时可以向我提供例子。\n更安全\n很多人认为 JWT 令牌「更安全」，是因为使用了加密技术。虽然签名的 cookies 比未签名的 cookies 更安全，但这并不是 JWT 所独有的，好的 Session 实现也会使用签名的 cookies。\nJWT 使用加密技术并不会神奇地使某个东西更安全，它必须有一个特定的目标，且对于那个特定的目标，它是一种有效的解决方案。事实上，错误的使用加密技术可能会变得更不安全。\n另一个我经常听到的「更安全」的论点是「他们不是作为 cookie 发送出去的」。这完全没有道理，cookie 只是一个 HTTP 头，使用 cookies 并没有什么不安全。实际上，cookies 对防止恶意客户端代码特别有效，这是我稍后要讲的。\n如果你担心有人截取你的会话 cookie，你应该使用 TLS，如果你不使用 TLS，任何类型的会话实现都会被截取，包括 JWT。\n内置过期功能\n这并没有什么意义的，也不是一个有用的特性。服务器端一样可以很好地实现过期功能，许很多实现方式就是如此。实际上，服务端过期是更好的选择，它允许应用程序清理不需要的 Session 数据，这是「有状态的 JWT token」过期机制是无法做到的。\n无需用户同意 Cookie 策略\n这是完全错误的。没有所谓的 “cookie 策略”，关于 cookie 的各种规定实际上覆盖了任何并非严格必要的持久性标识符。你能想到的任何会话机制都包含在这其中。\n总的来说：\n如果你出于功能性目的（比如，让用户保持登录状态）正在使用 Session 或 JWT，那么无论你如何存储该会话，你都不需要向用户请求同意。 如果你出于其他目的（比如，分析或跟踪）正在使用会话或令牌，那么无论你如何存储该会话，你都需要向用户请求同意。\n防止跨站请求伪造（CSRF）\n事实并非如此。存储 JWT 大致有两种方式：\n在 cookie 中：容易受到 CSRF 攻击，仍然需要防护。 在其他地方，比如 Local Storage：现在你不再容易受到 CSRF 攻击，但你的应用程序或网站现在需要 JavaScript 才能工作，并且你把自己暴露给了一个完全不同的，可能更糟糕的漏洞类型。下面有更多关于这点的内容。 唯一正确的 CSRF 缓解措施是使用 CSRF 令牌。这里的会话机制并不相关。\n对移动设备上支持更好\n无稽之谈。现有的每一款移动浏览器都支持 cookies，因此也支持会话。每个主要的移动开发框架和任何权威的 HTTP 库也是如此。所以这根本就不是问题。\n对那些阻止 cookies 的用户也起作用\n不太可能。用户不仅仅是阻止 cookies，他们通常会阻止所有持久化的方式。那包括 Local Storage 和任何其他可以让你持久化会话的存储机制（无论是否使用 JWT）。你是否使用 JWT 在这里根本不重要，这是一个完全不同的问题，试图在没有 cookies 的情况下让认证工作，基本上是徒劳的。\n除此之外，那些阻止所有 cookies 的用户通常明白，这将会破坏他们的认证功能，他们会为他们关心的网站单独解锁 cookies。作为一个网络开发者，你无需解决这个问题；一个更好的解决方案是告诉你的用户为什么你的网站需要 cookies 才能工作。\nJWT 缺点\n既然我已经讨论了所有常见的观点和它们为何错误，你可能会想“哦，这没什么大不了的，即使 JWT 对我没有帮助，我仍然可以使用他”，但你错了。使用 JWT 作为会话机制确实有很多缺点，其中一些是严重的安全问题。\nJWT 令牌空间占用较大\n特别是当使用无状态的 JWT 令牌时，所有的数据都直接编码进令牌中，你将很快超过 cookie 或 URL 的大小限制。你可能决定将它们存储在 Local Storage 中，然而…\n安全性更差\n当你将 JWT 存储在 cookie 中时，它与任何其他会话标识符没有什么区别。但当你把你的 JWT 存储在其他地方时，你现在就容易受到新一类攻击的威胁，在这篇文章（特别是”存储会话”部分）中有所描述：\n\n我们从上次停止的地方开始：回到本地存储 (Local Storage)，这是一个伟大的 HTML5 新增功能，可以在浏览器和 cookie 中添加键/值存储。那么我们应该在本地存储中存储 JWT 吗？考虑到这些令牌可能达到的大小，这样做似乎有点道理。cookies 通常在大约 4k 的存储空间上达到上限。对于大型的令牌，cookie 可能不适合，本地存储会是显而易见的解决方案。然而，本地存储并没有提供 cookie 所提供的任何安全机制。\n与 cookies 不同，本地存储并不会在每一个请求中发送你的数据存储内容。从本地存储中检索数据的唯一方式就是使用 JavaScript，这意味着任何经过内容安全策略检查的攻击者提供的 JavaScript 都可以访问和提取它。而且，JavaScript 也不关心或跟踪数据是否通过 HTTPS 发送。在 JavaScript 看来，这只是数据，浏览器会对其进行操作，就像对待其他任何数据一样。\nCookie 开发工程师为了保护 Cookie 内容做了巨大努力，而我们现在正尝试忽视他们给我们的技巧。在我看来，这似乎有点倒退。\n\n简而言之，无论你是否使用 JWT，都必须使用 cookie。\n无法使单个 JWT 令牌失效\n还有更多的安全问题。与会话不同，会话可以在任何时候被服务器无效化，但是无状态的 JWT 令牌无法被单个无效化。设计上，它们将一直有效，直到它们过期，不论发生了什么。这意味着你不能，例如，在检测到攻击者后使攻击者的会话无效。当用户更改密码时，你也不能使旧的会话无效。\n你基本上是无能为力的，你不能”杀死”一个会话，除非建立复杂的(并且有状态的!)基础设施来明确地检测和驳回它们，这已经违背使用无状态 JWT 令牌的全部意图。\n数据过期\n这个问题与上述问题有些相关，而且是另一个存在的安全问题。就像缓存一样，无状态令牌中的数据最终会「过期」，并非数据库中的最新数据。\n这意味着一个令牌包含一些过时的信息，如某人在其个人资料中更改的旧网站 URL - 但更严重的是，这也可能意味着某人有一个具有管理员角色的令牌，尽管你刚刚撤销了他们的管理员角色。因为你也无法让令牌失效，自然无法撤回他们的管理员访问权限，除非关闭整个系统。\n实现的经验不足或者根本不存在\n你可能认为所有这些问题只与无状态 JWT 令牌有关，你可能大部分是对的。然而，使用有状态的令牌基本上等同于一个常规的 Session…但没有经过严格测试。\n现有的会话实现（例如 Express 的 express-session）已在生产环境中运行了很多，很多年，因此它们的安全性得到了很大的提高。当你使用 JWT 令牌作为会话 cookie 的临时替代品时，你无法获得这些好处 - 你将不得不自行实现（并且在过程中很可能引入漏洞），或者使用一个没有经过实际检验的第三方实现。\n结论\n无状态的 JWT 令牌不能过期或更新，而且根据你存储它们的地方，会引入大小问题或安全性问题。有状态的 JWT 令牌在功能上与会话 cookie 相同，但没有经过严格测试和好的实现或客户端支持。\n除非你在开发一个类似 Reddit 规模的应用，否则没有理由把 JWT 令牌作为会话机制。只使用 Session 就好。\n那么……JWT 到底有什么用呢？\n在这篇文章的开头，我说过 JWT 有其良好的应用场景，但它们作为会话机制是不合适的。这仍然是正确的；JWT 特别有效的使用场景通常是那些把它们作为 一次性授权令牌 的场景。\n从 JSON Web Token 的规范中：\n\nJSON Web Token (JWT)是一种紧凑的、URL 安全的，用于在两方之间传输待传输声明的方式。[…]这使得这些声明可以通过数字签名或使用消息认证码（MAC）的完整性保护和/或加密。\n\n在这种情境下，“声明”可以被理解为”命令”，一次性授权，或者你可以将其描述为如下的任何其他场景：\n\n你好，服务器 B，服务器 A 告诉我我可以&lt;在此处填写声明&gt;，这是这里的（加密的）证据。\n\n例如，你可能在运营一个文件托管服务，用户需要验证身份才能下载他们的文件，但文件本身是由一个单独的、无状态的“下载服务器”提供的。在这种情况下，你可能希望你的应用程序服务器（服务器 A）发布单次使用的”下载令牌”，然后客户端可以使用这个令牌从下载服务器（服务器 B）下载文件。\n以这种方式使用 JWT 时，有一些特定的属性：\n\n令牌的生命周期很短。它们只需要在几分钟内有效，以允许客户端开始下载。\n令牌只预计使用一次。应用服务器将对每次下载发出新的令牌，所以任何一个令牌只用于请求文件一次，然后就被丢弃。根本没有持久的状态。\n应用服务器仍然使用会话。只有下载服务器使用令牌来授权单个下载，因为它不需要持久的状态。\n\n如你所见，在这里，将会话和 JWT 令牌结合起来是完全合理的 - 它们各自有自己的目的，有时你需要两者。只是不要使用 JWT 来处理持久的，生命周期长的数据。"},"Spaces/Resources/博客/技术类/2021-年终总结（技术向）":{"title":"2021-年终总结（技术向）","links":[],"tags":["年终总结"],"content":"简单的聊一聊一年下来自己学到了哪些技术，做了那些改变。\n学习技术与成果：\n\nMaven，啃了半本《Maven 实战》，经典永不过时。能够解决 Maven 冲突，并写了一个简单的 Maven 插件。\n学习使用 Docker，熟悉 Docker 基本命令，会编写简单的 Dockerfile，以及发布自己的 Docker 镜像。\n了解 Jenkis 自动化部署的流程，能够进行简单的构建。\n学习 Liunx，了解基本命令，熟悉管道，Shell，线程机制。\n编写了自己的自动化脚本，自动拉取代码打包，运行项目。\n会编写单元测试和集成测试，熟悉使用 Junit5 和 Mockito。\n学会使用了 Maven 插件：SpotBugs (代码缺陷检查工具)、Checkstyle (代码规范检查工具)、jaCoCo (测试覆盖率报告插件)、Flyway（数据库迁移工具）\n深度学习 Java 集合常用的集合类，并手自己写了 ArrayList、LinkedList 实现。\n了解了开源项目运作和管理流程、学会使用了 CircleCi 管理自己的代码。\n熟练使用 Java8 的语法、Stream、Optional、CompleteFuture（后悔学的太晚）。\n写了一个简单的新浪新闻爬虫。\nGitHub 也开始有绿点了，尽管不多，但也是个很好的开始。\n\n\n\n帮助开源项目 github.com/ByteLegend/ByteLegend，修复了一个 bug，这个是我参与开源修的第一个 bug。帮助修复了 ByteBuddy 中文文档错字 bug，尽管很小的 bug，但是能接触到 ByteBuddy 我感到很荣幸。\n了解 log4j 的漏洞的基本原理，并自己用代码开启 ldap 服务，复现了 bug。\n\n知识获取渠道推荐：\n\n正式抛弃百度搜索、全面拥抱 Google，如果无法用 Google、你也不应该用百度。必应搜索也可以、以及 V 站大佬做的搜索引擎 fsou.cc/，搜索结果来源取自 Google、必应等。访问 GitHub 和 Stack Overflow 有速度加成。\n取关了一系列公众号大 V，虽然他们技术很牛，但广告的投放技术也是牛上天。而且大部分文章抄袭国外的技术博客，程序员不应该等待别人给你投喂，应该自己去获取一手资源。\n论坛：\n\nV站 国内程序员论坛、 程序员的一切里面都有、牛人遍地跑。虽然是国内程序员论坛、但也是需要科学上网。\nHackNews，给程序员看的新闻。国内许多公众号大 V抄袭翻译的地方。\nGitHub 全球最大的同性交友平台（手动滑稽）\nCoolShell 博客技术论坛，作者是个乐于分享技术的大牛，文章质量非常高。\n[nipafx.dev/](You. Me. Java)，国外开源大牛的技术博客，你想知道的 java 的一切（java 8 ~ java18）里面基本都有。\n\n\n许多经典书籍，主要就看了这几本：《Java8 实战》、《Maven 实战》、《Effective Java》第三版、《重构改善现有代码设计》第一版。\n了解了一些非常优秀的程序员：方应杭（前端大牛，现在是全栈大牛、非常喜欢看他的直播）、ZhangBo(Gradle 公司员工，开源世界大牛，我的评价是无所不知)、陈皓（Collshell 作者）\n\n2022 的一些目标\n\n工作顺利、生活愉快。\n去年看书还是看的很少，许多经典书籍都还没开始看。2022 年，我要把 《重构，改善现有代码设计》第二版看完，读完《Effective Java》、《Java 并发编程实战》、《程序员的自我修养—链接、装载与库》、《编码：隐匿在计算机软硬件背后的语言》\n参与到更多开源项目中去、GitHub 绿点也可以多一些。\n保持自己的好奇心、做自己想做的事。\n"},"Spaces/Resources/博客/技术类/2022-年终总结":{"title":"2022-年终总结","links":[],"tags":["年终总结"],"content":"简单的聊一聊在过去一年的成果，包括生活和工作。\n生活\n\n优化自己的知识渠道。\n学会接纳孤独。\n换了一份很棒的工作。\n继续保持独立思考。\n花了一笔大钱买了 MacBook。\n\n影视\n2022 看的影视作品看的比较少，只看过几部精品\n\nn 刷了《武林外传》\n《异物志》\n《铁齿铜牙纪晓岚》1 ~ 4\n木鱼水心 - 《水浒传》\n《怪奇物语》第四季\n《The boys》 第三季\n\n学习技术与成果：\n\n给 Vue 的中文文档提交了 PR。\n写了一个 Java 版的语雀导出工具。\n重新优化自己的博客。\n\n2023 的一些目标\n\n工作顺利、生活愉快。保持自己的好奇心、做自己想做的事。\n学习 MIT 6.824 课程。\n尝试学习使用 Go 语言。\n产出更高质量的博客。\n"},"Spaces/Resources/博客/技术类/2023年终总结及个人复盘":{"title":"2023 年终总结 + 个人复盘","links":[],"tags":["年终总结"],"content":"不知不觉工作已经 3 年了，想要好好总结复盘一下今年的一些情况。今年的生活特别有记忆点，不再像过去的时间一样枯燥单调麻木，今年是一个全新的体验。\n身体的一些小状况 1~ 4 月\n年初刚到公司换了部门。\n1 ~ 4 月如果过去的两年别无二致，机械麻木的工作，蜗居在自己的安乐窝中 ，享受着奶头乐。但不变的，依然关注着 IT 前沿的技术信息，以及未来的一些发展，开始了解 AI，学习使用 ChatGPT，并自己捣鼓一些小玩意，密切关注着 AI 发展。技术上取得的一些小成就，帮公司搭了一套 GPT 服务，在公司做过一次 AI 使用的分享。\n1 ~ 4 月技术方面成长还算凑合，但身体出了一些状况，体验查出自己有肾结石，经历了人生中第一次手术，住院，jj 插尿管的酸爽（想起来都疼）。为了不让自己害怕，看了大量的肾结石相关的科普视频，结石的产生以及现有的手术方案，各种方案的优缺点等等，让我从新认识到自己的身体处于一个什么样的状态，所以如果有关于结石方面的问题，可以来问我哈哈哈，希望大家不要有哈哈。\n开始内耗 5 ~ 8 月\n5 ~ 8 月，中间断断续续看过一些技术书籍，也特意花时间学了 Obsidian 使用、卡片笔记法、ACCESS 知识管理，现在回想起来，这是今年投入时间最多也非常值得的事情。中间学了 100 多天的英语，自我感觉语感提升，后面认识的以为猎头也是因为英语，哈哈哈，可惜后面没有继续坚持。这个时候想要润，想要出国的想法达到了顶峰。\n日子还是那么浑浑噩噩的过着，但我是乐在其中，靠着王者荣耀，各种短视频麻痹着自己，享受着自以为是的快乐。人一旦闲下来就容易胡思乱想，想的多了发展成了内耗，自己的心态出现了问题，每天都在不切实际的幻想，幻想着自己成为技术大牛后，如何如何，每天都靠美好的幻想麻痹着自己，却少有行动，只是为了让自己内心满足，真是可怜。\n发现自己的状态不对，就开始看一些心里学的书籍《不再害羞》《被讨厌的勇气》，看哲学相关的视频，《人生的意义》《如何克服虚无主义》。每次看的时候都能给到我冲击和能量，但是结束之后一切好像恢复如初。我开始怀疑书上说的知识，开始把他当做麻醉人的鸡汤文章。\n跌落谷底，触底反弹。\n改变！！刻不容缓！！9 ~ 10 月\n经历了内耗的折磨，寻找解决方法无果，9 月 9 号晚上与好朋友微信语音聊到凌晨 2 点，探讨人生哲学，那天晚上就下定决心第二天一定要出门走走，改变自己内耗的状态。\n或许是上天真的想让我改变了，我永远不会忘记这一天 2023 年 9 月 10 号，待在深圳快 3 年的我，选择了去户外感受世界，选择了离家最近的海边。那天天气格外的好，中午的大太阳，在一阵小雨之后，格外清爽，我换了一身好看的衣服，带着我的帆布包，耳机，踏出了房门。大口呼吸着新鲜空气，耳机音量调的很大，音乐响起的那一刻，我的眼泪刷地一下就出来，那一刻是我感觉特别幸福。这是一种从未有过的感觉，可能是因为自我感动，自艾自怜，但是那种感觉真的太棒了，只是去到户外就能给我这么大的能量，哇生活真美好！！！\n从这天开始后，我就打算每周都去一个没有去过的地方，于是我去了深圳湾公园、海上世界、南头古城、中山公园、四海公园、大大小小的书店、各式各样的咖啡厅、深圳美术馆、会展中心等等。\n之后的生活仿佛开了挂一般，开启了一系列的连锁反应。我开始愿意尝试新鲜事物，开始愿意主动去和别人交流（尽管这对一个曾经社恐的人士很难）。在国庆期间与之好久没联系的朋友重新联络，通过他的介绍认识了很多创业者，开始大量社交，每次都会给到我很强的能量，我开始有信心和勇气去做自己舒适圈外的事情。\n后面的时间都在一点点的突破自己的舒适圈，并每天记录一些突破舒适圈的行为。例如换穿搭风格、戴墨镜出门、参加公司活动、参加兰海老师分享会、主动与陌生人交流，发自己的丑照等等。这些积累让我开始想要追求更难的挑战，机缘巧合下我报名了公司年会的主持（这因应该是近几年我做的最大的尝试了），哇真是个巨大的进步，我爱死自己了。\n在这些尝试中，我已经没有时间去胡思乱想，自然也没有内耗了，我开始愿意去尝试自己从未接触过的东西，我结交了一些好友，结束了长达 20 多年的单身状态。\n稳步前进 11 ~ 12 月\n这两个月已经很少关注 IT 行业的事情了，慢慢地发现自己开始对设计，服装、穿搭、潮流文化感兴趣，开始关注该行业的信息，后面的时间准备开始投入更多的时间在该领域，未来会发展成什么样子也不知道，只要自己喜欢就好。\n这一两个月我更多地关注自身的心态，情绪认知，看待事物的方式等等。可能自我感觉不明显，但是身边人的一些反馈，让我意识到，哦原来我是在变化的。\n12月份公司经历了一波裁员，熟悉的同事大多数都走了，自己的心态受到了些影响，沉浸在分别的情绪当中，或许这就是自己改变之后的需要承受的东西。我也不知道自己会不会是下一个，但是没关系，事情发生了就去面对就好了，这是未来的自己告诉我，我需要经历这些。\n2023 一些完成的目标\n看过的电影\n\n《涉过愤怒的海》\n《名侦探柯南-黑铁的渔影》\n《好像也没有那么热血沸腾》\n《惊奇队长2》\n《惊奇队长2》\n《涉过愤怒的海》\n《河边的错误》\n《灌篮高手》\n《误杀2》\n《保你平安》\n《巴霍巴利王》\n《巴霍巴利王2》\n《饮食男女》\n《心迷宫》\n《蜘蛛侠：纵横宇宙》\n《杰伊比姆》\n\n综艺\n\n《圆桌派第三季》\n《圆桌派第二季》\n《圆桌派第一季》\n\n剧集\n\n《请回答1988》 \n《武林外传》 心中第一神剧，没有之一，不记得几刷了。\n《少年谢尔顿4》\n《时光代理人》\n《我是大哥大》\n《鹊刀门》\n《凸变英雄2》\n《模仿犯》\n《灌篮高手》 不记得几刷了，每次看完都热血沸腾\n《星期三》\n\n书籍\n\n《人性的弱点》还没有读完\n《谁动了我的奶酪》\n《谁动了我的奶酪2》\n《活着》\n《在细雨中呼喊》\n《被讨厌的勇气》\n《不再害羞》\n\n2024\n2023年就要过去了，最近常听的一个播客节目「无人知晓」，特别喜欢孟岩，这里想引用他说的一句话作为我新的一年开始：\n愿新年的阳光打在你的脸上，愿你拥有无限的热情、勇气和平静，让万物穿过自己。"},"Spaces/Resources/博客/技术类/6.824分布式系统-Introduction":{"title":"MIT 6.824 分布式系统 - Introduction","links":[],"tags":["分布式/6.824"],"content":"分布式系统基础架构\n\n存储\n计算\n通信（关于通信的详细内容可观看 6.829 计算机网络）\n\n实现分布式所需的工具\n\nRPC (Remote procedure call)\n线程\n并发控制\n\n描述\n\n分布式系统的扩展，带来便利。\n\n高性能\n高容错\n\n\n扩展带来的几个问题\n\n容错性（Fault Tolerance）\n可用性 （Availability）\n可恢复（Recoverability）\n\n\n解决容错的手段\n\n避免写入非易失性存储（Non-Volatile Storage）\n使用复制，来增加容错（Replicated）\n\n\n\n一致性（Consistency）\n使用一个 key value 例子说明 强一致性(Strong Consistency) 和 弱一致性(Weak Consistency)\nGoogle 的 MapReduce"},"Spaces/Resources/博客/技术类/AI-工具使用分享":{"title":"AI 工具使用分享","links":[],"tags":["AI"],"content":"获得工具\n国外的一些 AI 聊天产品，无一例外访问都需要一些手段，使用成本较高。\n\nChatGPT\nGoogle 的 bard\nClaude ai\nBing Chat\n\n正常使用\n像和一个知识渊博的人在对话一样，无需顾忌他能否听懂你的问题，无需顾及之前和他谈过的内容，他就像一个真人一样，帮你解答一切。\n优化使用\n想要和提高和 AI 谈话的效率，有两个做法，一个是提升 AI 的理解能力，另一个是提升自己文字表达能力。\n提升 AI 理解能力\n业界使用最多的就是使用 prompt，给 AI 赋予一个角色，让 AI 在给定的角色中发挥作用，这样能够让 AI 的回复限定在角色中，让 AI 回复相关性和满意度更高。\n\n使用现成的高质量 prompt\n\nAiShort (ChatGPT Shortcut) - 简单易用的 ChatGPT 快捷指令表，让生产力倍增！标签筛选、关键词搜索和一键复制 Prompts | AiShort(ChatGPT Shortcut)-Tag filtering, keyword search, and one-click copy prompts\nGitHub - PlexPt/awesome-chatgpt-prompts-zh: ChatGPT 中文调教指南。各种场景使用指南。学习怎么让它听你的话。\n\n\n自己定义 prompt 并使用相关手段进行优化\n\nPromptPerfect - Elevate Your Prompts to Perfection. Prompt Engineering, Optimizing, Debugging and Hosting.\nChatGPT &amp; Midjourney Prompt Generator | Hero\n\n\n\n提升自己的知识水平\nQ：为什么需要提升自己才能用好 AI？\nA：你的提问水平决定了 AI 的回答水平。提问的水平越高，AI 就更能理解你的意图。有的时候你无法准确描述一个问题，是因为你对这方面的基础不够。\n场景：需要将字符串 Hello World变成 dlroW olleH。\n学过一些知识的应该都知道这个操作叫做 回文，我们可以像 AI 提问：在 xx 语言中如何实现回文？\n但是前提是你知道这个操作的专业术语，倘若你是一个小白你会如何去问这个问题？想让 AI 理解你的意图，你可能需要花更多的时间和更多的精力。\n一些 AI 工具\n\nAI工具导航\n编码\n\n代码智能补全工具 Copilot\n通过编写注释即可自动帮你实现代码，或者根据已有的上下文推导出代码的实现\n通过定义良好的方法名，自动实现方法逻辑\n\n\n项目生成\n\nMetaGPT 一句话生成一个项目，输出用户故事 / 竞品分析 / 需求 / 数据结构 / APIs / 文件等\n\n\n代码翻译，将 A 语言 转成 B 语言\n\nAI Code Converter | AI Code Translator | AI Code Generator\n\n\n翻译\n\n沉浸式翻译 - 支持多平台以及 openai\n\n\nppt\n\nGamma\ntome AI\n\n\n\n其他的替代品\n技术人员\n\n注册国外的 AI 账号\n使用开源项目搭建自己的 gpt\n\npandora github 开源项目，目前已经被封了\nChatgpt-on-wechat 支持多种 ai 模型\nChatGPT-Next-Web: 一键拥有你自己的跨平台 ChatGPT 应用。\n\n\n\n使用开源项目部署自己的 AI 服务，成本低，但需要懂一些技术。\n非技术人员\n\nPoe目前技术人员使用人数最多的平台，整合多个 AI 资源，部分收费。\nGPT Shared Chat 一个共享的 ChatGPT 使用平台 共享的 gpt 平台，不适合放一些敏感数据\n需要自备账号\n\nAI First\n当我要在公司分享这篇文章的时候，我忘记了写 PPT，于是我打开 PPT 制作软件，刚准备创建第一张 PPT 时才猛然想起，为什么不用 AI 帮我生成？\n这件事引起了我的思考，我在想我为什么没有第一时间想到去用 AI，而还是按部就班的去做这一件事，AI 已经有很多优秀的产品出现，但是好像和我的工作生活基本没有交集，难道这些 AI 工具不是为我服务的？\nAI 当然是为每一个人服务的，但我们并没有跳脱出原来僵化的思维，仅仅是在做某件事情觉得困难才去找一些相关的工具。因此我觉的有必要做每件事的时候思考一下，AI 能帮我做什么，我觉得这样 AI 才能真正帮助你。\n授人与渔\n了解程序员行业最新动态的途径，包括但不限于 AI。\n\nHacker News\n阮一峰的网络日志\nV2EX\nTrending repositories on GitHub today · GitHub\n"},"Spaces/Resources/博客/技术类/Code-Specification":{"title":"Code Specification","links":[],"tags":[],"content":"使用条件语句\nif 语句\n原则一：要使得正常情况执行代码过程清晰，优先考虑代码正常执行情况。\n原则二：不要用 ”&gt;” 代替 ”&gt;=” 或用 ”&lt;” 代替 &quot;⇐&quot;。\n原则三：正常情况的处理放在 if 后面而不是 else 后面（保证能快速找到代码正常的执行过程）。\n原则四：if 子句后面跟随一个有意义的语句，避免空语句。\nif-else if-else 语句\n原则一：把常见的情况放在最前面（既提高了阅读效率，也变相的提高了系统执行效率）。\n原则二：确保所有情况都考虑到，else 子句用作出错消息或者不考虑的情况。\nswitch case 语句\n原则一：为 case 选择最有效的排列顺序，当 case 超过3个，排序就更为重要。以下是一些排序原则。\n\n按字母顺序或按数字顺序排列\n把正常的情况放在前面\n按执行频率排列，最近常执行的 case 子句放在最前面\n\n原则二：尽量简化 case 子句中的操作，避免逻辑嵌套，可以将要执行的子句抽取成一个方法，使得逻辑更清晰。\n原则三：不要为了使用 switch 语句而刻意制造一个变量。\n原则四：利用 default 子句来检测错误的情况，而不是代替一种 case 的情况。\n原则五：避免代码执行执行越过 case，每条 case 都应该及时加 break;\n测试\n一个值得养成的测试习惯\n:::success\n每当你遇见一个bug，先写一个测试来清楚地复现它。仅当测试通过时，才视为bug修完。只要测试存在一天，我就知道这个错误永远不会再复现。这个bug和对应的测试也会提醒我思考：测试集里是否还有这样不被阳光照耀到的犄角旮旯\n:::\n推荐的测试方法\n方法一：对每一项相关的需求进行测试，以确保需求都已经被实现。\n方法二：对每一个相关的设计关注点进行测试，以确保设计已经被实现。\n方法三：用 基础测试来扩充针对需求和设计的详细测试用例。\n方法四：使用一个检查表，记录项目迄今为止所犯的错误类型。\n测试技巧\n技巧一：选择最有可能找到错误的测试用例。\n技巧二：结构化的基础测试，需要去测试程序中每一条语句至少一次。所需基础测试用例的最少数量可以使用该方法计算：程序本身记作1，每遇到关键字时加1，如：if,while,for,and,or,case 。\n技巧三：数据流测试，对于数据的状态进行测试。状态可以是：已定义，已使用，已销毁。还有一些术语用来描述对数据进行某种操作之前或之后的状态：已进入，已退出。对于所有已定义-已使用的组合进行测试是比较好的实践。\n技巧四：边界值分析，对于边界值一般会遇到三种情况：大于边界值，等于边界值，小于边界值。为这些情况编写测试用例。\n技巧五：使用几类坏数据测试，坏数据包括（数据太少，太多数据，错误的数据情况，长度错误的数据，未初始化的数据）。使用几类好数据测试，好数据包括（所期望的值，最小的正常情况，最大的正常情况，与旧数据的兼容性）\n技巧六：采用容易的手工检查的测试用例。如计算薪水，可以输入一些自身能判断的数据123，根据薪水规则计算出的结果，判断是否符合自己的预期。\n表驱动编程\n方法命名规范\n返回真伪值的方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n位置单词意义例Prefixis对象是否符合期待的状态isValidPrefixcan对象能否执行所期待的动作canRemovePrefixshould调用方执行某个命令或方法是好还是不好,应不应该，或者说推荐还是不推荐shouldMigratePrefixhas对象是否持有所期待的数据和属性hasObserversPrefixneeds调用方是否需要执行某个命令或方法needsMigrate\n用来检查的方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单词意义例ensure检查是否为期待的状态，不是则抛出异常或返回 error codeensureCapacityvalidate检查是否为正确的状态，不是则抛出异常或返回 error codevalidateInputs\n按需求才执行的方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n位置单词意义例SuffixIfNeeded需要的时候执行，不需要的时候什么都不做drawIfNeededPrefixmight同上mightCreatePrefixtry尝试执行，失败时抛出异常或是返回 errorcodetryCreateSuffixOrDefault尝试执行，失败时返回默认值getOrDefaultSuffixOrElse尝试执行、失败时返回实际参数中指定的值getOrElsePrefixforce强制尝试执行。error 抛出异常或是返回值forceCreate, forceStop\n异步相关方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n位置单词意义例Prefixblocking线程阻塞方法blockingGetUserSuffixInBackground执行在后台的线程doInBackgroundSuffixAsync异步方法sendAsyncSuffixSync对应已有异步方法的同步方法sendSyncPrefix or AlonescheduleJob 和 Task 放入队列schedule, scheduleJobPrefix or Alonepost同上postJobPrefix or Aloneexecute执行异步方法（注：我一般拿这个做同步方法名）execute, executeTaskPrefix or Alonestart同上start, startJobPrefix or Alonecancel停止异步方法cancel, cancelJobPrefix or Alonestop同上stop, stopJob\n回调方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n位置单词意义例Prefixon事件发生时执行onCompletedPrefixbefore事件发生前执行beforeUpdatePrefixpre同上preUpdatePrefixwill同上willUpdatePrefixafter事件发生后执行afterUpdatePrefixpost同上postUpdatePrefixdid同上didUpdatePrefixshould确认事件是否可以发生时执行shouldUpdate\n操作对象生命周期的方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单词意义例initialize初始化。也可作为延迟初始化使用initializepause暂停onPause ，pausestop停止onStop，stopabandon销毁的替代abandondestroy同上destroydispose同上dispose\n与集合操作相关的方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单词意义例contains是否持有与指定对象相同的对象containsadd添加addJobappend添加appendJobinsert插入到下标 ninsertJobput添加与 key 对应的元素putJobremove移除元素removeJobenqueue添加到队列的最末位enqueueJobdequeue从队列中头部取出并移除dequeueJobpush添加到栈头pushJobpop从栈头取出并移除popJobpeek从栈头取出但不移除peekJobfind寻找符合条件的某物findById\n与数据相关的方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单词意义例create新创建createAccountnew新创建newAccountfrom从既有的某物新建，或是从其他的数据新建fromConfigto转换toStringupdate更新既有某物updateAccountload读取loadAccountfetch远程读取fetchAccountdelete删除deleteAccountremove删除removeAccountsave保存saveAccountstore保存storeAccountcommit保存commitChangeapply保存或应用applyChangeclear清除数据或是恢复到初始状态clearAllreset清除数据或是恢复到初始状态resetAll\n成对出现的动词\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单词意义get 获取set 设置add 增加remove 删除create 创建destory 移除start 启动stop 停止open 打开close 关闭read 读取write 写入load 载入save 保存create 创建destroy 销毁begin 开始end 结束backup 备份restore 恢复import 导入export 导出split 分割merge 合并inject 注入extract 提取attach 附着detach 脱离bind 绑定separate 分离view 查看browse 浏览edit 编辑modify 修改select 选取mark 标记copy 复制paste 粘贴undo 撤销redo 重做insert 插入delete 移除add 加入append 添加clean 清理clear 清除index 索引sort 排序find 查找search 搜索increase 增加decrease 减少play 播放pause 暂停launch 启动run 运行compile 编译execute 执行debug 调试trace 跟踪observe 观察listen 监听build 构建publish 发布input 输入output 输出encode 编码decode 解码encrypt 加密decrypt 解密compress 压缩decompress 解压缩pack 打包unpack 解包parse 解析emit 生成connect 连接disconnect 断开send 发送receive 接收download 下载upload 上传refresh 刷新synchronize 同步update 更新revert 复原lock 锁定unlock 解锁check out 签出check in 签入submit 提交commit 交付push 推pull 拉expand 展开collapse 折叠begin 起始end 结束start 开始finish 完成enter 进入exit 退出abort 放弃quit 离开obsolete 废弃depreciate 废旧collect 收集aggregate 聚集"},"Spaces/Resources/博客/技术类/Collection-不常见的重要实现和原理":{"title":"Collection 笔记","links":[],"tags":["Collection"],"content":"判断线程安全类的准则\n当需要在多线程环境下，使用一些类时，我们首先就需要判断当前类是否是线程安全的，否则出现线程安全问题。\n准则一\n最直接，方便的准则就是查看类的源代码注释，上面提到的集合类都在注释声明了该类不是线程安全的。查找注释的时候可以直接搜索 Thread或者 synchronize关键字。\n准则二\n查看有没有使用同步语句：java.util.concurrent.* / synchronize / Object.wait()\n如果以上准则都不满足，几乎可以断定不是线程安全的类。\n多线程环境下使用 Collection\n多线程换环境下使用 ArrayList\n\n最好的办法是使用 Collections.sysnchronized(new ArrayList())\n慎用 CopyOnWriteArrayList，性能问题\n\n多线程换环境下使用 HashSet / HashMap\n\nHashMap 无脑使用 ConcurrentHashMap 替换\nHashSet 没有对应的 ConcurrentHashSet类，可使用以下方法\n\nCollections._newSetFromMap_(new ConcurrentHashMap&lt;&gt;()); 从一个 ConcurrentHashMap 获取 HashSet\nGuava 提供的 Sets._newConcurrentHashSet_();方法，创建一个线程安全的 Set。\n\n\n\n多线程换环境下使用 TreeSet / TreeMap\n\n使用 ConcurrentSkipListSet 和 ConcurrentSkipListMap （很少使用到），都是基于 Skip List 这一数据结构实现的。\n\n多线程环境下新的 Collection 类\n\nBlockingQueue 可以等待的队列。\n当队列为空的时候，获取元素就会进入等待状态，直到队列中有元素。插入元素时相反。\n使用场景很高级，很少使用到。一旦使用上，就要格外的小心。\n常用的实现 ArrayBlockingQueue，SynchronousQueue。\n\nCollection 工具方法集合\n返回一个空集合\n Collections.emptyList();\n Collections.emptyMap();\n Collections.emptySet();\n ...\nemptySet，emptyMap，emptyList，返回一个空集合。该空集合是全局唯一的，并且自动泛型化，在方法返回的时候很适用，节省时间和内存。\n将集合变成线程安全的\nList unSafeList = new ArrayList();\nSet unSafeSet = new HashSet();\nMap unSafeMap = new HashMap();\n \nCollections.synchronizedList(unSafeList);\nCollections.synchronizedMap(unSafeMap);\nCollections.synchronizedSet(unSafeSet);\nsynchronizedList，synchronizedMap，synchronizedSet 把制定的集合变成线程安全的。实际上只是把对应的集合中的方法加锁，优先使用 Concurret 集合类。\n将集合变成不可变的（只读）\nList modifiableList = new ArrayList();\nSet modifiableSet = new HashSet();\nMap modifiableMap = new HashMap();\n \nCollections.unmodifiableList(modifiableList);\nCollections.unmodifiableSet(modifiableSet);\nCollections.unmodifiableMap(modifiableMap);\nunmodifiableList，unmodifiableSet，unmodifiableMap 把指定的集合变成不可变的集合（也可以使用 Guava 的 Immutable ）。\nQueue 与 Deque\nQueue 是数据结构中的经典的「队列」，一个方向进，一个方向出。\nDeque 是「双端队列」，两个方向都可以进出。\nQueue 和 Deque 的常用实现是 LinkedList。\nVector 和 Stack\nVector 就是 ArrayList 的前生。\nStack 是数据结构中经典的「栈」，使用它的好处就是能够让人一眼看出你的意图。\n**Vector 和 Stack 都是 JDK 中非常古老的 class，并不是 interface! **两个类都不推荐使用，前者可以用 ArrayList 代替，后者可用 Deque 代替。\nPriorityQueue\n优先级队列，根据优先级进行排列。基于数据结构**二叉堆（特殊的二叉树）**实现，根节点的元素比所有子节点的元素都小。因此可以快速获取最大和最小元素。\nPriorityQueue 的实现必须提供比较器，在初始化队列的时候提供，或者由包含的元素提供。如果两个都不提供比较器，则报错。该优先级队列非线程安全。\n与 TreeSet 区别：数据结构不同，检索速度非常快（复杂度 O(1)），移除元素调整比 TreeSet 更快，遍历不保证有序。\nGuava 对 Collection 体系的有力扩展\n快速创建一个集合\nSets.newHashSet(1, 2, 3, 4, 5, 6);\nLists.newArrayList(1, 2, 3, 4, 5, 6);\nLists / Sets / Maps，方便的工具方法 newArrayList() / newLinkedList() / newHashSet() / newHashMap() 等，快速创建一个集合。\n快速创建一个不可变的 Map\nImmutableMap.of(&quot;key1&quot;, 1, &quot;key2&quot;, 2);\nImmutableMap.builder()\n        .put(&quot;key1&quot;, 1)\n        .put(&quot;key2&quot;, 2)\n        .put(&quot;key3&quot;, 3)\n        .put(&quot;key4&quot;, 4)\n        .put(&quot;key5&quot;, 5)\n        .build();\nImmutableMap 快速创建一个不可变的 Map，如果 Map 中的元素较少，可以使用 of 方法，元素较多使用 builder 方法。\n创建特殊的 Set 和 Map\nMultiset multiset = HashMultiset.create();\nmultiset.add(&quot;zz&quot;);\nmultiset.add(&quot;zz&quot;);\nmultiset.add(1);\nmultiset.add(2);\nSystem.out.println(multiset);\n \n// 打印结果\n[zz x 2, 1, 2]\n \n \nMultimap multimap = HashMultimap.create();\nmultimap.put(2,&quot;z&quot;);\nmultimap.put(1,&quot;a&quot;);\nmultimap.put(1,&quot;b&quot;);\nmultimap.put(1,&quot;c&quot;);\nSystem.out.println(multimap);\n \n// 打印结果\n{1=[a, b, c], 2=[z]}\nMultiset 可以记录重复插入元素的次数，MultiMap 支持同一个键插入多个元素。\nBiMap\nBiMap&lt;String, Integer&gt; map = HashBiMap.create();\nmap.put(&quot;a&quot;, 1);\nmap.put(&quot;b&quot;, 2);\nmap.put(&quot;c&quot;, 3);\nSystem.out.println(map.get(&quot;a&quot;));\nSystem.out.println(map.inverse().get(3));\n \n// 打印结果\n1\nc\nBiMap 是一个双向 Map，既可以键映射到值，也支持值映射到键。"},"Spaces/Resources/博客/技术类/Collection":{"title":"Collection","links":[],"tags":["Java","Collection"],"content":"什么是 Collection\nCollection 是 Java 世界中最重要的类库，是这个类库的顶级接口。它的实现有 Set，List。而 Set 的实现又有 HashSet，TreeSet……。List 的实现有 ArrayList，LinkedList ……。也就是说我们日常使用的集合类都基本是 Collection 接口的实现。\nCollction 常用方法\n**C：**new ArrayList()  / new LinkedList() / new HashSer() /…\n**R：**size() / isEmpty() / contains() / for() /stream\n**U：**add() / addAll() / retainAll()\n**D：**clear() / remove() / removeAll()\n\n其中 contains() 判断 collection 是否包含某一元素\nretainAll() 表示当前集合只保留与指定集合的公共元素，比如下面的代码：\n\n    public void updateCollection() {\n        Collection collection1 = new ArrayList();\n \n        collection1.add(1);\n        collection1.add(2);\n        collection1.add(3);\n \n        Collection collection2 = new ArrayList();\n \n        collection2.add(2);\n        collection2.add(3);\n        collection2.add(3);\n \n        collection2.retainAll(collection1);\n    }\n这样 collection2 进行 retainAll() 操作之后得到的结果就是与** collection1** 相同的元素，即：2，3。\n\n**removeAll() 正好与 retinAll() 相反，表示移除当前集合移除与指定集合相同的元素，比如下面代码：\n\n   public void deleteCollection() {\n        Collection collection1 = new ArrayList();\n        collection1.add(1);\n        collection1.add(2);\n        collection1.add(3);\n \n        Collection collection2 = new ArrayList();\n \n        collection2.add(2);\n        collection2.add(3);\n        collection2.add(4);\n \n        collection2.removeAll(collection1);\n    }\ncollection2 进行 **removeAll() **操作之后，collection2 中的元素为：4。\nList\nList 是有序且元素可重复的集合\nArrayList\nArrayList 底层是个数组实现，具有动态扩容的特点。说到数组，我们印象中的数组都是有容量限制的，都有一个固定大小，那 ArrayList 的动态扩容是怎么实现的呢？\nArrayList 动态扩容原理：当 ArrayList 满了的时候，会自动扩容。ArrayList 会创建一个新的更大的空间的 List ，把原来满了的 List 的数据，复制到新的 List 中，并把原来满的 List 丢弃。\nLinkedList\nLinkedList 底层是链表实现，LinkedList 在日常使用中很少使用到。\nArrayList 和 LinkedList\nArrayList 是 Java 世界中，最常用的实现。既然是最常用的实现，为什么我们还需要 LinkedList? 既然有两种实现方式，那么两者的的区别和优缺点又是什么？\n通过两者的底层实现可以发现他们各自的优势和区别。\n因为 ArrayList 底层是数组实现，根据数组这一数据结构的特点，可以知道，数组用于查询，速度非常快。但是，数组做增删的操作就很比较慢。\n而 LinkedList 的底层是链表实现，根据链表这一数据结构的特点，也很容易知道，链表的增删速度非常快，而对于查询来说就比较慢。\n因此，综上所诉。对于查询需求较多的，我们可以使用 ArrayList 的实现，对于增删需求较多的，就使用 LinkedList\nArrayList 的扩容机制\n我们经常往 ArrayList 中添加元素，在们看来 ArrayList 好像是一个无限容量的空间一样，可以一直往里面丢东西。实际上是 ArrayList 的扩容机制在搞鬼，每当容量不足的时候，他就会在背后帮我们自动扩容，而我们是感知不到这个过程的，扩容机制给我们造成了无限容量的假象。\n我们直接查看 ArrayList 的 add 方法源代码，如下。\n\n可以发现在添加元素前，使用了 ensureCapacityInternal 方法，来确保可以添加。我们可以在 ensureCapacityInternal 的实现方法中找到 grow 方法，这个方法就是 ArrayList 扩容的秘密。\n\n可以看到代码中的 newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，表示的扩容后，新容量等于旧容量加上旧容量右移一位。右移可以理解为除以 n^2，此处就是旧容量除以1的2次方，相加之后新容量就是旧容量的1.5倍。ArrayList 扩容机制简述就是：创建一个更大的空间，空间容量为原来容量的1.5倍，然后把所有元素拷贝过去，完成扩容。\n说到这里还有个问题没有解决，既然 ArrayList 容量是有限的，那么**我们直接 new 一个 ArrayList 的初始容量是多少呢？**其实源代码已经给出答案了。\n\n构造方法注释中标明，初始化容量是10。但我用 debug 调试的时候，发现初始容量并不是我们 new 的时候就创建好了，而是当我们往里面添加第一个元素时，触发了 ArrayList 的扩容机制，扩容成一个容量是10的新空间，再把我们要添加的元素放进新空间中。这属于懒加载机制，当我们需要添加元素时，才真正开辟空间。\nSet\nSet 是无序且元素不可重复的集合。在 java 世界中，判断两个元素是否相同使用 equals  方法。\n简单的 Set 实现\n我们可以顺着 List 的特性，以及 Collection 的 Contains() 方法来简单实现一个 Set。因为 Set 不包含重复元素，而且 Contains 方法就是判断元素是否重复。因此，只要往 List 中添加元素时，进行 Contains 判断，元素不重复就往 List 中添加，这样就能得到一个不包含重复元素的 List，也就是一个手写的简单 Set 实现。\nJava 世界的高效 Set 实现 HashSet\n虽然我们手写的 Set 也能用，但是相比 Java 中其它的 Set 实现，性能差距不知差了多少。Java 世界中最高效的 Set 实现当属于 HashSet 。\n一、HashSet 实现简述\nHashSet 之所以高效是因为他的背后是 HashBucket，即：哈希桶。每个哈希桶对应一个 hashCode。因此，每次往 HashSet 中添加元素的时候，首先通过 hash 运算，计算出它的 hashCode，再与哈希桶的 hashCode 进行比对，相同就把元素加入该哈希桶中。\n二、hashCode\n在了解 HashCode 之前，先了解下 Hash 运算。Hash 运算就是把我们数据变成一个哈希值，是一个单向映射操作。例如：假设 Hash 运算把名字变成姓氏，于是就是有「张三」→「张」、「李四」→ 「李」，以此类推。Java 世界中的 Hash 运算有它自己的一套运算规则，我们只需要知道经过 Hash 运算会返回一个 int 值就行了。\nhashCode 是数据通过 Hash 运算得到的值。我们可以通过 hashCode 来初步判断是否同一元素。\n在 Java 世界中对象返回的 HashCode 都遵守以下约定：\n\n同一个对象得到的 hashCode 相等\n两个对象 equals 为 true，hashcode 相等\n两个对象不等，hashcode 可能相等\n\n判断对象是否相等\n假设存在一个 Person 对象，它有 name 属性。现在我们要使得名字相同的对象为同一对象，应该怎么做呢？\npublic class Person {\n    private final String name;\n \n    public Person(String name) {\n        this.name = name;\n    }\n \n    public String getName() {\n        return name;\n    }\n}\n在上面提到过判断是否重复我们可以使用 equals 方法，因此我们可以该方法来解决。假如我们初始化 person1，person2，他们的名字都是「张三」。然后我们再调用 equals 方法判断 person1.equals(perons2) ，结果返回的却是 false，为什么？\n在我们看来，名字相同的人就是同一个对象，可是计算机却不是这么认为的，我们查看 Object 的 equals 方法发现，它比较的实际上是内存地址。因为是两个对象，所以他们指向的内存地址不同。尽管内存中的值相等，也没用。\n因此，我们就需要重写 equals，hashCode 方法来达到相同名字为同一对象的目的。\n    @Override\n    public int hashCode() {\n        return name.hashCode();\n    }\n \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof Person) {\n            Person person = (Person) obj;\n            return this.name.equals(person.getName());\n        }\n        return false;\n    }\n我们在 equals 中比较两个对象的名字是否相等，相等返回 true。同时遵守「两个对象 equals 为 true，hashcode 相等」的约定，所以我们再 hashCode 方法中根据 name 来返回 HashCode，当 name 相同时就会返回相等的 HahsCode。"},"Spaces/Resources/博客/技术类/Cookie":{"title":"Cookie","links":[],"tags":["Cookie","Web"],"content":"不知道大家是否想过这样一个问题，比如说我们登陆淘宝之后，点击订单，点击购物车，这些都是自己的信息。通过前面的学习，我们也知道 HTTP 协议是无状态的，我们与淘宝的服务器之间，只是通过一串串字节在交流。我们发送请求，就是发给服务器一串字节流，服务器收到后作出响应，也返回一串字节流。当我们点击「购物车」，点击「订单」他怎么知道是「我」在查看购物车信息，而不是张三在查看购物车呢？\n我们想到一种笨拙的解决办法：当我们点击购物车的时候，系统让你登陆账号密码，登陆之后就能正确访问你的信息了。当我们点击其他信息时，比如「订单」，系统也让你输入账号密码，这样订单信息也能正确访问了。这种方法是一种解决办法，但是给用户带来的体验很不好。cookie 就是用来维持登陆状态的东西。\nCookie 是什么 \n简单来说就是一串字符串数据，用来区分和辨别不同用户。可以理解为「身份证」，通过身份证这一串数据，我们就能知道是谁在访问服务器。当然这一字符串可能还会包含，Cookie 的过期时间，以及一些安全协议等等。\nCookie 如何维持状态当我们第一次登陆一个网站的时候，我们填写好自己的账号密码信息，向服务器发送登陆请求。服务器根据你传过来的账号密码进行判断，倘若账号密码正确，服务器就会返回登陆成功的信息，并且在返回的 response header 中使用 Set-Cookie  参数，设置一段随机字符串 Cookie。\n当我们有了 Cookie 之后，我们发出去的所有请求，浏览器都会帮我们把 Cookie 字符串带上，服务器就根据 Cookie 信息来辨别用户，返回正确的用户信息。\n使用 Java 代码获取 Cookie 信息\npublic class Crawler {\n \n    private static final String COOKIE_URL = &quot;http://47.91.156.35:8000/auth/login&quot;;\n    private static final String MESSAGE_URL = &quot;http://47.91.156.35:8000/auth&quot;;\n    private static final CloseableHttpClient httpclient = HttpClients.createDefault();\n \n    public static String loginAndGetResponse(String username, String password) throws IOException {\n \n        HttpPost httpPost = new HttpPost(COOKIE_URL);\n        httpPost.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);\n        httpPost.addHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&quot;);\n \n        Map&lt;String, String&gt; map = new HashMap&lt;&gt;(16);\n        map.put(&quot;username&quot;, username);\n        map.put(&quot;password&quot;, password);\n \n        HttpEntity entity = new StringEntity(JSON.toJSONString(map));\n        httpPost.setEntity(entity);\n        CloseableHttpResponse loginResponse = httpclient.execute(httpPost);\n \n        String result = getMessageByCookie(loginResponse.getFirstHeader(&quot;Set-Cookie&quot;).getValue());\n        loginResponse.close();\n \n        return result;\n    }\n \n    public static String getMessageByCookie(String cookie) throws IOException {\n        HttpGet httpGet = new HttpGet(MESSAGE_URL);\n        httpGet.addHeader(&quot;Cookie&quot;, cookie);\n        CloseableHttpResponse response = httpclient.execute(httpGet);\n \n        HttpEntity entity1 = response.getEntity();\n        InputStream is = entity1.getContent();\n        // 设置解析编码为UTF-8\n        String html = IOUtils.toString(is, &quot;UTF-8&quot;);\n        EntityUtils.consume(entity1);\n        response.close();\n        return html;\n    }\n}\n \n使用给定的用户名 username 和密码 password 进行模拟登录，然后获取服务器返回的 Cookie的值，并把获取到的 Cookie 带到下一次的请求中去访问个人信息。\n首先新建一个 HttpPost 对象，添加所需的头部信息。 Content-type 告诉服务器我们要给服务器发送的数据类型。 User-Agent 让我们模拟浏览器的方式去访问，避免被服务器屏蔽请求。\n使用 Map 对象将我们得账号密码存储起来，接着使用 JSON 工具转化为字符串，放到请求体中，执行 POST 请求，把返回的头部信息 Set-Cookie 的值拿到。\n使用 getMessageByCookie 方法，把获取到的 Cookie 值当做参数传入。方法中发送了一个 HttpGet 请求，把Cookie加到请求头中，发送到服务器，并把返回的 body 数据转化为字符串，返回去。\n这样就是一次使用获取 Cookie ，并使用 Cookie 的简单访问。"},"Spaces/Resources/博客/技术类/Docker-基础":{"title":"Docker 基础","links":[],"tags":["Docker"],"content":"软件的依赖，开发环境不确定性，导致部署软件项目是一件令人头疼的事。\n虚拟机解决了这个问题，但是太吃内存，很耗资源。 Docker 使用了一个轻量的虚拟机。\n优点\n\n保证开发、测试、交付、部署的环境完全一致\n保证资源的隔离\n启动临时的、用完即丢弃的环境，例如测试\n迅速（秒级）扩容\n\nDocker 基本概念\ndocker 可以类比装系统，换系统操作。有了这个前置知识，对于 docker 的一系列知识会更容易理解。\n镜像 (images) 与容器 (container)\n镜像就和电脑镜像是一样的，而容器对应的就是电脑。电脑和电脑之间是相互隔离的（A 电脑数据无法与其他电脑共享，除非使用特殊手段），容器之间也是如此。\n常用命令\npull\ndocker pull 镜像:镜像版本 \n从 docker 官方拉取镜像，镜像版本不指定默认下载 Latest 版本。镜像地址不指定默认从 Docker 官方仓库下载。\nimages 查看所有下载的 docker 镜像\nrun 运行容器\n\n—name 为将要启动的容器起一个名字，在引用容器 id 的时候可以替换成容器 name\n—restart=always 遇到错误自动重启\n-p 与宿主机（自己的电脑）\n-v &lt;本地文件&gt;:&lt;容器文件&gt; 与宿主机进行文件映射，使得容器内部和宿主机共享同一份文件\n-p &lt;本地端口&gt;:&lt;容器端口&gt; 将本地端口映射到 docker 容器内部\n-e  &lt;name&gt;=&lt;value&gt;  启动容器时传递的环境变量，使得容器在初始化时可以使用这些变量\n\nrm 删除容器\nstart/stop/restart 启动/停止/重启一个容器\nexec 访问容器，进入容器内部\nlogs 容器id 查看容器日志\ninspect 容器id 查看当前容器的状态信息\ntag 镜像id 给镜像取名字\n创建自己的镜像\n我们可以很方便的从 Docker 官方拉取镜像，就像我们可以很方便的去网上找到 win10 镜像一样。但是，Docker 镜像并不能完全满足你的需求，所以就需要我们自己制作一个镜像。\n在开始制作镜像之前，需要知道镜像内部都是分层的，我们来看一个 Redis 的 Dockerfile 文件\nFROM debian:buster-slim\n \nRUN groupadd -r -g 999 redis &amp;&amp; useradd -r -g redis -u 999 redis\n \nENV GOSU_VERSION 1.12\nRUN .... // 一系列命令（此处已省略）\n \nENV REDIS_VERSION 6.2.5\nENV REDIS_DOWNLOAD_URL download.redis.io/releases/redis-6.2.5.tar.gz\nENV REDIS_DOWNLOAD_SHA 4b9a75709a1b74b3785e20a6c158cab94cf52298aa381eea947a678a60d551ae\n \nRUN .... // 一系列命令（此处已省略）\n \nRUN mkdir /data &amp;&amp; chown redis:redis /data\nVOLUME /data\nWORKDIR /data\n \nCOPY docker-entrypoint.sh /usr/local/bin/\nENTRYPOINT [&quot;docker-entrypoint.sh&quot;]\n \nEXPOSE 6379\nCMD [&quot;redis-server&quot;]\n上面的代码都很简单\n\n使用 FROM 指定基础镜像（当多个镜像指定同一个基础镜像时，就不需要重复下载）\nRUN 后面跟一系列需要执行的命令\nENV 配置环境变量\nVOLUME 创建可持久化目录\nWORKDIR 指定了工作目录\nENTRYPOINT 为容器提供命令和参数\nEXPOSE 对外暴露的端口\nCMD 容器启动之后执行的命令\n\n可以看到镜像的制作都是一步一步来的，就好像你跟一个智能机器人说，我要 debian，然后帮我运行一些命令，帮我设置一个工作目录，帮我暴露一个对外端口等等，你只需要用机器人能听懂的语言跟它说，他就会按照你的要求去执行相应步骤。\nDockerfile 文件创建好之后，我们就需要把它构建成一个镜像文件。只需要使用如下命令\ndocker build &lt;dockerfile 所在目录&gt;\n等待 Docker 帮你构建完成，接下来你就可以同其他镜像一样使用自己的镜像。\n发布自己的镜像\n可以通过上面的步骤，自己编写了一个 Dockerfile，并且使用该文件构建一个镜像。如图：\n\n由于新构建的镜像是没有名字的，为了方便后续使用我们可以给它取个名字。我们可以使用如下命令：\ndocker tag cf6ef720090d zzf:1.0.0\n再次查看我们的镜像\n\n可以看到 REPOSITORY 那一栏名字变成了 zzf，TAG栏也变成了 1.0.0。需要特别声明的是，REPOSITORY那一栏的名称，定义了镜像的 push 和 pull 地址，由于我们命令为 zzf，并没有给镜像设置地址，因此当我们 push 的时候，docker 会使用默认的 docker 官方仓库的地址，如图：\n\n为了发布到自己的 docker 仓库中去，我们需要注册一个 Docker 账号。然后把我们的镜像名称改成如下:\ndocker tag cf6ef720090d wszzh/zzf:latest\n只需要在镜像名前加上 docker 用户名加 /，即可。这样使用 docker push 命令就能推送到我们的仓库，如图：\n\n这样就推送成功，我们可以登录自己的 Docker 账户查看该镜像。需要使用的时候只需要使用如下命令即可拉取我们自己的镜像，如果有多个版本，则需要在镜像地址后面加冒号跟上对应的版本号即可。\ndocker pull wszzh/zzf"},"Spaces/Resources/博客/技术类/Git-Bisect-快速上手":{"title":"Git Bisect 快速上手","links":[],"tags":["Git"],"content":"假设你刚接手一个项目，这时线上出现了一个 bug，因为对业务不熟悉加上老板施压，导致 bug 定位过程异常艰难，开始焦头烂额。\n聪明的你转念一想：既然无法准确定位 bug，那不如先找到是哪个提交引入的 bug，这样再去定位 bug 就简单很多了。\n于是你确认了bug 存在的 commit 区间，使用二分查找来找 bug commit ，假设 bug 存在的 commit 区间是（3 ~ 10），你开始了如下过程：\n\n你确定了 3 是没有 bug ，10 有 bug，于是使用二分查找，找到 6，判断 6 有 bug。继续缩小范围，最终找到了第一次出现 bug 的 commit 是 4，就能确定 bug 是 4 引入的。\n这个手动查找的过程比较繁琐，而恰好 git 是有命令来支持这个查找行为的，这个命令就是 git bisect。\nbisect 命令参数使用\n将上诉过程使用基本 Git 命令，来表示。\n\n找到引入 bug 的 commit 范围\n二分查找，并切换到分支\n运行代码，判断是否有 bug 是否存在\n重复 2、3，最终确认第一次引入 bug 的 commit\n\n现在使用 Git Bisect来实现，步骤和上面都差不多，只不过省去了很多人为的动作。\n\n告诉 Git 需要开启 bisect 模式\n\ngit bisect start\n\n告诉 Git 需要查找的 commit 范围，需要指定一个 good (正常代码) 和一个 bad（存在 bug 的提交）\n\n// 切换到 commit 10，并标记为 bad\ngit checkout 10\ngit bisect bad\n \n// 切换到 commit 3，并标记为 good\ngit chekcout 3\ngit bisect good\n \n// 这样 bisect 就确认了 commit 范围\n\n步骤 2 执行结束后，Git 会进行二分查找，并自动切换到对应分支。只需要再验证分支是否还存在 bug，存在标记为 bad，反之 good\n\n// 根据实际情况标记为 bad 或者 good\n \ngit bisect good \n或\ngit bisect bad\n\n只需重复 3 的过程，最后 bisect 会帮我们找到第一个出现 bug 的 commit。\n\nIn Action\n实战 Demo 地址: GitHub 或 Gitee。\n这个项目有多个版本，从 v1.0 到 v9.1，其中我们能确定 v1.0 是没有 bug，v9.1 是有 bug 的，bug 的表现形式是一条输出语句I have a bug!，代码如下：\npublic class Product {\n    public static void main(String[] args) {\n        System.out.println(&quot;I&#039;m version 9.1!&quot;);\n        System.out.println(&quot;I have a bug!&quot;);\n        System.out.println(&quot;A bad feature!&quot;);\n    }\n}\n使用 git bisect 查找过程\n# 切换到任意版本(需要提前确认该版本是否存在 bug)，由于已确认 v9.1 有 bug，切换到 v9.1\ngit checkout v9.1\n \n# 标记 git bisect 开始\ngit bisect start\n \n# 存在 bug，标记为 bad\ngit bisect bad\n \n# 切换到不存在 bug 的分支，标记为 good\ngit checkout v1.0 \ngit bisect good\n \n# 此时 git 已经自动切换到一个新的 commit，标记当前 commit\ngit bisect (good or bad) \n \n# 重复上一步，直到 git，给出如下提示\nxxxxxx is the first bad commit\ncommit xxxxxx\n \n# git 已经帮我们找到了，第一次出现 bug 的 commit id，此时需要手动结束 bisect 过程\ngit bisect reset\n执行 git bisect reset 后，bisect 过程即结束。\n使用脚本\nbisect 支持使用脚本，使用脚本的目的是帮 git 来判断 bug。git 执行脚本，根据脚本的执行结果，自动帮我们标记 good 或 bad。\n上面的例子，可以根据输出结果包含 bug字样来判断 bug，对应的 shell 脚本命令如下：\n#!/bin/sh\n \njavac Product.java\nOUTPUT=$(java Product)\n \nif [[ $OUTPUT == *&quot;bug&quot;* ]]; then\n  exit 1\nelse\n  exit 0\nfi\n这个脚本执行 java Product，判断输出结果是否包含 bug 字样，包含则 exit code 为 1，反之为 0；\n有了这个判断脚本之后，上面的查找流程可以大大简化\n# 标记开始\ngit bisect start\n \n# 把 v9.0 标记为 bad，把 v1.0 标记为 good\ngit checkout v9.0\ngit bisect bad\ngit checkout v1.0\ngit bisect good (in v1.0)\n    \n# 执行脚本自动化查找过程\ngit bisect run &lt;脚本名称&gt;\n    \n# 脚本执行完之后，手动关闭 bisect\ngit bisect reset\n至此，bisect 查找过程结束。\n结论\ngit bisect 在业务开发方面使用的比较少，但是在开源项目中，使用相对比较频繁。\n对于开源项目，可以使用 git bisect 帮助开发者定位 bug，贡献 issues。\n对于棘手的 bug 定位，git bisect 为我们提供了另外一种解决思路。"},"Spaces/Resources/博客/技术类/Git":{"title":"Git","links":[],"tags":["Git"],"content":"Git 简介\n了解一门新的技术或者工具都要问这几个问题：它是什么？它有什么用？\nGit 是世界上最先进的分布式版本控制系统。这里又有两个小问题：什么是「分布式」？「版本控制」又是什么？\n首先讲一下「版本控制」。什么是版本控制呢，只要玩过游戏就能很好的理解，「版本控制」就像游戏的「存档」一样。一般我们打 boss 前都会存档，我们可能存在多个存档，每次想回到哪个时间点都能回去。我们遇到很难打的 boss ，可以借号给朋友，让朋友帮你过，朋友打完也可以存档，这样你玩的时候已经通关了。这就是「多人协作」的好处，同样 Git 也是支持多人协作的。相比游戏「存档」，Git 还可以清楚的知道每个存档你做了什么事，比如：你在存档 A 过了新手村，存档 B 击杀了 boss。游戏就不同了，「存档」和「事件」的对应关系，需要自己去记忆，存档多了就会很不方便。\nGit 命令\ngit add\ngit commit\ngit status\ngit diff\ngit log —pretty=oneline\ngit reset —hard head^\ngit reflog\n远程仓库\n远程仓库熟悉的有 GitHub，Gitee。我们可以把我们的本地仓库推送到远程仓库上去，接下来都以 GitHub 仓库举例，练习。\nSSH 配置\n由于本地的 Git仓库和 GitHub 的传输是通过 SSH 加密的，我们需要做一些简单设置。在用户主目录下，先检查电脑是否有 .ssh 文件夹，如果有，在看下有没有 id_rsa 和 id_rsa.pub 这两个文件。如果有，就跳到第二步。\n一， 打开 Git Bash，输入如下命令命令，创建 SSH Key，记得把邮箱换成自己的。\nssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n过程中出现提示，一直回车即可。成功的话，就可以在用户主目录下看到 .ssh 文件夹，以及该文件夹下的 id_rsa，id_rsa.pub 两个文件。\n二，在 GitHub 添加 SSH Key。把刚才的 id_rsa.pub 文件里的内容复制到 GitHub 要添加 SSH Key 的地方，完成添加即可。GitHub 添加 SSH Key 的位置自行搜索。\n推送到远程仓库\n使用如下命令关联远程仓库\ngit remote add origin 仓库地址"},"Spaces/Resources/博客/技术类/GitHub-提交作业":{"title":"GitHub 提交作业","links":[],"tags":["GitHub","Git"],"content":"使用一个工具的时候，应该先要问自己他是什么，他有什么作用？所以先根据这两个来初步了解下 Git 和 GitHub。\nGitHub\nGitHub 简单来说就是一个代码仓库，里面存放着世界各地程序员写的代码，我们也可以在 GitHub 上注册自己的账号，拥有自己的代码仓库。我们可以往自己的仓库提交代码，也可以去看一些大牛的仓库，学习他们的编码技巧，倘若发现一些小 Bug，我们也可以帮助别人解决，贡献一份力量。\nGit\n想一个问题：我们已经有了自己的代码仓库 GitHub，那么我们该怎么把自己电脑上的代码放到 GitHub 中去呢？\n解决这个问题的办法有：我们打开 GitHub ，在自己的代码仓库点击上传文件，这样就可以上传自己的代码。但是这样上传速度慢，而且容错性较差，可能遇到提交错误的代码，导致无法回到上一版本。\nGit 最大的用处，应该就是版本控制。可以记录你提交记录与版本，相当于「后悔药」，也支持多人协作，每个人的代码提交记录都会保存，所做的修改也有记录，这就是 Git 的好处。\n修改别人的代码\n这是一次在 GitHub 上完成提交的经历，整个过程如下：\n一、Fork 别人的代码\n首先，找到你要修改的仓库地址。因为是别人的代码，你没办法直接 「clone」复制下来，修改并提交，除非仓库的主人你认识，并且赋予了你修改的权限。既然没有直接的修改权限，那么我们就要 Fork 一份代码。Fork 的意思是：把当前仓库，拷贝到自己的 GitHub。Fork 的结果就是你的 GitHub 中多了一个一模一样的仓库。Fork 操作如图：\n\n图中的 Fork 结果，在我的 GitHub 中多了一个「JavaCollection」的仓库，代码也和拷贝过来的一模一样。\n二、Clone 代码，并在本地进行修改\nClone 代码就相对简单很多了，找到 Fork 之后的仓库。我这边对应的就是我 GitHub 中的「JavaCollection」仓库，打开，并点击「code」，弹框选择 「HTTPS」,复制 「HTTPS」下面的地址。需要说明一点：如果你对 「SSH」和「GitHub CLI」不熟悉，就老老实实选择「HTTPS」。\n\n复制好地址之后，打开开发者工具，此处以 IDEA 举例。打开 IDEA，并在首页点击 Get from Version Control ，不同的 IDEA 版本可能名称不一样。\n\n在弹出的对话框中，选择在 Version control 选择 Git，并在 Url 一栏粘贴刚才复制的地址，再点击 Clone 即可\n\n点击 Clone 之后，IDEA 会自动帮你把代码拷贝到本地，拷贝完成之后 IDEA 提示你「是否需要打开它」，选择「Yes」，等待一会，就可以对代码就行操作了。\n\n三、Commit 代码，并 Push 本地代码到 GitHub\n点击 IDEA 左下角的 Version Control，可看到修改的文件详情，在需要提交的文件处右键，然后点击 Commit ，代码就会先提交到本地仓库\n\nCommit 代码之后，接下来就要进行 Push 操作，在 IDEA 工具栏中找到「VCS」「Git」「Push」，就可以把本地代码提交到自己的 GitHub 中。接下来可以在 GitHub 中找到对应的代码仓库，查看刚才提交 Push 的结果。\n四、发起 Pull requests\n在 GitHub 点击上传代码的仓库，就可以看到 Pull requests ，点击它，然后选择要提交的分支，以及他人仓库的分支，点击完成就可以了。\n\n发起 Pull requests 之后只需要等待开发者查看你的 PR，根据情况判断是否需要，如果通过了，恭喜你成功贡献了一份力量，没有通过也不用气馁，可以看看不通过的原因什么，下次继续努力。"},"Spaces/Resources/博客/技术类/HTML常用标签":{"title":"HTML 常用标签","links":[],"tags":["Java","Web"],"content":"a 标签\n属性\n\nhref（指定要跳转的链接），取值如下\n\n网址（google.com，google.com，//google.com）\n路径（/a/b/c，a/b/c/，index.html）\n伪协议（javascript:代码;，tel:手机号，mailto:邮箱）\n\n\ntarget（指定打开链接的窗口），取值如下\n\n_blank（新窗口打开）\n_top（顶级窗口打开）\n_parent（父级窗口打开）\n_self（默认值，表示在当前页面打开）\n\n\n\ntable 标签\n相关的标签\n\ntable\nthead（表头）\ntbody（表内容）\ntfoot（表尾）\ntr，table row 缩写，表示一行。\ntd，table data 缩写,表示内容\nth，table header 缩写，表示标题\n\n我们可以用如下代码的来实现，一个简单的表格\n&lt;table&gt;\n    &lt;thead&gt;\n    &lt;tr&gt;\n        &lt;th&gt;&lt;/th&gt;\n        &lt;th&gt;小明&lt;/th&gt;\n        &lt;th&gt;小红&lt;/th&gt;\n        &lt;th&gt;小白&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;/thead&gt;\n \n    &lt;tbody&gt;\n    &lt;tr&gt;\n        &lt;th&gt;数学&lt;/th&gt;\n        &lt;td&gt;82&lt;/td&gt;\n        &lt;td&gt;93&lt;/td&gt;\n        &lt;td&gt;99&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;th&gt;语文&lt;/th&gt;\n        &lt;td&gt;82&lt;/td&gt;\n        &lt;td&gt;93&lt;/td&gt;\n        &lt;td&gt;99&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;th&gt;英语&lt;/th&gt;\n        &lt;td&gt;82&lt;/td&gt;\n        &lt;td&gt;93&lt;/td&gt;\n        &lt;td&gt;99&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;/tbody&gt;\n \n    &lt;tfoot&gt;\n    &lt;tr&gt;\n        &lt;th&gt;总分&lt;/th&gt;\n        &lt;td&gt;246&lt;/td&gt;\n        &lt;td&gt;279&lt;/td&gt;\n        &lt;td&gt;297&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;/tfoot&gt;\n\n\n\n\n\n\n\n\n\n小明小红小白\n&lt;tbody&gt;\n&lt;tr&gt;\n    &lt;th&gt;数学&lt;/th&gt;\n    &lt;td&gt;82&lt;/td&gt;\n    &lt;td&gt;93&lt;/td&gt;\n    &lt;td&gt;99&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n    &lt;th&gt;语文&lt;/th&gt;\n    &lt;td&gt;82&lt;/td&gt;\n    &lt;td&gt;93&lt;/td&gt;\n    &lt;td&gt;99&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n    &lt;th&gt;英语&lt;/th&gt;\n    &lt;td&gt;82&lt;/td&gt;\n    &lt;td&gt;93&lt;/td&gt;\n    &lt;td&gt;99&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n\n&lt;tfoot&gt;\n&lt;tr&gt;\n    &lt;th&gt;总分&lt;/th&gt;\n    &lt;td&gt;246&lt;/td&gt;\n    &lt;td&gt;279&lt;/td&gt;\n    &lt;td&gt;297&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tfoot&gt;\n\n\n其中 小明，小红，小白 为表头的标题，所以使用  标签包裹，并使用  标签表示表头。 数学，语文，英语，总分 也为标题，因此也要用  标签包裹，总分在  中，使用  包裹。这样就实现一个简单的表格。\n相关样式\n\ntable-layout\n\nauto，根据内容的宽度展示\nfixed，固定的宽度\n\n\nborder-collapse（border 是否合并）\n\ncollapse 表示合并\n\n\nborder-spacing（合并 border 之间的距离）**\n\nimg 标签\n作用\n发出 get 请求，展示一张图片\n属性\n\nalt（图片加载失败时展示的内容）\nheight（图片高度，直接使用数字。支持自适应，高度固定则宽度自适应）\nwidth（图片宽度，直接使用数字。支持自适应，宽度固定则高度自适应）\nsrc（引用图片地址，可以使用绝对路径，相对路径，网络地址）\n\n事件\n\nonload（图片加载成功事件）\nonerror（图片加载失败页面），通常可以做一些处理，例如当图片加载失败之后，可以使用默认的错误图片来展示。\n\n响应式\n\nmax-width:100%，自适应不同屏幕分辨率。可以使图片根据不同屏幕大小完整显示。\n\nform 标签\n作用\n发 get 或 post 请求，然后刷新页面。\n属性\n\naction（请求的地址）\nmethod（请求方法）\nautocomplete（比如输入账号有自动填充）\ntarget（指定刷新页面）\n\n事件\n\nonsubmit（表单提交）\n\n注意事项\n\nform 里面放一个 type = submit 才能触发事件。\n可以是 &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt; ，或者 &lt;input type=&quot;submit&quot;/&gt;\n\ninput 标签\n作用\n让用户输入内容\n属性\n\ntype\n\nbutton，按钮\ncheckbox，复选框，提交多个选项将 input 的 name 属性设置为相同的值\nfile，上传单个文件，上传多个需要在 input 中加入 multipart 即可\nhidden\npassword，密码类型\nradio，单选框，实现单选需要将两个 input 的 name 设为相同的值\nsubmit，提交表单\ntext，文本类型\n\n\n\n事件\n\nonchange，输入框中改变的事件\nonfocus，输入框焦点事件\nonblur，输入框移出事件\n一般不监听 input 的 click 事件\n"},"Spaces/Resources/博客/技术类/HashMap-前世今生":{"title":"HashMap 前世今生","links":[],"tags":["HashMap","Java"],"content":"要了解 HashMap 首先要先了解哈希表这种数据结构。哈希表是根据关键码值进行访问的数据结构。我们可以类比成现实生活中的电话本，如图所示。\n\n假设这个人交际能力特别强，他保存了很多人的电话，这个电话本就会很厚，当你想要查找某个人的电话时，就会非常费时。因此我们可以根据姓的首字母，分类排序，把张三放到 Z 里面，李四放到 L 里面，以此类推。通过这种方法，我们得找人效率就会大大提高。\n我们已经按照刚才的方法分好类了，可以看到 Z 分类下面有多个名字，我们把这样一组称作哈希桶，把 Z 叫做 哈希值，整个电话本就是一个哈希表，我们还把一个哈希值对应多个数据，这种现象叫做哈希碰撞。\n\n使用哈希表的好处就是 O(1) 的平均查找，插入和删除时间。致命缺陷就是哈希值的碰撞（哈希碰撞）。在 Java 世界中对于 哈希表的实现就是 HashMap。\nJava 7中的 HashMap\n经典的哈希表实现：数组 + 链表，其中链表采用头插法（每次有新元素都放到第一位）\nHashMap 构造方法\n查看 HashMap 源代码，它默认的初始大小是 1 &lt;&lt; 4  ，表示位运算，等价于 1 * 2^4 即等于16，因此默认大小就是16。且注释中规定容量必须是2的幂。\n\n源代码中定义了默认的 DEFAULT_LOAD_FACTOR （负载系数）是 0.75\n\n默认的构造函数，把默认的初始容量，以及默认的负载系数当参数传递给重载的构造函数。注意事项：当我们调用 HashMap 的构造函数时，哈希桶并没有开辟出来，只有第一次往里面 put 元素进去的时候，空间才会开辟出来，这样避免了空间浪费。\n\n\nHashMap put 方法\ninflateTable 方法\nput 方法首先是一个判断，判断表是否是一个空表，如果是就调用 inflateTable 方法，把 threshold 参数传进去。因为使用 HashMap 构造方法时，以及将初始化容量赋值给 threshold，所以他的值就是容量的值。\n\n执行 inflateTable 方法，我们可以看到该方法对于我们传来的容量值进行了一个向上取2次幂的操作。前面注释规定容量必须为2次幂，当我们自定义容量不为2次幂时，他就帮我们向上转为2次幂。例如：我们定义初始容量为17，他就会帮我们转化成32；初始容量定为5，帮我们转成8，这样就达到了容量必须为2次幂的要求。\n\nhash 方法\nhash 方法把我们输入的 key 值，通过他特定的算法，返回一个 int 值。既然我们知道了元素对应的 hash 值，那么我们应该如何设计一个映射，把元素放到它对应的哈希桶里呢？就像「张三」对应 “Z” 这个桶一样。\n数据结构课程中提到过取模运算，我们把 hash 值通过取模运算得到的结果，跟哈希桶编号进行比对，一致就放在该哈希桶里。但是这样做存在两个缺点：由于 hash 值可能得到负数，负数取模运算还是负数，而哈希桶编号是正数。因此遇到 hash 是负数的情况，需要转化成正数；其次，使用取模运算较慢。\n让我们看看源代码中 indexFor 方法，是如何设计其中的映射关系的。\nindexFor 方法 \n我们可以在 put 方法中找到这一行代码\nint i = indexFor(hash, table.length);\n其中把 hash 值和表的长度（表的长度为哈希桶个数，即为初始容量大小）当做参数，调用 indexFor 方法计算出该元素对应哈希桶的编号。\n我们点进去查看具体的方法实现\n\n如图所示，他把 hash 值 length - 1 进行了按位与运算，得到的结果就是索引坐标。它这样做的目的在于提高效率，与运算比我们刚才说的取模运算要快很多。\n**为什么容量必须是2的幂呢？**我们前面一直说到容量必须是2的幂，是因为方便这里进行与运算。2的正数次幂的二进制值首位是1其它全部都是0，例如：2^3 = 1000，2^4 = 10000。因此当他们再减1时，得到的值都会变成1，例如：2^3 -1 = 111，2^4 -1 = 1111。使用这种都是1的数与 hash 值进行与运算，得到的坐标就与 hash 值有关了。假设我们初始容量是 2^4，减1之后与 hash 值进行按位与运算得到的坐标如下。\n\n假如我们不用2次幂来设定容量，我们设定容量为7，与 hash 进行与运算得到的坐标如下。你可能会想，这样不是也可以得到坐标吗？这样可以得到没错，但是会发现有些桶永远是空着的。如下图所示，当我们的 hash 值无论为多少，和110进行与运算后，最后一位一定是0，因此必然得不到101，001，011坐标，所以哈希桶坐标为5，1，3的桶永远都是空着的。\n\naddEntry 方法 \n接着 put 方法往下看，addEntry 方法往指定坐标的哈希桶里面添加元素。具体的实现方法如下\n\n可以看到，添加元素前前。进行了一个判断，当哈希桶中的元素 size 大于等于 threshold（初始化容量 * 负载系数，即默认的为 16*0.75 = 12），并且指定的桶不能为空时，执行 resize 操作，新的容量是原来容量的2倍。\nHashMap 扩容操作\n以下是 resize 方法的具体实现\n\n扩容的时候容量为原来的2倍，然后把原来所有的元素全部迁移到新的中去。元素的迁移过程使用了 transfer 方法\n\ntransfer 方法遍历旧表中每一个桶里面的元素，重新进行 hash 运算，得到新的值，再把该元素放到新表中，对应的哈希桶中。\n缺陷\n\n在多线程环境中，java7中 HashMap 的实现容易成环，形成死锁，详见文章。\n可以通过精心构造的 HTTP 请求，使得所有元素都落入到同一个桶中，引发 DOS。\n\nJava 8中的 HashMap\n实现：数组 + 链表/红黑树，其中链表采用尾插法（每次有新元素都放到最后一位）\n链表转为红黑树\njava 8中使用了新的数据结构，红黑树。但并不全是红黑树，原来的链表也是存在的。java 8中给链表中的元素设定了一个阈值，大于等于这个阈值就会转化成红黑树，如下图所示。\n\njava 8 设定这个树形化的阈值 TREEIFY_THRESHOLD 为8，当链表中元素个数大于等于8时，就会转化为红黑树。\n**那么为什么要数量大于等于8时，才转化为红黑树呢？**这个在源代码中也有解释，下图截取自 java 8的源代码注释。\n\n通过图中的解释可以知道，我们的 hash 值是遵循泊松分布的。每个桶中有0个元素的概率是 0.60653066，以此类推，可以看到桶中有8个元素的概率是 0.00000006，超过8的概率小于十万分之一，这个概率已经非常小了。因此树形化阈值才会设定为8。\n扩容操作\njava 8在原来 HashMap 扩容的基础上改进了一点，原来的 HashMap 扩容之后不保证顺序，java 8则保持了扩容之前与之后的元素插入顺序一致，这样降低了线程出现问题的概率，但还是没有彻底解决线程安全问题。在多线程环境下请使用 ConcurrentHashMap。\njava 7中旧表中的元素要重新进行 hash 运算得到 hash 值，再把它放到新表中，而 java 8对这一方法进行了优化。\n\n假设图左边的初始容量为16，扩容之后诚意2得到的容量为32。 1001001......11011 这个哈希值，计算出它对应的坐标，因此与16 - 1的二进制，进行与运算，得到1011。而扩容到32时，按照原来的方法重新计算坐标得到 11011。从中我们可以发现，扩容之后，hash 值由原来的4位参与运算，变成了5位，我们把新增加的那一位称作高位，其他不变的称作**低位。**对应图中的高位就是标红的1，低位就是1011。进而我们也可以知道，扩容之后元素对应的坐标他的低位是不会变的，新坐标就取决于高位的值。\n\n如图，高位为1时，原来的坐标 1011对应十进制是11，扩容之后新坐标 11011对应十进制是27，坐标发生了改变。高位为0时，原来的坐标还是1011，新坐标也是1011，新坐标与原来坐标相等。因此可以总结规律：高位为0，扩容之后新旧坐标相等；高位为1，新坐标 = 1 + 旧坐标。\njava 8中 HashMap 就是根据这一规律进行扩容，这样计算新坐标比 java7重新进行坐标运算要快上不少。"},"Spaces/Resources/博客/技术类/Hexo博客搭建":{"title":"Hexo 博客搭建","links":[],"tags":["博客","Hexo"],"content":"这是一个简单的 Hexo 博客搭建教程，无需自己购买服务器，也能搭建属于自己的博客。\n准备工作\n\nGitee 账号或者 GitHub 账号。Gitee 账号和 GitHub 账号都很容易申请，考虑到博客的访问速度，更推荐使用 Gitee。然后新建一个公开的空仓库，仓库的命名需要和你的账号名保持一致。在 Gitee 中访问个人的主页，浏览器上的地址会变成 gitee.com/xxx，这个 xxx  就是你的账号名。同理，进入 GitHub 的个人主页，地址栏 github.com/xxx。\nGit。电脑需要安装 Git，使用 git --version 确保 Git 是安装成功的。\nNode 环境。Node 环境安装也很简单，百度关键词 nodejs 进入官网下载，安装了过程无脑下一步即可。安装完成后，控制台使用 node -v命令，打印出 node 的版本信息即为成功。例如我的电脑打印的 node 版本信息 v19.1.0。\n安装 Hexo。Node 环境准备好之后，使用命令 npm install -g hexo-cli 安装 Hexo，等待控制台输出完成即可，使用 hexo -v 验证是否安装成功。Hexo 官方文档有详细的安装方法，可以参考。\n至此，所有准备工作已完成。\n\n快速搭建\n首先，使用 hexo 命令创建一个文件夹，文件夹的名称和路径自己指定。为了规避一些潜在的问题，名称和路径最好是英文的。此处创建一个 blog 文件夹。\nhexo init blog\n等待一会，然后进入到 blog 文件夹。需要注意的是， 文件夹有个 .gitignore 文件，需要将 public/ 这行删除，后续步骤会使用到。\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/  # 删除这行\n.deploy*/\n_multiconfig.yml\n安装所需依赖。\nnpm install \n将 md 文件生成 html 文件，此时 blog 目录下自动生成 public 文件夹，用于保存 html 文件。\nhexo generate\n之后，使用命令在本地访问我们搭建的博客，看看效果。\nhexo server\n此时在浏览器上访问 http://localhost:4000 即可看到搭建的 hexo 博客了。停止访问只需要 Ctrl + C。\n推送到远程仓库\n博客能本地访问，无法满足大多数人的需求，搭建博客的目的就是为了能够随时随地访问。\n需要使用 git 命令提交，推送到远程仓库。要注意的是，只需要将 html 文件推送到远程仓库，因此推送 public 下的文件即可。\n进入到 blog/public 文件夹，使用 Git 进行初始化。\ngit init\n关联远程仓库地址\ngit remote add origin &lt;远程仓库地址&gt;\n使用 git 命令提交，推送到远程仓库。需要注意的是，只需要将生成好的 html 文件推送到远程仓库，因此推送 public 下的所有文件即可。\n# 添加 public 下的所有文件\ngit add .\n \n# 提交\ngit commit -m &#039;init blog&#039;\n \n# 推送到远程仓库\ngit push origin master\n推送成功后，远程仓库的目录结构应与下图类似\n\n使用 pages 服务\nGitee 和 GitHub 都提供了 pages 服务，pages 服务简单来说，就是让你的 html 文件能被其他人访问，这样就达到了博客共享的目的。\n\n这个一整套流程就是：编写博客（markdown），使用 hexo generate 将 md 文件编译成 html 文件，使用 git 命令将文件推送到远程仓库，配置好 pages 服务即可。当然，pages 只需配置一次即可。\n由于 Gitee 使用 pages 要实名认证，这里使用 Github pages 服务演示，原理都是一样的。\n进入到刚建的仓库，按照如下步骤配置 pages服务。\n\n这里告诉了 Github 要从哪个分支，哪个目录部署 pages 服务。如果你使用的是 Gitee Pages，原理也是一样的。pages 服务会去找 index.html 作为站点的入口文件。\n等待片刻，就可以使用 https://你的github账号名.github.io 来访问你的博客了。\n添加自己的博客\n以上部署好之后，可以开始编写自己的博客了。只需要将编写好的 markdown 文件放入 blog/source/_posts 即可。由于 hexo 默认的资源路径是 source，因此图片也应该放在该文件夹下。\n博客添加完成后，需要重新编译生成 html 文件\nhexo generate\n编译完成后，走上面的提交操作，把 html 文件推送到远程仓库。\n更换主题\nhexo 提供了大量的第三方主题，可以使用主题来美化博客。这里使用 fluid 主题举例，主题的官方文档点击这里。\n使用主题很简单，只需要按照它官方文档的要求来即可。\n例如 fluid 的官方文档说明如下\n\n将主题解压到 blog/themes 后，重命名为 fluid，然后修改 blog/_config.yml 文件，把 theme 字段替换为 fluid，语言也可以设置成中文。\n主题设置好之后，重新编译，提交，推送到远程仓库即可。\n若遇到主题样式不生效，可以先执行 hexo clean ，之后再执行 hexo generate 重新编译即可。\n若一切妥当，你的主题应该与我的博客基本一致。\n尾巴\nblog 文件夹下的文件，并没有一一细说其作用，日常只需要关心 public source _config.yml 几个文件即可。\n_config.yml 是整个博客的配置文件，有关的参数可以参考官方文档，有详细的说明。\n同样主题的细节配置，比如字体样式，大小，首页图片等等，都是以主题的官方文档为准。\n最后，期待你能根据我的教程，搭建满意的博客。"},"Spaces/Resources/博客/技术类/JVM-基本结构":{"title":"JVM 基本结构","links":[],"tags":["JVM","Java"],"content":"谈起 JVM 第一印象就是「八股」，毕竟正经人谁学 JVM 啊。当我深入学习，了解了相关原理后，真令人大呼过瘾。\n了解 JVM 并不会让你更快的 CRUD，对大部分工作没有实质性的帮助，但这是成为高级程序员的第一步。\nJVM 初识\nJVM 全称是 Java virtual machine 即 Java 虚拟机。JVM 是抽象（虚拟）计算机，它定义了一系列规范，因此他有很多实现，如：HotSpot，Eclipse OpenJ9 等等，最常使用的应该就是 Oracle 的 HotSpot。\nJVM 存在的意义就是抹平所有平台和操作系统的鸿沟。它就像是一个在不同平台提供的翻译官，当用英语和它对话时，他翻译成自己「国家」的语言并执行。这就是为什么在 Windows 下编写好的代码能够在 Linux 等其他系统运行的原因。\n代码编译执行过程如图\n\n程序员使用像 Java，Kotlin，Scala ，Groovy 等高级语言进行编码，编译成 JVM 能识别的语言。JVM 识别并进行「二次编译操作」，将它翻译成对应的平台语言。\n日常编码所做的仅仅只是用高级语言编写一份「说明书」，说明书如何编译成中间语言，这就是高级语言编译器做的事了，当然也可以自己去实现一个编译器，嗯。。至少我目前没有这个能力。\nJLS\nJava 语言规范 Java Language Specification， 定义了 Java 编程的语法。比如 Java 中的关键字信息 class、public 等等，都是在 JLS 规范下，完成 Java 代码的开发。\nJVMS\nJava 虚拟机规范 Java Virtual Machine Specifiction，定义了字节码如何在 JVM 中执行，仅此而已。\nJVM 堆 (Heap)\n堆是 JVM 中非常重要的区域，所有的「对象」都在堆上分配，它是个无情的对象生产机器，只负责生产，不负责销毁。\n堆为我们创建了对象，但是在代码中操作与访问对象实际上都是在操作对象的地址或者引用。\n来看个非常简单的代码，以此来演示堆中发生了什么\n   Object obj = new Object();\n   obj = new Object();\n\n首先堆内存中创建了一个对象（假设对象地址为 100），然后将该对象的地址赋值给 obj 变量，可以想象有一条线将 obj 和 对象 100 连接起来。\n接着，堆内存中又创建了一个变量 101，然后将该对象地址赋值给 obj，此时 obj 和对象 101 连接起来了。这就是堆所做的一切。\n很显然，上面的例子对象 100 还是存在堆中，他并没有消失，他还在等有缘人「联系」它。\n这样就会存在一个问题，「无人问津」的对象越来越多怎么办？这就涉及到 GC 了，GC 会根据相应的算法来判断对象是否需要回收销毁，因此暂时不需要操心，后续提供 GC 的讲解。\n当然堆中产生的对象太多，大量占用堆内存，导致内存溢出，常见表现为 OOM (Out Of Memory) 异常。当代码出现该异常时，就应该关心，代码是否产生了大量不必要的对象，谨慎的检查代码。\nJVM 栈（Stack）\n当我们用 IDEA Debug 如下代码，可以看到在 IDEA 界面底部，多了一些信息。\n    public static void main(String[] args) {\n        int i = 0;\n        a();\n    }\n \n    private static void a() {\n        System.out.println(&quot;I am a&quot;);\n        b();\n    }\n \n    private static void b() {\n        System.out.println(&quot;I am b&quot;);\n    }\n在我的调试器中表现形式如下：\n\n从 main 方法到 b 方法，中间一系列调用都称作**「栈」或「方法栈」，其中每一次方法调用称作「栈帧」**，如图中的 main，a，b。\n不知你是否思考过，为什么代码的调用形式会是这样？无论你是否好奇过，现在我来分析下代码执行的过程。\n我们都知道，Java  程序的入口都是 main 方法开始的，因此当代码被执行时，会先调用 main 方法。不过，在调用 main 方法之前，JVM 创建一个方法栈，用来保存「当前线程」方法调用过程（因此方法栈是线程私有的）。于是方法栈中会放入第一个栈帧 main，由于栈结构的特性，main 自然而然的就会在栈底。\n接着执行 main 方法，执行到最后需要调用 a 方法，因此将栈帧 a 放入方法栈中。接着 a 中又调用 b 方法，以此类推。现在，方法栈中已经有 3 个栈帧了，方法调用已经结束了。于是从栈顶开始，将方法的执行结果依次返回，b 方法中无返回值，因此执行完打印语句，b 栈帧就销毁了。以此类推到 a 方法，最后到 main，这就是上述代码玩完整的执行过程，流程如图：\n\n了解了方法调用的基本流程，这里有几个疑问：\nQ：当方法栈满了会发生什么？\nA：当栈深度过⼤时抛出 StackOverflowError，著名的程序员交流网站就是以此命名的 stackoverflow\nQ：栈帧销毁什么时候被销毁？\nA：这些情况栈帧会被销毁：当方法执行抛出异常或者错误；方法正常返回结果或者无返回。\n参数传递\n来看一段简单的代码， a 方法定义了一个变量，并且调用了 b 方法使得该变量自增，然后打印该变量。\n    public void a(){\n        int i = 0;\n        b(i);\n        System.out.println(i);\n    }\n \n    public void b(int i){\n        i++;\n        System.out.println(i);\n    }\na 方法中打印的结果为 0，按照正常的思维去理解的话，i 的值因该为 1 才对，这是为什么？\n这是因为这些变量在方法中都是**「值传递」**的，当把 i 传递给 b 方法时，发生了一次拷贝，因此 b 方法中操作的 i，实际上只存在 b 方法中，并不会影响到 a 方法中的 i 变量。\n上面说的是基本类型变量传递，接下来用引用数据类型来进行参数传递，看看发生了什么：\n    public void a(){\n        Object obj = new Object();\n        b(obj);\n    }\n \n    public void b(Object obj){\n        obj = new Object();\n    }\na 方法中初始化了一个变量 obj，并把它当作参数传递给 b 方法，b 方法中创建一个新的对象，并把该对象地址赋值给参数 obj。整个过程就是这样，此时 a 中的 obj 对象和 b 中的 obj 是什么关系？他们是同一个对象吗？b 中的对象改变了，会影响到 a 吗？\n有过编程经验的应该都知道，答案是否定的。\n\n如图所示，a 中 obj 变量指向 Object 10087，把 obj 当作参数给 b 方法时，他会直接复制 obj 所指向的对象地址，即 b 方法刚开始也指向 10087 对象。之后创建了一个新对象地址为 10086，并把地址重新赋值给了 obj，因此 b 中的 obj 指向的是 10086，而 a 指向的是 10087，两者操作的都不是同一个对象，因此也不会相互影响。\n栈帧\n现在已经对 JVM 中的堆和栈有所了解，但是对于方法栈中的每个栈帧还不了解，目前只是知道方法调用就入栈，结束就出栈。因此，现在将栈帧放大来看，看看代码执行过程中，栈帧发生了什么。\n每个栈帧中都有一个「操作数栈」和「局部变量表」。\n每当方法调用开始的时候，局部变量表会被初始化成当前方法的参数。操作数栈上会根据代码实际情况，加载局部变量表中的数据，或者直接加载常量，根据字节码指令集，完成相应的数据操作。\n这就像是人在吃饭一样，用筷子在碟子（局部变量表）中夹菜，夹到碗中（操作数栈），然后根据自己喜好（代码）吃自己的菜。\nJVM 方法区\n方法区中包含了整个虚拟机所共享的 Class 信息，JVM 就是根据方法区中 Class 这份说明书，来帮我们生成对象的。\n方法区中存的所有信息都是共享，基本都是只读的，但这并不是一定的。**「运行时常量池」**就是个例外，在程序运行时往往会往常量池中放入常量信息。\n运行时常量池会保存经常使用的常量，例如 String 字符串常量，当重复 new 一个相同字符串对象时，新的对象就会指向字符串常量池中的字符串常量，这样就节省了内存开销。同时在 String api 中，由于常量的重复使用，可以使得它的 equals 方法可以更快速地进行判断。\n永久代和元空间\nJVM 方法区是一块所有的线程共享的区域，是 JVM 所定义的规范。\nJava 7 之前发方法区的实现称作**「永久代」，即 PermGen。Java 8 之后的称作「元空间」**，即 Metaspace。\n在 Java 7 中，方法区和堆是使用一块连续的物理内存，仅仅是在逻辑上分开的。如果没有设置方法区的大小的话，使用默认大小很容易遇到 OOM 错误。\n在 Java 8 之后，把方法区和堆区分开来，使用了本地内存（Native memory），大小取决于本地内存大小。"},"Spaces/Resources/博客/技术类/Java-8函数式编程":{"title":"Java 8 函数式编程","links":[],"tags":["Java"],"content":"函数式编程\n优点： 减少工作量，减少 Bug，提高效率\n减少工作量：做同样一件事，普通的方法实现，可能需要几十行代码，而函数式编程只需要几行代码\n减少 Bug：代码写的越少，Bug 自然也变的越少\n提高效率：别人还在吭哧坑次的写几十上百行代码时，你已经写完，顺便刷了个知乎\n函数式编程深入浅出\n你可能对我的话不信，那咱们就来看看实际的例子\n假如给定一个用户列表信息，现在要你分别获取id 为偶数的用户、姓周的用户、姓王的用户，你会如何实现这个需求。\n大多数人会写出如下代码\n   // 过滤 id 为偶数的用户\n    public static List&lt;User&gt; filterUsersWithEvenId(List&lt;User&gt; users) {\n        List&lt;User&gt; result = new ArrayList&lt;&gt;();\n        for (User user : users) {\n            if (user.id % 2 == 0) {\n                result.add(user);\n            }\n        }\n        return result;\n    }\n \n    // 过滤姓周的用户\n    public static List&lt;User&gt; filterZhouUsers(List&lt;User&gt; users) {\n        List&lt;User&gt; result = new ArrayList&lt;&gt;();\n        for (User user : users) {\n            if (user.name.startsWith(&quot;周&quot;)) {\n                result.add(user);\n            }\n        }\n        return result;\n    }\n \n    // 过滤姓王的用户\n    public static List&lt;User&gt; filterWangUsers(List&lt;User&gt; users) {\n        List&lt;User&gt; result = new ArrayList&lt;&gt;();\n        for (User user : users) {\n            if (user.name.startsWith(&quot;王&quot;)) {\n                result.add(user);\n            }\n        }\n        return result;\n    }\n代码达到了我们需要的效果，但是你仔细观察，会发现重复的代码太多了，不同的地方仅仅是 if 中的条件判断，这个时候就需要思考一下如何简化这些代码。稍微细心的人就会发现，过滤姓张的用户，和过滤姓王的用户可以抽取成一个方法，只需要把姓氏当做参数传给函数就行了，如下\n  // 过滤指定姓氏的用户\n    public static List&lt;User&gt; filterUsersWithLastName(List&lt;User&gt; users,String lastName){\n        List&lt;User&gt; result = new ArrayList&lt;&gt;();\n        for (User user : users) {\n            if (user.name.startsWith(lastName)) {\n                result.add(user);\n            }\n        }\n        return result;\n    }\n这样的确简化了部分代码，但是仅此而已吗？难道过滤id为偶数的用户 方法，就不能跟其它方法合并了吗？\n这个时候你可能会想，要是可以传条件就好了，这样方法就能根据条件，过滤我们需要的用户信息。的确，这种方法确实可行，那要怎么去实现呢？既然传递的都是自己「实现」的条件，那么很容易想到「接口」这个东西。所以我们可以根据要求写一个接口，并提供一个方法，让其他实现该接口的类，自己定义方法的实现，如下\n \n    public static List&lt;User&gt; filterUsersWithCondition(List&lt;User&gt; users,Condition condition) {\n        List&lt;User&gt; result = new ArrayList&lt;&gt;();\n        for (User user : users) {\n            if (condition.isSatisfied(user)) {\n                result.add(user);\n            }\n        }\n        return result;\n    }\n \n    interface Condition {\n        boolean isSatisfied(User user);\n    }\n \n    static class ZhouUser implements Condition {\n        @Override\n        public boolean isSatisfied(User user) {\n            return user.name.startsWith(&quot;周&quot;);\n        }\n    }\n \n    static class WangUser implements Condition {\n        @Override\n        public boolean isSatisfied(User user) {\n            return user.name.startsWith(&quot;王&quot;);\n        }\n    }\n \n    static class UsersWithEvenId implements Condition {\n        @Override\n        public boolean isSatisfied(User user) {\n            return user.id % 2 == 0;\n        }\n    }\n我们使用了一个接口，以及三个类，每个类对应不同的实现。编写一个根据条件过滤的方法 filterUsersWithCondition，我们传入接口类，然后进行条件判断。\n但是实际上 Java 已经帮我们定义好了这些通用接口，不用我们再去定义，在 java.util.function包中，例如：\n@FunctionalInterface\npublic interface Predicate&lt;T&gt; {\n    boolean test(T t);\n他与我们自己定义的 Condition 接口很像，方法都是接收一个参数，返回一个布尔值。因此，我们完全可以把自己定义的接口，替换成官方提供的。这样又减少了一点代码量，以 ZhouUser类举例\n  static class ZhouUser implements Predicate {\n        @Override\n        public boolean test(User user) {\n            return user.name.startsWith(&quot;周&quot;);\n        }\n    }\n这个时候我们得 filterUsersWithCondition 方法，更改如下\n \n    public static List&lt;User&gt; filterUsersWithCondition(List&lt;User&gt; users,Predicate&lt;User&gt; predicate) {\n        List&lt;User&gt; result = new ArrayList&lt;&gt;();\n        for (User user : users) {\n            if (predicate.test(user)) {\n                result.add(user);\n            }\n        }\n        return result;\n    }\n实际上，做到这样已经很不错了，但是我们还能精简。每次调用 filterUsersWithCondition 方法的时候，都要传入一个实现类，并且每次有新需求，都要生成一个新类实现 Predicate 接口，这样代码量还是很多。\n我们可以这样，直接使用匿名类完成操作，这样我们就不用频繁的实现接口了。如下\nList&lt;User&gt; users = new ArrayList&lt;&gt;();\nfilterUsersWithCondition(users, new Predicate&lt;User&gt;() {\n\t@Override\n\tpublic boolean test(User user) { return user.name.startsWith(&quot;周&quot;);}\n})\n这个时候 IDEA 就会提示你了，按下快捷键 alt + enter 建，将匿名类转化为 Lambda 表达式。于是我们上面的代码就变成这样，代码瞬间简洁了很多。\nList&lt;User&gt; users = new ArrayList&lt;&gt;();\nfilterUsersWithCondition(users, user -&gt; user.name.startsWith(&quot;周&quot;));\n这边简单的介绍下 Lambda 表达式：user -&gt; user.name.startsWith(&quot;周&quot;)它对应的就是过滤姓周用户的匿名内部类 test 方法。-&gt; 左边对应参数，他完整的参数是 (User user)，由于 Lambda 可以通过上下文推断出参数类型，因此我们得式子仅仅指定了参数名user。-&gt; 右边的就是要执行的语句了，遇到多行执行语句需要用 {}括起来，用分号分隔语句。\nPredicate 中的 test 方法，是将一个 User 对象到 boolean 的映射。实际上只要我们写的方法满足object-&gt;boolean，都可以自动转化成一个函数接口。比如我们刚写的 Lambda 表达式 user -&gt; user.name.startsWith(&quot;周&quot;) ，以及我们将要展示的方法引用。\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;User&gt; users = new ArrayList&lt;&gt;();\n        filterUsersWithCondition(users, Main::zhouUser);\n    }\n \n    public static boolean zhouUser(User user){\n        return user.name.startsWith(&quot;周&quot;);\n    }\n \n    public static List&lt;User&gt; filterUsersWithCondition(List&lt;User&gt; users, Predicate&lt;User&gt; predicate) {\n        List&lt;User&gt; result = new ArrayList&lt;&gt;();\n        for (User user : users) {\n            if (predicate.test(user)) {\n                result.add(user);\n            }\n        }\n        return result;\n    }\n \n}\n我们自己编写了一个方法 zhouUser，这个方法也是满足 Object → boolean  的映射关系，因此他会被转化成相应的函数接口，这时使用方法引用调用这个方法，即可达到相同的目的。方法引用相比 Labmda 表达式的实现，更为清晰易懂，因为有方法名，我们很容易根据方法的名称来了解代码在干什么，对于日常维护开发更为友好。\nJava 中的函数接口\n先说一个结论：任何只包含一个抽象方法的接口，都可以转化成函数接口，例如我们刚开始使用的 Condition接口。\n在 Java 中不只有 Predicate，还有很多默认的实现。像，Consumer是 Object→void 的映射；Supplier是 void→Object 的映射;ToIntFunction 是 Object→int 的映射，等等，如图：\n\n我们可以根据我们得需求使用以上接口，或者自己定义我们所需的接口。\n使用 Comparator 实战\n当我们需要对数据进行比较的时候，就需要 Comparator\n还是上面说到的 User 对象，现在有了新需求，需要对 user 的 id 进行从小到大排序，然后按照年龄从大到小排列。我们可以使用 Collections.sort() 方法，对数据进行排序。可以发现需要传入的参数是一个 Comparator 接口，因此我们可以直接 New 一个 Comparator，并实现他的方法。代码如下\n        List&lt;User&gt; users = Arrays.asList(\n                new User(1, 18),\n                new User(2, 5),\n                new User(3, 7),\n                new User(4, 20));\n        \n        Collections.sort(users, new Comparator&lt;User&gt;() {\n            @Override\n            public int compare(User o1, User o2) {\n                if (o1.id &lt; o2.id) {\n                    return 1;\n                } else if (o1.id &gt; o2.id) {\n                    return -1;\n                }\n                return 0;\n            }\n        });\nJava 8 之后，JDK 为我们提供了更好的方法。在 Comparator 接口中有一个静态方法 comparing()，我们可以查看代码，发现他需要我们传入一个 Function 接口\n    public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(\n            Function&lt;? super T, ? extends U&gt; keyExtractor)\n    {\n        Objects.requireNonNull(keyExtractor);\n        return (Comparator&lt;T&gt; &amp; Serializable)\n            (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));\n    }\n因此我们传入的参数遵循 Function 接口对应的映射关系就可以了，打开发现 Function 是 T→R 的映射关系，即我们传入的参数转化成另一种数据类型。因此我们可以写成这样，User 类转化成整形，符合映射关系\nCollections.sort(users,Comparator.comparing(user -&gt; user.id);\n我们可以使用方法引用替换 Lambda 表达式，getId 方法表面上没有参数，实际上是有一个隐藏的 this，因次该方法引用也符合映射关系\nCollections.sort(users,Comparator.comparing(User::getId);\n比较了 id 之后我们还需要比较年龄的倒序排列，使用 thenComparing 继续比较，再使用 reversed() 方法将结果倒序排列。\nCollections.sort(users, Comparator.comparing(User::getId).thenComparing(User::getAge).reversed());\n这样就完成了我们得需求，一行代码完成了我们得工作，还减少了 bug，头发又可以少掉几根了，真是幸福。"},"Spaces/Resources/博客/技术类/Java-与命令行":{"title":"Java 与命令行","links":[],"tags":["命令行","Java"],"content":"在日常写 Java 程序的工作中，运行，debug 等等操作，本质上都是在进行命令行操作。我们在 IDE 上点击运行，Java 程序就会运行，实际上 IDE 在背后帮我们进行了命令拼接。\n我们可以在 IDEA 中编写一个简单的 Java 程序\npackage zzf;\n \n/**\n * @author zzf\n * @date 2021/2/28/028 21:53\n */\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(&quot;Hello World&quot;);\n    }\n}\n在 zzf 包下面有个 Main.java 类，里面有个 main 方法输出了 “Hello World”。在 IDEA 中点击了运行按钮之后，控制台会有一串命令行\nD:\\java\\jdk\\bin\\java.exe -javaagent:D:\\software\\Idea\\ideaIU-2019.2.3.win\\lib\\idea_rt.jar=56956:D:\\software\\Idea\\ideaIU-2019.2.3.win\\bin -Dfile.encoding=UTF-8 -classpath D:\\Java\\jdk\\jre\\lib\\charsets.jar;D:\\Java\\jdk\\jre\\lib\\deploy.jar;D:\\Java\\jdk\\jre\\lib\\ext\\access-bridge-64.jar;D:\\Java\\jdk\\jre\\lib\\ext\\cldrdata.jar;D:\\Java\\jdk\\jre\\lib\\ext\\dnsns.jar;D:\\Java\\jdk\\jre\\lib\\ext\\jaccess.jar;D:\\Java\\jdk\\jre\\lib\\ext\\jfxrt.jar;D:\\Java\\jdk\\jre\\lib\\ext\\localedata.jar;D:\\Java\\jdk\\jre\\lib\\ext\\nashorn.jar;D:\\Java\\jdk\\jre\\lib\\ext\\sunec.jar;D:\\Java\\jdk\\jre\\lib\\ext\\sunjce_provider.jar;D:\\Java\\jdk\\jre\\lib\\ext\\sunmscapi.jar;D:\\Java\\jdk\\jre\\lib\\ext\\sunpkcs11.jar;D:\\Java\\jdk\\jre\\lib\\ext\\zipfs.jar;D:\\Java\\jdk\\jre\\lib\\javaws.jar;D:\\Java\\jdk\\jre\\lib\\jce.jar;D:\\Java\\jdk\\jre\\lib\\jfr.jar;D:\\Java\\jdk\\jre\\lib\\jfxswt.jar;D:\\Java\\jdk\\jre\\lib\\jsse.jar;D:\\Java\\jdk\\jre\\lib\\management-agent.jar;D:\\Java\\jdk\\jre\\lib\\plugin.jar;D:\\Java\\jdk\\jre\\lib\\resources.jar;D:\\Java\\jdk\\jre\\lib\\rt.jar;D:\\idea-work\\testDemo\\out\\production\\testDemo zzf.Main\n当我们把该命令复制到 CMD 窗口运行的时候，同样控制台会打印 “Hello World”\nJava 执行过程\n我们平时写的源代码（.java 文件），需要编译成字节码（.class 文件），然后再给到 jvm 去解释执行。jvm 只认识字节码，多个 class 文件可以打包成 jar 包来执行。\nargs 参数\n我们写 Java 程序，main 方法里面都有一个 args 参数，实际上这个参数是可以从命令行获取的。编写以下程序获取打印 args 参数\npublic class Main {\n\tpublic static void main(String []args){\n\tSystem.out.println(java.util.Arrays.toString(args));\n\t}\n}\n使用如下命令编辑和运行该程序\n\n可以看到使用 java Main 运行时，打印为空字符串，而在后面添加 1 2 3 三个参数时，打印 [1,2,3] 。\njava Main 1 2 3 表示，调用 java 这个可执行程序，然后把 Main 1 2 3 这四个参数传递个 java。java 把 Main 这个类名拿出来，并且运行这个类，后面的参数 1 2 3 当做这个类的参数，传递给这个类的 main 方法。\njvm 中的系统属性和环境变量\n系统属性和环境变量是完全不同的东西，系统属性只在 jvm 中有效，不像环境变量可以继承属性。\n我们可以在代码中使用 System.getenv() 来获取当前环境变量，使用 System.getProperty() 获取系统属性。我们可以编写如下代码（其中 java.version 是 jvm 自带的系统属性）\npublic class Main {\n\tpublic static void main(String []args){\n    // 打印 args 参数\n\tSystem.out.println(&quot;args: &quot; +java.util.Arrays.toString(args));\n    // 打印名为 zzf 的环境变量\n\tSystem.out.println(&quot;env: &quot; +System.getenv(&quot;zzf&quot;));\n    // 打印名为 zzf 的系统属性\n\tSystem.out.println(&quot;System Property: &quot; +System.getProperty(&quot;zzf&quot;));\n    // 打印名为 java.version 的系统属性\n\tSystem.out.println(&quot;Java version: &quot; +System.getProperty(&quot;java.version&quot;));\n\t}\n}\n我们先使用 export zzf=helo 给当前环境添加环境变量 zzf，值为 hello，然后运行。\n\n可以发现系统属性 zzf 并没有，打印为 null。而由于 jvm 存在系统属性 java.version，所以正确打印出版本号。要传入系统属性给 jvm 我们需要使用 -D 参数，如图所示。\n\njava 代码中的包\n假设有如下代码 zzf.java：\nimport org.apache.commons.lang3.StringUtils;\npublic class zzf{\n\tpublic static void main (String[] args){\n\t\tSystem.out.println(StringUtils.isBlank(args[0]));\n\t\tSystem.out.println(StringUtils.isBlank(args[1]));\n\t\tSystem.out.println(StringUtils.isBlank(args[2]));\n\t}\n}\n该代码引用了第三方的包 org.apache.commons.lang3.StringUtils ，当我们使用 javac 编译的时候会报错，找不到这个包。因此，就需要指定这个包的目录，假设 commons-lang3-3.9.jar 文件和 zzf.java 文件在同一目录下，我们就可以使用 -classpath（简写 -cp），指定文件的位置。\njavac -cp commons-lang3-3.9.jar zzf.java\n这样就可以编译通过。但是在运行 java 程序的时候，需要同时指定引用的包的位置，还需要指定 zzf.class 文件位置\njava -cp ./commons-lang3-3.9.jar:. zzf 1 2 3\n该命令指定了第三方包的位置，以及 zzf.class 文件的位置。由于 zzf.class 文件是在当前目录，所以用 ”.” 来表示。在 Linux 中多个目录用 ”:” 隔开，Windows 使用 ”;” 隔开。\n总结\n回到这个命令行\nD:\\java\\jdk\\bin\\java.exe -javaagent:D:\\software\\Idea\\ideaIU-2019.2.3.win\\lib\\idea_rt.jar=56956:D:\\software\\Idea\\ideaIU-2019.2.3.win\\bin -Dfile.encoding=UTF-8 -classpath D:\\Java\\jdk\\jre\\lib\\charsets.jar;D:\\Java\\jdk\\jre\\lib\\deploy.jar;D:\\Java\\jdk\\jre\\lib\\ext\\access-bridge-64.jar;D:\\Java\\jdk\\jre\\lib\\ext\\cldrdata.jar;D:\\Java\\jdk\\jre\\lib\\ext\\dnsns.jar;D:\\Java\\jdk\\jre\\lib\\ext\\jaccess.jar;D:\\Java\\jdk\\jre\\lib\\ext\\jfxrt.jar;D:\\Java\\jdk\\jre\\lib\\ext\\localedata.jar;D:\\Java\\jdk\\jre\\lib\\ext\\nashorn.jar;D:\\Java\\jdk\\jre\\lib\\ext\\sunec.jar;D:\\Java\\jdk\\jre\\lib\\ext\\sunjce_provider.jar;D:\\Java\\jdk\\jre\\lib\\ext\\sunmscapi.jar;D:\\Java\\jdk\\jre\\lib\\ext\\sunpkcs11.jar;D:\\Java\\jdk\\jre\\lib\\ext\\zipfs.jar;D:\\Java\\jdk\\jre\\lib\\javaws.jar;D:\\Java\\jdk\\jre\\lib\\jce.jar;D:\\Java\\jdk\\jre\\lib\\jfr.jar;D:\\Java\\jdk\\jre\\lib\\jfxswt.jar;D:\\Java\\jdk\\jre\\lib\\jsse.jar;D:\\Java\\jdk\\jre\\lib\\management-agent.jar;D:\\Java\\jdk\\jre\\lib\\plugin.jar;D:\\Java\\jdk\\jre\\lib\\resources.jar;D:\\Java\\jdk\\jre\\lib\\rt.jar;D:\\idea-work\\testDemo\\out\\production\\testDemo zzf.Main\n先不管 -javaagent ，从 -Dfile.encoding=UTF-8 给 jvm 设置一个系统属性 file.encoding=UTF-8，然后使用 -classpath 指定引用的包路径，要运行的文件的位置。最后只剩需要执行的文件名称 zzf.Main 。把上述这些都交给 D:\\java\\jdk\\bin\\java.exe 该可执行程序执行。"},"Spaces/Resources/博客/技术类/Java-中的-GC":{"title":"Java 中的 GC","links":[],"tags":["Java","GC","JVM"],"content":"人在日常活动中不可避免会产生垃圾，程序也是如此。在方法中 new 一个对象，每次调用该方法都会进行 new 对象操作，如果没有人去管理这些对象，没有把这些对象占有内存及时释放掉，内存很快就会满。因此，在程序运行过程中，需要及时寻找和处理「 死去」的对象。这个「 死去」的对象就是垃圾，而寻找和处理垃圾的过程就叫做 GC。\nGC 全称 “Garbage Collection” 即垃圾收集。不同的语言对于 GC 的处理都是不一样的，因此也产生了不同的「流派」。\n需要说明的是：本文介绍的 GC 都是基于 HotSpot。\n垃圾管理流派\n根据内存的管理方式，划分出两个流派：手动管理和自动管理。\n手动管理的代表就是：C ++ 和 C。它们需要在编码过程中，手动去释放内存。\n\n优点：能明确垃圾的产生，以及提高回收的效率。\n缺点：垃圾太多，在代码中手动清理内存很「痛苦」，很容易忘记释放内存，导致内存泄露。由于需要明确垃圾的产生位置，因此也需要对该语言非常熟悉，这也无形中加大了语言的上手难度。\n\n自动管理的代表：Java (当然还有很多其他语言，篇幅有限，暂不阐述)。\n\n优点：使用者无需关心内存的使用，只需专注功能和业务的实现。内存的处理和回收有个智能的程序替我们完成。\n缺点：屏蔽了底层细节，出现了内存问题，使用者无法着手解决。当然解决办法也很简单，就是去了解 GC 原理。\n\n寻找垃圾\n现在我们知道 Java 是自动 GC，那现在问题来了：它是怎么去找到垃圾？怎么保证找的对象就一定是垃圾呢？\n在「 找垃圾」这块，也有两种方式：引用计数和可达性分析。虽然有两种方式，但主流的 Java 虚拟机里面都没有选用引用计数。\n引用计数\n在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。\n如图所示，小圆圈代表对象，箭头代表引用关系，数字代表对象被引用的次数。可以看到蓝色的对象都是处于「 活跃」状态的，而灰色的对象要么没有被引用，要么引用它的对象没有被引用，这些对象就是程序需要回收的垃圾。\n\n这一切看似完美无缺，实则存在一个巨大问题：对象间的循环引用。\n仔细看上面这张图，红色的对象相互循环引用，程序并没有使用到，理应当作垃圾处理。但是，在引用计数方法看来这是个「 活跃」的对象，因此并不会进行处理。\n在一些文章上有谈论到解决该问题的方法，例如：循环引用的对象使用 弱引用，使用单独的算法等，详情可以自行搜索。\n可达性分析\nJava 就是通过可达性分析算法来进行内存管理的。\n这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，即通过 GC Roots 访问不到该对象时，则证明此对象是垃圾。\n用比较生活化的例子来解释：家是内存，家庭成员是 GC Roots，物品是对象，家庭大扫除就是可达性分析。家庭大扫除的结果就是把家庭成员都用不到的东西归为垃圾，并把它清除掉。\n如图所示：灰色的对象就是 GC Roots 访问不到的对象，这些对象就是垃圾。图中也可以看到对象循环引用的问题的，在这里也已经不复存在，都会被当做垃圾。\n\n大扫除的例子，我们知道「 家庭成员」是 GC Roots，在 Java 技术体系中常见的 GC Roots 包括以下几种：\n\n线程\nnative 方法\n栈帧中的局部变量表\nClass 引用的 static field\n所有被同步锁（synchronized关键字）持有的对象\n\n引用\n通过上面两种方法来看，似乎对象在内存中的状态只有「 被引用」和「 未被引用」两种状态，GC 把「 未被引用」 的对象收集。\n在在内存空间充足时，可能并不希望「 未被引用」的对象被清除，只有当内存紧张时，才把那些对象抛弃。\n在 Java 中对引用的概念进行扩充，将引用分为：\n\n强引用（Strongly Re-ference）\n\n在 Java 程序代码中普遍存在的就是强引用，比如你 new 一个对象。\n\n\n软引用（Soft Reference）\n\n只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常\n\n\n弱引用（Weak Reference）\n\n当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象\n\n\n虚引用（Phantom Reference）\n\n一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。类似于 Linux 中的 退出状态。\n\n\n\n这4种引用强度依次逐渐减弱。\n垃圾自我救赎\n使用可达性分析找到「未被引用」的对象并不会立即将内存释放，而是给这些对象进行标记 ，当对象被标记两次后才会进行回收。\n\n当对象第一次标记之后，随后会进行一次筛选，筛选的依据是：对象是否有必要执行 finalize() 方法？\n假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为**「没有必要执行」**。\n对象被判定为「没有必要执行」，则直接进行回收。否则，会把对象放入到一个名为 F-Queue 的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。流程如下：\n\n对象的 finalize() 方法执行，GC 对 F-Queue 中的对象进行第二次标记。如果 finalize() 方法执行之后，对象重新回到了 GC Roots 的引用链上，则把它移出队列。否则，被 GC 回收。\n\n这个时候你可能就有问题了：那我在对象的 finalize() 方法中，编写代码使得当前对象重新回到 GC Roots 引用链上，这个对象岂不是永远不会被 GC 回收？\n答案是会被回收。可以看到「没有必要执行」的条件中有一条是： finalize() 方法已经被虚拟机调用过。因此对象虽然能回到引用链上，但是下一次 GC 它一定会被回收。总结就是：一个对象只能被救赎一次。\n其实关于  finalize() 方法，很多人也不了解，只需要知道它会于 GC 过程产生联系即可。在 《Effective Java》第三版 Item 8 ，以及《深入理解 Java 虚拟机》第三版中，作者都不建议在代码中使用 finalize，甚至让我们忘记这个 API。\n因此，使用  finalize() 方法的最佳实践就是：从不使用它。\n\n文章参考《深入理解 Java 虚拟机》第三版、《Effective Java》第三版、《Plumbr Handbook Java Garbage Collcetion》。\n"},"Spaces/Resources/博客/技术类/Java-内存模型":{"title":"Java 内存模型","links":[],"tags":[],"content":"\n 主内存与工作内存，介绍与区别\n 两个内存之间的交互，操作。以及一些需要遵守的规范\n volatile 型变量的特殊规则\n\n Volatile 变量的可变性描述误区\n volatitle 的线程不安全性\n 使用的运算场景\n 禁止指令重新排序\n volatile 与锁的选择\n Java 内存模型对 volatile 的定义\n\n\n long 和 double 的特殊规则\n 原子性，可见性，有序性\n 先行发生原则判断线程安全性\n"},"Spaces/Resources/博客/技术类/Java-包管理":{"title":"Java 包管理","links":[],"tags":["Java","Maven"],"content":"java 程序的本质就是在拼接命令行，如何拼接的细节，都由 ide 帮我们实现了。假如我们在程序中添加一个包，我们只需要 java -cp 后面补上包的位置，以及这个包依赖的其他包的位置。 当程序中引用的包越来越多时，带来传递性依赖也会越来越多，要在 Java -cp 后面一个个补上包的位置，并且保证不遗漏传递性依赖的包，并且还要保证包不能同名。这将是一比巨大的工作量，费时费力，还容易出错。\n这个时候就需要使用包管理了。它的本质就是告诉JVM如何找到所需的第三⽅类库，以及成功地解决其中的冲突问题。\nJVM 加载包\n首先，JVM 的工作被设计地相当简单：执行一个类的字节码，假如这个过程中碰到了新的类，就去加载它。\n既然碰到新的类就会去加载，那么就存在一个问题：去哪里加载呢？\n类路径（Classpath）\n当 jvm 去找一个新的类时，就会到类路径（Classpath）中挨个去找，碰到 jar 包就会解压缩再去查找。\n由于类的全限定类名（⽬录层级）唯⼀确定了⼀个类，因此 jvm 可以找到这个类。其中 jar 包本质上就是把许多类放在一起打的压缩包。\n包加载存在的一些问题\n\n**传递性依赖。**简单的解释就是，你依赖的类还依赖了别的类。例如：A → B → C，A 依赖 B，B 依赖 C。\nClasspath hell。因为全限定类名是类的唯⼀标识，所以当多个同名类同时出现在Classpath中，就会出现问题。例如：当 classpath 中存在同名的但是不同版本的 jar 包，A-1.0.jar 和 A-1.2.jar。jvm 会根据声明顺序去选择执行，假如 A-1.0.jar 声明在前，jvm 就会加载 A-1.0.jar，而不使用 A-1.2.jar。如果 A-1.0.jar 中是存在安全风险，那么到时候程序运行到安全风险时，就会导致灾难性后果。\n\n包管理工具\nApache Ant\nApache Ant 解决了部分包管理的问题。通过⼿动下载 jar 包，放在⼀个⽬录中。然后写XML配置，指定编译的源代码⽬录、依赖的jar包、输出目录等。\n这样做带来的缺点是什么呢？\n\n每个人都要自己造一套轮子库\n依赖的第三⽅类库都需要⼿动下载，费时费力。依赖的第三方类库越多，越麻烦。\n没有解决 Classpath hell 问题。即，还是可能存在包同名的问题。\n\nMaven\nMaven 包管理\nMaven 是划时代的包管理工具，但是 Maven 能做的远不止包管理。\nMaven 的理念是约定优于配置，默认的 Maven 项目结构都是一样的。Maven 具有中央仓库，包都是按照一定约定存储的。Maven 还有本地仓库，默认是位于 ~/.m2 。当我们引入一个依赖时，Maven 就会根据填写的信息找到对应的包，并把它下载到本地仓库，下载到本地仓库之后，下次再有相同的包，则直接从本地仓库找。\nMaven 的包按照约定为所有的包编号，方便检索。例如要在项目中引入 fastjson.jar\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;1.2.75&lt;/version&gt;\n&lt;/dependency&gt;\n通过 groupId / artifactId / version，来定位唯一的包。开发过程中只需要在 pom.xml 文件添加包相应的信息即可。\n其中 version 中的版本 1.2.75 是有一个规约的，1表示主版本号，2表示此版本号，75表示修订号\n\n主版本号：当你做了不兼容的 API 修改。\n次版本号：当你做了向下兼容的功能性新增。\n修订号：当你做了向下兼容的问题修正。\n\nMaven 的传递性依赖以及包冲突\nmaven 传递性依赖的⾃动管理原则：绝对不允许最终的 classpath 出现同名不同版本的jar包\nmaven 解决传递性依赖\n当我们引入相关的包时，maven 会帮我们下载这个包，**并且把他的传递性依赖的包都下载下来。**因此，在 maven 中我们不需要去管理包的传递性依赖问题，maven 都会帮我们处理好。\nmaven 解决传递性依赖带来的包冲突问题\n假设你的项目有以下依赖。A 依赖 C，C 依赖 D 的0.2版本；B 依赖 D 的 0.1版本。\n \n如果按照图上所示，把所有的包都下载，势必会造成前面的 Classpath hell 问题，因为两个包 D 同名了。首先，maven 会根据包的 groupId 和 artifactId 来判断是否为同一个。存在相同的包 maven 就会帮我们自动解决。\nmaven 解决的原则就是：离项目最近的胜出，如果一样近，则靠前声明的胜出。回到图中，D-0.2 离项目的距离是3，而 D-0.1 离项目的距离是2，因此 D-0.2就会被 maven 剔除，classpath 路径中只存在 D-0.1。maven 解决冲突的做法，在大部分情况下是可行的，但也有不行的时候。假设项目中使用了 D-0.2 中的 API，由于 D-0.1 是旧版，没有相同的 API，maven 根据原则，帮我们把 D-0.2 剔除了，这个时候项目启动就会报错了。\n手动解决包冲突\n当遇到上诉情况就需要我们手动来解决冲突问题。\n\n首先我们要对比冲突包的区别，判断项目实际上所需要的包（maven 中央仓库找到冲突的包，通过查看源代码进行对比）\n确定了所需要的版本之后，可以使用如下方法进行解决\n\n方法一：根据 maven 的解决原则，最近的胜出，我们可以直接在项目中引入一个 D-0.2 版本，此时 D-0.2 离项目的距离是1，所以会使用 D-0.2。\n方法二：指定 maven 排除不需要的包，把不需要的依赖排除掉，剩下需要的依赖就可以了。使用exclusions，在 B 的 dependency 中排除掉 D 的依赖。\n\n\n\n &lt;exclusions&gt;\n           &lt;exclusion&gt;\n                    &lt;groupId&gt;&lt;/groupId&gt;\n                    &lt;artifactId&gt;&lt;/artifactId&gt;\n           &lt;/exclusion&gt;\n &lt;/exclusions&gt;\n**tips: ** 可以使用Maven helper 查看依赖树，也可以通过 mvn dependency:tree 命令查看依赖树。\n依赖的 scope\n我们经常可以在 pom 文件中看到以下依赖\n   &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n            &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n   &lt;/dependency&gt;\n其中 groupId、artifactId、version 来定位这个包。scope 则是用来声明这个包在项目的作用范围。通常有这三个值\ntest 、 compile 、 provided 。test 表示包作用在测试代码中，src/test 目录下。compile 作用在源代码和测试代码中，并且编译和运行都有效。procided 作用在代码的编译期间，代码运行期间不生效。"},"Spaces/Resources/博客/技术类/Java-异常体系":{"title":"Java 异常体系","links":[],"tags":["Java"],"content":"在 Java 中，离开方法的手段可以 靠 return 方法返回，而异常是 return 方法之外，离开方法的手段。\n在实际工作中，经常会遇到空指针、找不到、文件找不到，等等不计其数的异常情况。那么 Java 中如何处理这些异常呢？\ntry / catch / finally\n当对一个文件进行写入操作的时候，所使用的 IDE 就会提醒，可能存在异常，需要处理。于是我们按照 IDE 的提示，编写了如下代码\n   public static void openFile() {\n        File file = new File(&quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\1.txt&quot;);\n        try {\n            OutputStream os = new FileOutputStream(file);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n代码主要分成两部分：try 包裹的部分，以及 catch 包裹部分，其中 catch 专门用来捕获异常。\n其中 try 包裹的，表示可能运行会出错的代码。上面的代码通过 File，构建一个输出流，由于 File 对应的文件不一定存在，导致构建输出流失败，出现异常。因此，构建输出流的代码就要放到 try 中包裹起来。\ncatch 包裹的代码，就是对异常进行处理的流程。上面的代码是将错误信息打印到标准错误流中。\n一般异常处理使用 try-catch 语句就足够了，但有遇到加载文件资源的情况，使用完之后就需要及时关闭。也许你会想把关闭资源操作放在 try-catch 语句之后，这也是可以的。但是，一旦 try-catch 中有return 操作，导致代码无法往下执行，关闭资源也就失效了。\nfinally就是解决这个问题的，无论 try-catch 中如何返回，如何调用，它包裹的代码块都会执行。在 catch 语句后加上 finally，以及包裹的代码，这样就完成了一套标准的异常处理流程。\n    public static void openFile() {\n        File file = new File(&quot;&quot;);\n        try {\n            OutputStream os = new FileOutputStream(file);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n           //执行资源清理操作\n        }\n    }\nTips：如果 try 中可能存在多种类型异常，我们就需要多个 catch 来捕获他们。\ntry-with-resources\n在上面的代码中提到资源清理操作，在生产过程中，可能不止一个资源需要清理，我们需要进行多个资源关闭操作，难免会忘记对些资源清理。因此，在 Java 7 中就引入了 try-with-resources这个语法糖。\n原先我们关闭资源操作写在 finally 中，如下\npublic static void openFile() throws IOException {\n        File file = new File(&quot;&quot;);\n        OutputStream os = null;\n        try {\n            os = new FileOutputStream(file);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            os.close();\n        }\n    }\n现在我们把 OutputStream os = new FileOutputStream(file)声明在 try 后面的括号里，声明在里面的东西它会帮我们自动关闭，因此 finally 语句也不用写了。代码如下\n public static void openFile(){\n        File file = new File(&quot;&quot;);\n        try (OutputStream os = new FileOutputStream(file)) {\n \n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n那么问题来了，什么类型的资源会自动关闭呢 ？\n答案就是所有实现了 AutoCloseable 这个接口的类，都能被自动关闭。比如上面的 FileOutputStream就实现了这个接口。当然智能的 IDE 在我们写 try-catch 的时候都会 给与提示，告诉你可以转成 try-catch-resources模式\n抛出异常\n上面使用 try-catch 捕获异常，但实际生产环境中也需要抛出异常，不在当前方法处理。手动抛出异常，需要用到关键字 throw。\n   public static void openFile() throws Exception {\n        throw new Exception();\n    }\n上面代码抛出了一个异常，但没有使用 try-catch 捕获处理。仔细观察的话，你会发现 openFile 方法后面多出了throws Exception，它的意思声明 openFile 方法可能会抛出异常。\n那为什么要声明异常呢？直接抛出异常不行吗？\n这就源于 Java 的「保护机制」，如果你的方法中可能存在异常，要么使用 try-catch 将它捕获处理，要么就使用 throws 给当前方法声明异常。任何调用了声明异常的方法，都需要处理传过来的异常，与前面一样，要么 try-catch，要么继续声明异常等待其他方法调用处理。\n public static void A() throws Exception {\n        throw new Exception();\n    }\n \n    public static void B() throws Exception {\n        A();\n    }\n如上面代码所示，B 调用 A 方法，A 方法没有 try-catch，而是使用 throws 声明异常。因此，B 方法就有两种选择，要么 try-catch 处理 A 抛出的异常，要么选择像 A 一样，声明一个异常继续向上抛出。显然 B 是同 A 一样，选择声明异常向上抛出，当其他方法调用 B 方法，也会面临 B 方法的两种选择。如果一直向上抛异常，而不使用 try-catch 处理，那么抛出的异常会击穿所有的栈帧，直到有方法将它 catch 住。\nTips：throw 是抛出一个异常，而 throws 则是声明方法可能要抛出的异常，切勿混淆。\nJava 异常体系\n\nThrowable - 可以被抛出的东⻄（有毒）\n\nException - checked execption（受检异常，有毒，代表⼀种预料之中的异常）\n\nRuntimeException （运⾏时异常，⽆毒，代表⼀种预料之外的异常，因此不需要声明）\n\n\nError （错误，无毒）\n\n\ncatch 的级联与合并\n\nThrowable 是所有 Exception 和 Error 的父类，只要是 Throwable 类型就可以使用 throw 抛出。由于 Error 和 Exception 是他的子类，因此也能被抛出。\n上面的继承体系中提到 「有毒」和「无毒」的概念，有毒指的是方法会传染，而无毒不会。「有毒」同前面的 A 方法和 B 方法一样，任何声明了有毒类型的方法，被调用之后，需要再次声明或者自己处理。任何声明了「无毒」类型的方法，被调用之后方法中无需做任何处理。「有毒」的代码实例，参考「抛出异常」章节的 A 和 B 方法。下面展示「无毒」的类型代码\n \n    public static void A(){\n        throw new RuntimeException();\n    }\n \n    public static void B(){\n        A();\n    }\n可以看到我们抛出了一个「无毒」类型异常 RuntimeException，当 B 方法调用 A 方法的时候，无需 try-catch，也无需声明异常。\n这就是「有毒」和「无毒」的区别，它们有专业的术语 checked和unchecked，表示「受检」和「非受检」。「受检」表示写的代码会被检查，IDE 一般都会提示你做相应的处理。「非受检」表示写的代码不会被检查，无需做处理。\nException 是预料之内异常，正因为在预料之内，所以 IDE 才会提示我们去处理这个异常。常见的有 IOException、FileNotFonudException 。RuntimeException 预料之外的异常，也正因为预料之外，因此 IDE 并不会对抛出的异常进行检验，因为根本无法检验。常见的有 NullPointerException，即空指针异常。\nError 代表一种严重的错误，他与 Exception 的区别是，前者代表不能恢复的异常，后面代表可以恢复的异常。大多数情况下，Error 代表一种不正常的情况，像内存错误（OutOfMemoryError）等。而像网络超时重连就是可恢复异常的表现。\ncatch 的级联与合并\n前面我们提到过，方法中存在多个异常，就需要多个 catch 来处理，如下分别对几种不同类型的异常进行处理，进来的异常会从上到下一次比对，进入到对应的 catch 中\n    try {\n \n        }catch (Exception e){\n \n        }catch (EOFException e){\n \n        }catch (FileNotFoundException e){\n \n        }\n但上面代码存在一个问题，Exception 下面的 catch 都不会执行。因为 Exception 是他们的父类，所以每次进来都是第一个 catch 被执行，所以我们应该调整顺序从小到大排列，这样才能根据不同异常类型，做不同处理，如下\n  try {\n \n        }catch (FileNotFoundException e){\n \n        }catch (EOFException e){\n \n        }catch (Exception e){\n \n        }\n在 Java 7 之后引用了新的语法，对于处理方法完全一致的异常可以进行合并。如下，都是将错误信息打印到标准错误流中，因此我们可以对它进行合并\n   try {\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n            e.printStackTrace();\n        }\n合并之后我们的代码就会变成这样\n    try {\n        } catch (FileNotFoundException | EOFException e) {\n            e.printStackTrace();\n        }\n异常的一些原则\n抛出原则\n\n\n能⽤ if / else处理的，不要使⽤异常\n\n无法保证抓出的异常是你想抓住的\n相比 if 判断，异常的创建是非常昂贵的操作\n\n\n\n尽早抛出异常\n\n\n异常要准确、带有详细信息\n\n\n抛出异常也⽐悄悄地执⾏错误的逻辑强的多\n\n\n处理原则\n\n\n本⽅法是否有责任处理这个异常？\n\n不要处理不归⾃⼰管的异常\n\n\n\n本⽅法是否有能⼒处理这个异常？\n\n如果⾃⼰⽆法处理，就抛出\n\n\n\n如⾮万分必要，不要忽略异常\n\n\n使⽤ JDK 内置的异常\n\nNullPointerException\nClassNotFoundException/NoClassDefFoundError\nIllegalStateException\nIllegalArgumentException\nIllegalAccessException\nClassCastException\n"},"Spaces/Resources/博客/技术类/Java-正则表达式":{"title":"Java 正则表达式","links":[],"tags":["正则表达式"],"content":"描述\n定义：用于描述文本/字符串的一组规则\n作用：使用一些自定义的规则来批量处理文本，提取信息\n优点：使用很少的代码完成复杂的文本提取工作，提高工作效率\n缺点：难学，难懂。在 java 对于正则表达式的支持不太友好，频繁使用会有性能问题。\n常见规则\n元字符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n^开始位置$结束位置.单个任意字符\\w单个”word”字符 字母/数字/下划线/汉字\\s单个空白字符\\d单个数字字符\\b单词的开始或结束\n重复\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*0次或多次+1次或多次?0次或1次{n}n次{n,}&gt;=n次{n,m}n到m次\n选择\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[aeiou]单个的a/e/i/o/u字符之一[0-9]单个数字字符[A-Z]单个大写字母[A-Z0-9_]大写字母或者数字或者下划线Hi|hi等价于[Hh]iHi或者hi\nJava 世界中的正则表达式\nJava 中的正则表达式是比较「昂贵」的\n\n正则表达式需要解析\n\nJava 需要将正则表达式字符串，转换成自己内部的数据结构，这个转换过程代价较大\n在写代码中可以将正则表达式预编译好，需要的时候再调用就行了，减少了多次编译的开销。例：\n\n\n\nprivate static final Pattern phoneNumber = Pattern.compile(&quot;0\\\\d{2}-[1-9]\\\\d{7}|0\\\\d{3}-[1-9]\\\\d{6}&quot;);\n\n匹配过程非常「昂贵」\n\nJava 的匹配算法并不高效，用到的是回溯算法。就像机器人走迷宫一般，一直尝试，遇到墙就换一条路线继续试，直到走出迷宫\n\n\n\nJava 中使用到正则表达式的方法：String 类中的 split，replaceAll，replacefirst，matches，以及 Matches 中的方法。可以查看相关的 demo 链接：判断是不是合法的固定电话号码，移除文件中的时间戳\n分组与捕获\n前面的正则表达式用法，都是用来判断字符串是否满足条件。然而，实际工作中用到较多的都是从一堆字符串中提取所需的信息，那么 Java 又是怎么做的呢？\n想要将所有符合正则表达式的⽂本抓出来处理，需要先了解如下规则：\n\n使⽤括号来指定⼀个被捕获的分组\n分组的编号从1开始\n分组的编号计算只看左括号\n(?:)不捕获和分配编号，括号只⽤于分组或标记优先\n分组编号为0表示整个匹配的字符串\n\nJava 中捕获数据\n在 Java 中可以使用 Pattern 类的 matcher() 方法生成 Matcher 对象 ，然后我们可以对 Matcher对象进行操作。\n假设有如下数据，我们需要将时间以及消费金额提取出来。\n2020-01-02 在家玩游戏消费0元\n2020-01-03 在家敲代码消费3元\n2020-02-02 出门旅游消费1000元\n我们可以先将该数据读取出来，保存成一个 List\nFile gcLog = new File(&quot;message.log&quot;);\nList&lt;String&gt; lines = Files.readAllLines(gcLog.toPath());\n然后我们可以在类中声明 Pattern，把对匹配时间和事件的正则表达式预编译。经过在线正则表达式测试，我们可以编写如下正则 \\d{4}-\\d{2}-\\d{2}(.*)?\\d 这个可以匹配时间和金额。我们要提取，就需要给时间部分加上括号，金额部分也加上括号。正则表达式变成 (\\d{4}-\\d{2}-\\d{2})(.*)?(\\d)。\nprivate static final String MESSAGE_REGEX = &quot;(\\d{4}-\\d{2}-\\d{2})(.*)?(\\d)&quot;;\nprivate static final Pattern pattern = Pattern.compile(MESSAGE_REGEX);\n接着对所有字符串进行匹配，匹配过程中会生成 Matcher。调用 Matcher 的 find 方法，判断是否匹配成功。因为分组编号为 0 代表匹配的全部信息，即日期+金额，group(1) 代表匹配的第一组信息，即时间，group(2）就代表金额。\n  for (String line : lines) {\n            Matcher matcher = pattern.matcher(line);\n            if(matcher.find()){\n                System.out.println(matcher.group(0));\n                System.out.println(matcher.group(1));\n                System.out.println(matcher.group(2));\n            }\n        }\n一个更为复杂的 GC 日志文件信息提取操作可查看 Demo"},"Spaces/Resources/博客/技术类/Java-线程模型":{"title":"Java 线程模型","links":[],"tags":["Java-线程"],"content":"Java 线程\nJava 虚拟机规范并没有对 Java 线程的实现进行约束，因此 Java 线程的具体实现由 Java 虚拟机决定。Java 在早期的虚拟机上也使用过用户线程实现，但目前的主流 Java 虚拟机线程模型普遍都使用操作系统原生模型实现。HotSpot 就是将一个 Java 线程映射到一个操作系统原生线程，接下来讲解都是基于 HotSpot 虚拟机的线程实现。关于 Java 新的 Project Loom，读者可自行了解。\n不同操作系统的线程概念也不相同，比如 Linux 中线程被当做一个 轻量级进程。每个操作系统线程操作的 API 都不一样，但是 JVM 实现了这一切，为我们屏蔽了这些细节。对于开发者来说，只需要使用 new Thread() 就可以得到一个线程。\n这种直接把线程映射到操作系统的操作，使得线程的管理全权交给操作系统，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都取决于操作系统。\n系统线程调度与 Java 线程调度\n首先，需要简单的介绍一下什么是系统调度。线程调度是指系统为线程分配处理器使用权的过程，线程并不是一直占着处理器的，而是交替使用的。要以什么样的策略去交替使用线程，使得每个线程都能够得到有效执行，就是线程调度方式。\n正如上面提到的那样，Java 线程的管理权都交给了操作系统，Java 中的线程调度实际上就是操作系统中的线程调度。因此，这里需要介绍一下操作系统的线程调度方式。\n线程调度的方式有两种：协同式线程调度和抢占式线程调度。\n协同式线程调度：线程的执行时间交由线程本身控制，当线程执行完自己的工作，会主动通知系统切换到下一个线程上去。它的实现简单，切换操作对与线程是可知的。但是执行时间不可控，倘若一直占有处理器，那么程序就会一直阻塞。\n抢占式线程调度：线程执行时间由系统分配。线程的切换不由线程本身决定，在 Java 中有 Thread::yield() 方法让出执行时间，但无法主动获取执行时间。因此，每个线程的执行时间是可控的，不会因为一个线程导致整个系统阻塞的问题。\nJava 使用的是抢占式线程调度。尽管无法控制线程的执行时间，但有时还是希望对某些线程多一些执行时间，另外的少一些，这时可以使用线程优先级。\nJava 中有 10 个级别的优先级，从 1 ~ 10。两个线程同时处于 Ready 状态，优先级越高的线程越容易被系统选择执行。但使用线程优先级这种方式，并不稳定。由于操作系统也拥有线程优先级，且和 Java 提供的线程优先级并非一一对应，尽管在 Java 中使用不同的优先级，但在操作系统中看来还是同一优先级。\n例如：Java 中给线程 A 设置优先级为 6，给线程 B 设置为 7 ，映射到 Windows 中的优先级是THREAD_PRIORITY_ABOVE_NORMAL，两个线程在系统中都是相同的优先级，调度不会发生改变。\n除此之外，在Windows 中存在「优先级推进器」的功能，当一个线程执行的特别频繁时，系统可能会越级去给它分配时间。因此程序不能完全依赖线程优先级，它并不「靠谱」。\nJava 线程的生命周期\nJava 线程中有 6 总状态，在任意一个时间点，线程只会处于其中一种状态。JDK 源码的 Thread 类中的内部类 State，介绍了这 6 总状态：\n\n新建（New）：尚未启动的线程。例：刚 New 出来的线程。\n运行（Running）：在 Java 虚拟机中执行的线程，线程处于运行状态。\n阻塞（Blocked）：线程等待监视器锁（monitor lock），所处的状态。\n无限期等待（Waitting）：处于该状态的线程，不会被处理器分配执行时间。只有被其他线程唤醒之后，才会执行。\n限期等待（Timed Waitting）：与无限期不同的是，一定时间内没有被唤醒，他会自动唤醒。\n结束（Terminated）：已终止的线程状态，线程已结束执行。\n\n阻塞与等待状态的区别\n拿去医院看病举例。医生科室门口挤满了人，但每次只能有一个人就诊，谁先挤进去谁先就诊，后面的人只能等就诊人出来，这时等待就诊的人处于**「阻塞」状态。医院改变就诊方式，只有叫到号的人才能就诊，没有叫到号的人只能一直等，此时等待就诊的人处于「等待」**状态。\nThreadLocal\nJava 使用 Thread 来表示线程，线程相关的操作 Thread 类都有提供对应的 API。但是想要访问每个线程的局部变量，却需要通过 ThreadLocal 。\n那么为什么线程局部变量要通过 ThreadLocal 来访问？\n直接使用 Thread 中的局部变量好像也没什么问题，可以在线程启动的时候给他的变量赋值，结束时 JVM 会把线程和变量一起销毁。这种方式当然可行，但是却忽略了线程池管理线程的情况。线程池为了复用线程，不会在线程执行结束后立即销毁，而是在需要时被重复利用，直到线程池关闭。正因为如此，线程局部变量会存在上一次的信息，很容易出出现线程安全，内存泄露问题。\n当然，每次使用会线程，进行一个手动清理变量的操作，线程复用就不会有什么问题。但麻烦点就在于清理，手动管理非常麻烦。ThreadLocal 每次使用完也需要进行清理操作，只需要调用 remove 方法即可。\n小结\n本文讲解了 Java 线程，但是作者心中存在很多疑问：CPU 线程、操作系统线程和 Java 线程之间是什么关系？他们之间是如何协作的？协程又是什么，与线程相比解决了什么问题？Python、Kotlin 是假协程？不同协程实现之间存在什么区别？\n对于上面的问题，已经在收集资料开始写了，下一篇博客《线程解惑》正在路上。\n参考资料：\n\n《深入理解 Java 虚拟机》第三版\n《Java 并发编程实战》\nChatGPT\nV2EX\n"},"Spaces/Resources/博客/技术类/Java-获取-GitHub-PR-信息":{"title":"Java 获取 GitHub PR 消息","links":[],"tags":["GitHub"],"content":"项目地址：链接\n使用 GitHub API 获取 PR\n工具包:\n\nApache HttpClient 用来发起 HTTP 请求\nApache Commons IO 将返回的字节流转化成字符串\nJackson Databind 将返回的字符串解析转化成所需对象\n\n访问 GitHub API\n访问 Github API 文档，找到 List pull requests 该项，根据 API 说明，应当使用 GET 方法，路径中还需要带上 owner 和 repo 参数，还需要设置 request header 中的 accept 为 appliccation/vnd.github.v3+json，这样就建立了一个正确的请求\n\n编写代码\n\n创建一个类来封装获取到的信息\n\nstatic class GitHubPullRequest {\n        // Pull request的编号\n        int number;\n        // Pull request的标题\n        String title;\n        // Pull request的作者的 GitHub 用户名\n        String author;\n \n        GitHubPullRequest(int number, String title, String author) {\n            this.number = number;\n            this.title = title;\n            this.author = author;\n        }\n    }\n\n新建一个方法，使用 HttpClient 工具包发起 HTTP 请求\n\nCloseableHttpClient httpclient = HttpClients.createDefault();\nHttpGet httpGet = new HttpGet(&quot;api.github.com/repos/&quot; + repo + &quot;/pulls&quot;);\nhttpGet.setHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;);\nCloseableHttpResponse response = httpclient.execute(httpGet);\n首先创建一个默认的可关闭的客户端，使用 HttpGet 创建一个 GET 请求，repo 是我们要接收的参数。再刚才创建的 GET 请求中设置他的请求头信息，与 GitHub 规定的 API 一致。然后使用刚才创建的客户端，去执行 get 请求，将返回的结果用 CloseableHttpResponse 接收。\n\n由于返回的结果是字节流，因此我们需要把字节流转换成我们需要的类型\n\n HttpEntity responseEntity = response.getEntity();\nInputStream inputStream = responseEntity.getContent();\nString result = IOUtils.toString(inputStream, &quot;UTF-8&quot;);\n使用 getEntity() 方法获取返回的 body 实体信息，获取到的实体信息调用 getContent() 方法获取内容，接着使用 IOUtils 工具把获取的内容从字节流以 UTF-8 的格式转化为字符串。 \n\n把字符串转化成 json 对象或实体对象\n\n \t\t\tObjectMapper objectMapper = new ObjectMapper();\n            JsonNode node = objectMapper.readTree(result);\n\t\t\t\n \t\t\tList&lt;GitHubPullRequest&gt; gitHubPullRequests = new ArrayList&lt;&gt;();\n            int number;\n            String title;\n            String author;\n            for (int i = 0; i &lt; node.size(); i++) {\n                number = node.get(i).get(&quot;number&quot;).asInt();\n                title = node.get(i).get(&quot;title&quot;).asText();\n                author = node.get(i).get(&quot;user&quot;).get(&quot;login&quot;).asText();\n \n                gitHubPullRequests.add(new GitHubPullRequest(number, title, author));\n            }\n使用 Jackson 工具，以树的形式反序列化 json 字符串得到 JsonNode，然后使用 for 循环将我们需要的数据封装到GitHubPullRequest 对象中，即可。\n解析 HTML 获取 PR\n工具包:\n\nApache HttpClient 用来发起 HTTP 请求\nApache Commons IO 将返回的字节流转化成字符串\nJsoup 将 html 字符串转化为 document\n\n找到要获取的仓库 PR 地址，发起请求\nCloseableHttpClient httpclient = HttpClients.createDefault();\nHttpGet httpGet = new HttpGet(&quot;github.com/&quot; + repo + &quot;/pulls&quot;);\nCloseableHttpResponse response = httpclient.execute(httpGet);\n发起请求并执行请求，获得返回的 response\nHttpEntity responseEntity = response.getEntity();\nInputStream inputStream = responseEntity.getContent();\nString result = IOUtils.toString(inputStream, &quot;UTF-8&quot;);\n获取返回的数据中，body的内容，并把它转化成字符串。\nDocument doc = Jsoup.parse(result);\n由于得到的是 html 字符串，使用 Jsoup 解析工具解析成 Document 类型。\nArrayList&lt;Element&gt; elements = doc.select(&quot;.js-issue-row&quot;);\n使用 document 的 css 选择器，获取页面中的元素。此处可以根据具体页面采用不同的选择器。\n   \t\t\tint number;\n            String title;\n            String author;\n            List&lt;GitHubPullRequest&gt; gitHubPullRequests = new ArrayList&lt;&gt;();\n            for (Element e : elements) {\n                title = e.child(0).child(1).child(0).text();\n                author = e.child(0).child(1).child(3).child(0).child(1).text();\n                String[] str = e.child(0).child(1).child(3).child(0).text().split(&quot; &quot;);\n                number = Integer.parseInt(str[0].substring(1));\n                gitHubPullRequests.add(new GitHubPullRequest(number, title, author));\n            }\n根据元素之间的层级关系，拿到对应元素的信息，把信息封装到 GitHubPullRequest 类中存储。一个简单的 HTML 爬虫实现。\n使用第三方 SDK 获取 PR\n工具包:\n\nApache HttpClient 用来发起 HTTP 请求\nApache Commons IO 将返回的字节流转化成字符串\nJackson Databind 将返回的字符串解析转化成所需对象\n"},"Spaces/Resources/博客/技术类/Jenkins-自动化部署":{"title":"Jenkins 自动化部署","links":[],"tags":["Jenkins"],"content":"简介：Java 编写的最广泛使用的开源持续集成工具，非常易用，广泛的第三方插件支持，以及分布式构建。\n文章所演示的项目地址：\nGitHub: github.com/greek-zzf/oh-my-jenkins.git\nGitee: gitee.com/geek-zzf/oh-my-jenkins.git\n安装\nWar 包方式\n优点：安装启动非常方便。\n缺点：与环境强绑定，服务器要为 Jenkins 提供部署项目所需要的环境，例如：Node、Java 等。 部署成服务需要使用对应平台的命令。\n安装步骤：\n\n\n访问 Jenkins 官网，找到安装方式，下载 War 包。或者直接点击这里下载。\n\n\n下载完成运行命令 java -jar jenkins.war ，等待几分钟。\n\n\n在浏览器中访问 http://localhost:8080，完成后续配置。\n\n\nDocker 方式\n优点：与宿主机环境隔离，不依赖宿主机环境。注册成服务非常方便，只需要启动时设置好参数 --restart=always 即可。\n缺点：启动稍微复杂，需要配置好启动命令。\n安装步骤：\n\n\n访问 Jenkins 官网，找到 Docker 安装方式。或者直接点击这里访问。\n\n\n运行 Docker 命令如下\n\n\nstep1: docker network create jenkins\n \nstep2: docker run --name jenkins-docker --rm --detach \\\n  --privileged --network jenkins --network-alias docker \\\n  --env DOCKER_TLS_CERTDIR=/certs \\\n  --volume jenkins-docker-certs:/certs/client \\\n  --volume jenkins-data:/var/jenkins_home \\\n  --publish 2376:2376 \\ \n  docker:dind --storage-driver overlay2   --insecure-registry 47.107.74.10:5000 \n \n \nstep3: 创建 Dockerfile 文件，并把如下内容复制进去\n \n    FROM jenkins/jenkins:2.332.2-jdk11\n    USER root\n    RUN apt-get update &amp;&amp; apt-get install -y lsb-release\n    RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \\\n      download.docker.com/linux/debian/gpg\n    RUN echo &quot;deb [arch=$(dpkg --print-architecture) \\\n      signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \\\n      download.docker.com/linux/debian \\\n      $(lsb_release -cs) stable&quot; &gt; /etc/apt/sources.list.d/docker.list\n    RUN apt-get update &amp;&amp; apt-get install -y docker-ce-cli\n    USER jenkins\n    RUN jenkins-plugin-cli --plugins &quot;blueocean:1.25.3 docker-workflow:1.28&quot;\n \nstep4: docker build -t myjenkins-blueocean:2.332.2-1 .\n \nstep5: docker run --name jenkins-blueocean --rm --detach \\\n  --network jenkins --env DOCKER_HOST=tcp://docker:2376 \\\n  --env DOCKER_CERT_PATH=/certs/client --env DOCKER_TLS_VERIFY=1 \\\n  --publish 8080:8080 --publish 50000:50000 \\\n  --volume jenkins-data:/var/jenkins_home \\\n  --volume jenkins-docker-certs:/certs/client:ro \\\n  myjenkins-blueocean:2.332.2-1\n\n等待一会，在浏览器中访问 http://localhost:8080，完成后续配置。\n\n注意：步骤4构建失败，可能是由于 Docker 权限问题，解决方案可参考这里。\n配置\n\n\n解锁 Jenkins：浏览器中提示输入管理员密码。War 在启动的控制台中会打印密码，或者页面提示的文件中。Docker 方式使用命令，查看容器日志信息即可看到 docker logs jenkins-blueocean。\n\n\n插件下载镜像设置：为了部署和运行项目，需要安装一些插件。首先需要给插件站点设置一个镜像，不然访问速度感人。配置路径 “Manager Jenkins → Manager Plugins → Advanced”，在底部的 Update Site 中把地址进行替换。这里提供一个国内可访问的镜像地址：updates.jenkins-zh.cn/update-center.json。\n\n\n设置好插件镜像源之后，去搜索对应的插件，下载安装即可。\n\n\n下载并安装插件：由于项目是用 Git 来管理的，并且使用的是 Maven，因此需要下载这两个插件。\n\n\n使用\n创建 Job 之前，需要先了解一个 Job 任务涉及到哪些流程。Jenkins 给我们提供了以下几个模块：\n\n\nGeneral Job 描述，可选。\n\n\nSource Code Management 源代码管理，有多个版本工具选择：Git、Svn 等。\n\n\nBuild Triggers 构建触发器，选择构建代码的时机\n\nTrigger builds remotely，手动去触发。\nBuild after other project are built，在其他项目构建完成后触发。\nBuild periodically，周期的进行构建\nGitHub Hooks，当有代码更新到 GitHub，GitHub 会触发一个 Hooks，并通知 Jenkins 服务开始构建，这个需要在 GitHub 中配置推送地址信息。\nPoll SCM 定时任务轮询，填写 Cron 表达式指定轮询的时机。例如：每 10 分钟去检查 GitHub 仓库是否有代码更新。\n\n\n\nBuild Environment构建环境，配置项目构建的环境，可以在构建的时候传递环境变量信息。\n\n\nBuild 可以选择构建所需步骤。\n\n\nPost-build Actions可以指定项目完成构建之后的行为。\n\n\n手动创建 Job\n在 Jenkins 中添加两个任务，一个用于拉取代码运行测试、打包任务，另一个可以手动选择版本的部署任务。\n创建测试打包任务\n\n填写创建的 Job 信息\n\n\n\n选择 Git 作为代码管理工具，配置对应的仓库地址。如果是私密仓库，需要填写对应的账号密码。这里使用了 ssh 方式，并提前配置好了私钥信息。\n\n\n\n选择一个构建方式，这里我们选择 SCM，填写一个每 10 分钟轮询一次的 corn 表达式。\n\n\n\n构建的时候选择 Execute shell 并在文本框中填写要执行的脚本信息，这里我们填写 mvn clean package，该命令会执行清理、测试、打包操作，在 target 目录下生成 jar 包。\n\n\n\n保存任务，回到页面。等待 10 分钟或者手动点击立即构建，即可开始构建。 控制台最终打印了文件夹下所有项目版本信息。\n\n\n创建部署任务\n\n创建 deploy 任务，在页面中填写描述，并勾选 This project is parameterized，选择 String 参数，这里定义一个变量 version。\n\n\n\n由于部署任务和打包任务是分开，此处无需在使用 Git 去拉取代码，也无需定义构建触发器，直接手动构建即可。\n\n\n\nbuild 环节还是去执行一个 shell，这里我们配置一个 java 程序启动命令 java -Dserver.port=5000 -jar  /c/Users/Administrator/Desktop/jenkins/${version}.jar指定 5000 端口，并且根据输入的版本号，去执行对应的 jar 包。\n\n\n\n根据上个任务构建的输出，我们执行部署任务的构建。Jenkins 会弹出提示，此时输入对应的项目版本号，点击开始构建，等待构建完成项目就启动成功了。\n\n\n使用 Jenkinsfile 创建 Job\n图形化页面创建一个 Job 很方便，但是当 Jenkins 需要为多个项目创建 Job 时，一个一个手动创建就会很繁琐，并且 Job 信息也没办法进行版本管理。\nJenkinsfile 就是来解决这个问题的，他将 Job 的配置信息用脚本语言来表示，这样只需要维护这个脚本即可。Jenkinsfile 就像是一份说明书，指导 Jenkins 的工作，让他自动帮我们完成配置。编写 Jenkinsfile 的脚本语言是 Groovy，推荐学习。\n\n整个流程如图：\n\n创建流程：\n\n\n为项目编写 Dockerfile。\n\n\n创建 Jenkinsfile。\n\n\n使用 pipleline 语法编写脚本：使用 Dockerfile 文件 build 一个镜像，并上传到 Docker 私服。\n\n\n使用一个新的 Job，用来获取 Docker 私服所有项目版本信息，支持选择对应版本部署。\n\n\n为项目编写 Dockerfile\nFROM java:openjdk-8u111-alpine\n \nRUN mkdir /app\n \nWORKDIR /app\n \nCOPY target/oh-my-jenkins-0.0.1-SNAPSHOT.jar /app\n \nEXPOSE 8080\n \nCMD [ &quot;java&quot;, &quot;-jar&quot;, &quot;oh-my-jenkins-0.0.1-SNAPSHOT.jar&quot; ]\n在 master 分支创建 Jenkinsfile 并编写对应的脚本\npipeline {\n     agent any\n     triggers {\n          pollSCM(&#039;* * * * *&#039;)\n     }\n     stages {\n        stage(&#039;Test&#039;) {\n            agent { docker {\n                image &quot;circleci/openjdk:8u212-jdk-stretch&quot;\n                args &#039;-v /usr/local/docker-cache:/root/.m2&#039;\n                            }\n                 }\n            steps {\n                sh &#039;mvn clean package&#039;\n                stash includes: &#039;**/target/*.jar&#039;, name: &#039;app&#039;\n            }\n        }\n \n        stage(&#039;Docker Build&#039;) {\n           steps {\n               echo &#039;Starting to build docker image&#039;\n \n                unstash &#039;app&#039;\n                script {\n                    def customImage = docker.build(&quot;172.29.145.109:5000/on-my-jenkins:${new Date().format(&#039;yyyy-MM-dd-HH-mm-ss&#039;)}&quot;)\n                    customImage.push()\n                }\n           }\n        }\n     }\n}\n该脚本定义了轮询任务，在 docker 中使用 java 环境运行 mvn clean package打包，并把它暂存。之后使用一个 docker build 构建镜像并推送到 docker 私服。由于私服地址和 Jenkins 都在同一个服务器，因此直接使用内网 ip。\n在 deploy 分支创建 Jenkinsfile  并编写部署脚本\ndef responseJson = new URL(&quot;http://172.29.145.109:5000/v2/oh-my-jenkins/tags/list&quot;)\n        .getText(requestProperties: [&#039;Content-Type&#039;: &quot;application/json&quot;]);\n \nprintln(responseJson)\n \nMap response = new groovy.json.JsonSlurperClassic().parseText(responseJson) as Map;\n \ndef versionsStr = response.tags.join(&#039;\\n&#039;);\n \npipeline {\n     agent any\n \n     stages {\n        stage(&#039;Test&#039;) {\n            input {\n                message &quot;Choose a version&quot;\n                ok &quot;Deploy&quot;\n                parameters {\n                    choice(choices: versionsStr, description: &#039;version&#039;, name: &#039;version&#039;)\n                }\n            }\n            steps {\n                sh &quot;ssh root@172.29.145.109 &#039;docker rm -f oh-my-jenkins&#039; || true&quot;\n                sh &quot;ssh root@172.29.145.109 &#039;docker run --name oh-my-jenkins -p 8081:8080 -d 172.29.145.109:5000/oh-my-jenkins:${version}&#039;&quot;\n            }\n        }\n     }\n}\n该脚本获取 Docker 私服的oh-my-jenkins镜像，部署我们选择的版本。\n在 Jenkins 创建多分支流水线任务\n\n然后只需要配置仓库地址就好了，由于 GitHub 抽风，所以使用 Gitee 仓库地址。\n\n创建完流水线任务，他会自动扫描仓库上的所有分支，并读取 Jenkinsfile 文件，执行命令。\n选择版本部署\n\n当流水线分支创建完成之后，deploy 分支会等待我们选择版本，选择需要部署的版本，deploy 即可完成部署。"},"Spaces/Resources/博客/技术类/Linux-服务化的几种方式":{"title":"Linux 服务化的几种方式","links":[],"tags":["Linux"],"content":"nohup\n使用 nohub 命令，例如运行一个 java 项目\nnohub java -jar xxx.jar\ntmux\ntmux 全程 terminal multiplexer 意思是终端多路复用器。它可以启动一个新的终端进程，可以通过一些命令在当前终端和新终端之间来回切换。\n因此，可以在新的终端进程中运行程序，然后使用命令切回到现有的终端即可。\ntmux 一些常用的命令：\n创建一个新的进程\ntmux\n回到当前终端\n使用 control + b，再使用 d 即可\n回到新的进程中\ntmux attach\nsystemd\nnohub 和 tmux 的方法，都无法应对程序崩溃的情况，程序崩溃后需要人为重启。将程序执行改为系统服务，即可解决该问题。\n此处使用 Unbuntu 的创建服务的方式举例：\n创建一个配置文件 my-program.service\n[Unit]\nDescription= a service for java # 服务的描述\nAfter=netwprk.target\nStartLimitIntervalSec=0\n[Service]\nType=simple\nRestart=always # 自动重启\nRestartSec=1\nUser=root\nExecStart=java -jar my-program.jar # 服务启动命令\n \n[Install]\nWantedBy=multi-user.target\n创建完成后，启动服务即可。\nsystemctl start my-program\n服务配置详细信息，可以参考这里\nDocker\n使用 docker 启动程序，在启动参数上加 -d 参数即可。\ndocker run -d my-program-image"},"Spaces/Resources/博客/技术类/Maven-代码插件":{"title":"Maven 代码插件","links":[],"tags":["Maven"],"content":"代码规范检查工具 CheckStyle\n功能\ncheckstyle 插件能帮助我们规范代码行为，尽可能地检查代码的坏味道。\n配置\ncheckStyle 插件配置很简单，主要是分两步：引入插件，编写代码规则 xml。\n引入插件的配置如下：\n\t\t&lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.1.2&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;configLocation&gt;${basedir}/src/main/resources/checkstyle.xml&lt;/configLocation&gt;\n                &lt;includeTestSourceDirectory&gt;false&lt;/includeTestSourceDirectory&gt;\n                &lt;enableRulesSummary&gt;false&lt;/enableRulesSummary&gt;\n            &lt;/configuration&gt;\n            &lt;executions&gt;\n                &lt;execution&gt;\n                    &lt;id&gt;compile&lt;/id&gt;\n                    &lt;phase&gt;compile&lt;/phase&gt;\n                    &lt;goals&gt;\n                        &lt;goal&gt;check&lt;/goal&gt;\n                    &lt;/goals&gt;\n                &lt;/execution&gt;\n            &lt;/executions&gt;\n        &lt;/plugin&gt;\n引入插件的坐标，在   中配置插件的一些属性， configLocation 配置了要使用的规则文件位置，如若不配置则默认使用 sun 公司提供的代码规范配置。includeTestSourceDirectory 是否检查测试代码规范 ，enableRulesSummary 是否开启规则摘要等等，详细的配置信息请点击\n在标签中将 checkstyle 插件的 check 目标绑定到 default 生命周期的 compile 阶段。当使用 mvn compile 编译代码时，checkStyle 便会执行 check 目标，或者手动执行 mvn checkstyle:check\n编写代码规则 xml：\n代码规则已经有现成的模板，因此可以直接使用现成的模板，或者根据已有的模板进行修改。比如 sun 公司的代码规范，以及 google 的代码规范。以下是个人开发中经常使用的代码规则，可根据需要修改。\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE module PUBLIC\n        &quot;-//Puppy Crawl//DTD Check Configuration 1.1//EN&quot;\n        &quot;www.puppycrawl.com/dtds/configuration_1_1.dtd&quot;&gt;\n&lt;module name=&quot;Checker&quot;&gt;\n    &lt;property name=&quot;localeLanguage&quot; value=&quot;en&quot;/&gt;\n    &lt;module name=&quot;NewlineAtEndOfFile&quot;&gt;\n        &lt;property name=&quot;lineSeparator&quot; value=&quot;lf&quot;/&gt;\n    &lt;/module&gt;\n    &lt;module name=&quot;FileTabCharacter&quot;&gt;\n        &lt;property name=&quot;fileExtensions&quot; value=&quot;java,xml&quot;/&gt;\n    &lt;/module&gt;\n    &lt;module name=&quot;RegexpSingleline&quot;&gt;\n        &lt;!-- \\s matches whitespace character, $ matches end of line. --&gt;\n        &lt;property name=&quot;format&quot; value=&quot;\\s+$&quot;/&gt;\n        &lt;property name=&quot;message&quot; value=&quot;Line has trailing spaces.&quot;/&gt;\n    &lt;/module&gt;\n    &lt;module name=&quot;TreeWalker&quot;&gt;\n        &lt;module name=&quot;IllegalImport&quot;/&gt;\n        &lt;module name=&quot;RedundantImport&quot;/&gt;\n        &lt;module name=&quot;UnusedImports&quot;/&gt;\n        &lt;module name=&quot;NeedBraces&quot;/&gt;\n     \t&lt;module name=&quot;JavadocMethod&quot;&gt;\n            &lt;property name=&quot;scope&quot; value=&quot;public&quot;/&gt;\n      \t&lt;/module&gt;\n        &lt;module name=&quot;ModifierOrder&quot;/&gt;\n        &lt;module name=&quot;RedundantModifier&quot;/&gt;\n        &lt;module name=&quot;UpperEll&quot;/&gt;\n        &lt;module name=&quot;LeftCurly&quot;/&gt;\n        &lt;module name=&quot;NeedBraces&quot;/&gt;\n        &lt;module name=&quot;RightCurly&quot;/&gt;\n        &lt;module name=&quot;GenericWhitespace&quot;/&gt;\n        &lt;module name=&quot;WhitespaceAfter&quot;/&gt;\n        &lt;module name=&quot;NoWhitespaceBefore&quot;/&gt;\n    &lt;/module&gt;\n&lt;/module&gt;\n需要注意的是，规则文件的目录名称需要与插件配置的地址一致，否则插件无法使用自己编写的规则。\n代码缺陷检查工具 SpotBugs\n功能\nSpotBugs 的前身是 FindBugs，从字面意思很好理解就是帮我们的代码找 bug，当然这个 bug 指的是代码层面的，而不是业务上的。特别说明，SpotBugs 检查的是编译后的字节码文件，而非源代码。\n配置\nSpotBugs 的配置也很简单：引入插件依赖，并在插件中做配置即可\n      &lt;!--     SpotBugs 插件      --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;com.github.spotbugs&lt;/groupId&gt;\n                &lt;artifactId&gt;spotbugs-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1.12&lt;/version&gt;\n                &lt;dependencies&gt;\n                    &lt;!-- 此处的依赖用于指定 spotbugs 的版本，不引入该依赖，插件默认会有一个提供一个版本 --&gt;\n                    &lt;dependency&gt;\n                        &lt;groupId&gt;com.github.spotbugs&lt;/groupId&gt;\n                        &lt;artifactId&gt;spotbugs&lt;/artifactId&gt;\n                        &lt;version&gt;4.4.2&lt;/version&gt;\n                    &lt;/dependency&gt;\n                &lt;/dependencies&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;spotbugs&lt;/id&gt;\n                        &lt;phase&gt;verify&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;check&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n由于 SpotBugs 是检查字节码文件，因此需要将 SpotBugs 的目标绑定到 compile 之后的阶段，上述配置将 SpotBugs 绑定到 default 生命周期的 verify 阶段，亦可以直接使用命令 mvn spotbugs:check 执行目标。\n对于一些不需要 SpotBugs 检查的方法或者类需要在 pom 中引入如下依赖：\n \n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.code.findbugs&lt;/groupId&gt;\n    &lt;artifactId&gt;annotations&lt;/artifactId&gt;\n    &lt;version&gt;3.0.1&lt;/version&gt;\n&lt;/dependency&gt;\n \n引入依赖后，在对应的类或者方法上添加 @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;) 其中括号中替换为对应的错误类型，更多关于 SpotBugs 的配置信息请点击\n测试覆盖率报告插件 Jacoco\n功能\n给单元测试生成测试覆盖率报告，覆盖率报告可以详细的查看测试覆盖到的地方。\n配置\n给 Junit 测试生成测试报告配置如下：\n\t\t\t&lt;plugin&gt;\n                &lt;groupId&gt;org.jacoco&lt;/groupId&gt;\n                &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;0.8.7&lt;/version&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;default-prepare-agent&lt;/id&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;prepare-agent&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;default-report&lt;/id&gt;\n                      \t&lt;phase&gt;verify&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;report&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;default-check&lt;/id&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;check&lt;/goal&gt;\n                        &lt;/goals&gt;\n                        &lt;configuration&gt;\n                            &lt;rules&gt;\n                                &lt;rule&gt;\n                                    &lt;element&gt;BUNDLE&lt;/element&gt;\n                                    &lt;limits&gt;\n                                        &lt;limit&gt;\n                                            &lt;counter&gt;COMPLEXITY&lt;/counter&gt;\n                                            &lt;value&gt;COVEREDRATIO&lt;/value&gt;\n                                            &lt;minimum&gt;0.60&lt;/minimum&gt;\n                                        &lt;/limit&gt;\n                                    &lt;/limits&gt;\n                                &lt;/rule&gt;\n                            &lt;/rules&gt;\n                        &lt;/configuration&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n配值 Jacoco 的 report 目标绑定到 verify 阶段，当运行 mvn verify命令时，会生成代码测试覆盖率报告。\nJacoco 排除文件的配置也需要注意：当我们既需要在生成报告中排除，又需要在检查测试覆盖率中排除时，可以在插件依赖下声明如下，configuration 与插件的 executions在同一级。\n&lt;configuration&gt;\n      &lt;excludes&gt;\n           &lt;exclude&gt;com/greek/shop/entity/*&lt;/exclude&gt;\n      &lt;/excludes&gt;\n&lt;/configuration&gt;\n仅需要在某些目标执行是过滤文件，则在对应目标的配置中加入上面的代码。例如要在 report 目标中排除文件，则要在 report 对应的 execution 里面添加上面的配置。\n官方文档中针对单元测试和集成测试有不同的配置方法请点击查看，关于 report 的具体配置，以及相关参数也可点击这里"},"Spaces/Resources/博客/技术类/Maven-依赖与插件解析机制":{"title":"Maven 依赖与插件解析机制","links":[],"tags":["Maven"],"content":"劝退提醒：不了解 maven 坐标机制，没有使用过 maven 插件，不了解 maven 插件命令的，可以关闭文章了。\n我们经常在项目中引入包，使用 &lt;dependency&gt; 标签，然后填写包的坐标信息， Maven 就可以帮我们引入该 jar 包。当本地存在该 jar 包时，就从本地引入该 jar 包，否则就从远程仓库引入。\n这背后的解析机制是什么呢？\n依赖解析机制\n依赖解析的背后机制可以概括如下：\n\n\n依赖范围是 system，maven 就会从本地加载该 jar 包，完成构建。\n\n\n正常解析依赖坐标，先去本地仓库找，找到就完成构建。\n\n\n本地找不到，并且显示的指定了版本信息，就去远程仓库中遍历，找到并下载解析。\n\n\n如果依赖的版本信息并没有指定，而是使用 RELEASE或者 LATEST，他会找到远程仓库的元数据和本地的元数据进行合并，然后计算出真正的版本号。元数据指的就是仓库中 groupId/artifactId/maven-metadata.xml文件，例如我们打开 guava 包的元数据。元数据位置就在 com.google.guava/guava 包下，打开可以看到如下信息：\n\n\n&lt;metadata modelVersion=&quot;1.1.0&quot;&gt;\n&lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n&lt;artifactId&gt;guava&lt;/artifactId&gt;\n&lt;versioning&gt;\n  &lt;latest&gt;30.1.1-jre&lt;/latest&gt;\n\t&lt;release&gt;30.1.1-jre&lt;/release&gt;\n  &lt;versions&gt;\n  &lt;version&gt;r03&lt;/version&gt;\n\t&lt;version&gt;r05&lt;/version&gt;\n\t&lt;version&gt;r06&lt;/version&gt;\n\t&lt;version&gt;r07&lt;/version&gt;\n\t&lt;version&gt;r08&lt;/version&gt;\n\t&lt;version&gt;r09&lt;/version&gt;\n\t...\n  &lt;version&gt;30.1-android&lt;/version&gt;\n\t&lt;version&gt;30.1-jre&lt;/version&gt;\n\t&lt;version&gt;30.1.1-android&lt;/version&gt;\n\t&lt;version&gt;30.1.1-jre&lt;/version&gt;\n  &lt;/versions&gt;\n  &lt;lastUpdated&gt;20210319161151&lt;/lastUpdated&gt;\n&lt;/versioning&gt;\n&lt;/metadata\n上面的信息展示了 latest，release 对应的版本号，以及 guava 包的历代版本号，以及最近一次更新时间。例如我们引入 guava，并使用 latest 版本，maven 就会合并元数据，然后计算出 latest 对应的版本号，然后从本地仓库找到改版本的 guava，没有则去远程仓库下载。\n\n\n依赖的版本是 SNAPSHOT，则同样获取远程元数据与本地合并，计算版本信息，获取对应版本的包。\n\n\n如果依赖版本为时间戳的快照版本，就会先转换成非时间戳的快照版本，然后去解析下载。\n\n\nmaven 3 中如果不指定 version，则默认解析使用 RELEASE 版本。\n\n\n插件解析机制\n我们常用的 maven 插件命令都是 mvn dependency:tree mvn flyway:migrate，诸如此类的，他们的格式都是 mvn 插件前缀:目标。\n为了方便用户使用和配置插件，maven 不需要用户提供完整的坐标信息，就能解析得到正确的插件。那么问题来了，maven 是怎么确定插件的坐标和版本的呢？例如 mvn dependency:tree 他执行了什么插件，插件坐标版本信息是什么？\n插件的解析机制和依赖解析机制基本一致，不同的是远程仓库不一样。配置插件的远程仓库地址需要使用 &lt;pluginRepository&gt; 标签配置，如下：\n&lt;pluginRepositories&gt;\n  &lt;pluginRepository&gt;\n    &lt;id&gt;&lt;/id&gt;\n    &lt;name&gt;&lt;/name&gt;\n    &lt;url&gt;&lt;/url&gt;\n  &lt;/pluginRepository&gt;\n&lt;/pluginRepositories&gt;\n除了 &lt;pluginRepositories&gt;和 &lt;pluginRepository&gt;不同，其他的与依赖的仓库配置信息一致。\n默认的 groupId\n在 pom 文件在红配置插件信息的时候，如果插件是 maven 官方的插件（groupId 为 org.apache.maven.plugins），就可以省略 groupId 的配置。如下是官方的 clean 插件配置，没有指定 groupId，但是解析坐标的时候会带上。\n       &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1.0&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n在插件配置中，不推荐省略 groupId 的写法，但这与我们使用 maven 插件命令有关。\n省略版本信息\nmaven 的核心插件都在超级 pom 中显示的声明了具体的版本信息，因此当这些插件未指定版本信息的时候，就会使用超级 pom 中指定的插件版本。\n如果是非核心插件，且未指定版本信息。在 maven2 中默认解析至 latest，maven3 默认解析至 release，具体的解析过程与依赖解析一致，都是根据合并计算元数据，得到具体的版本信息。\n插件前缀解析\n我们使用命令 mvn dependency:tree 插件前缀是 dependency，我们是如何根据这个前缀信息得到该插件的完整坐标呢？\n这就需要结合上面的知识了，首先存在一个保存 groupId 和 artifactId 对应关系的文件 maven-metadata.xml，该文件存在 groupId / maven-metadata.xml。由于上面的 dependency 是官方插件，因此 groupId 为 org.apache.maven.plugins ，我们去远程仓库找到该文件，如下图。\n\n我们可以找到插件前缀 dependency 对应的 articfactId 是 maven-dependency-plugin，因此插件的完整坐标可以确定了。\n获取 groupId\n这里还有个问题，因为我们是提前知道 dependency 是官方的插件，可以推出他的 groupId ，但是 maven 是怎么知道它的 groupId 呢？\nmaven 的主要插件都在 [repo1.maven.org/maven2/org/apache/maven/plugins](repo1.maven.org/maven2/org/apache/maven/plugins)和[repository.codehaus.org/org/code-haus/mojo](repository.codehaus.org/org/code-haus/mojo)下，他们对应的 groupId 分别是 org.apache.maven.plugins 和 org.codehaus.mojo。maven 解析插件的时候就会默认使用这两个 groupId 去匹配，检查 org/apache/maven/plugins/maven-metadata.xml，org/codehaus.momjo/maven-metadata.xml 文件，判断是否有匹配的插件前缀，如果有则获取对应的坐标信息，完成解析。\n倘若想使用的插件是第三方的，就可以通过配置 setting.xml 文件，让 maven 也检查其他 groupId 上的仓库 metadata.xml 文件。\n&lt;setting&gt;\n  &lt;pluginGroups&gt;\n    &lt;pluginGroup&gt;第三方仓库 groupId&lt;/pluginGroup&gt;  \n  &lt;/pluginGroups&gt;\n&lt;/setting&gt;\n示例\n解析 dependency:tree 命令\n\n\n先使用默认的和配置的第三方的  groupId 去找到对应的 maven-metadata.xml文件，然后检查是否包含 dependency 前缀信息。\n\n\n包含前缀信息，获取对应 articfactId，不包含则使用下一个 groupId 的 maven-metadata.xml 文件。如果所有都获取不到，则报错。\n\n\n获取到 articfactId 之后根据上面 获取版本信息，即可得到完整的坐标，完成解析执行。\n\n"},"Spaces/Resources/博客/技术类/Maven-包冲突解决过程":{"title":"Maven 包冲突解决过程","links":[],"tags":["Maven"],"content":"记录一次 maven 包冲突解决过程，项目地址链接。\n查看错误方法\n首先要将项目克隆到本地，然后运行，找到出错的位置，以及出错的信息。\n \n如图所示，错误的位置在 MainTest.java 文件第六行，错误信息 NoSuchMethod ，表示没有找到这个方法。根据位置提示，一层一层往下找，发现原来是 A.java 这个类中调用的 getJsonpFunction 方法找不到\n\n查看包冲突\n通过使用 maven helper 插件查看包的依赖树。如图所示，spring-web:5.1.8.RELEASE 版本和 spring-web:4.3.6.RELEASE 版本冲突了。图上的 4.3.6 版本为红色，可知，maven 使用的是 5.1.8 版本。我们根据 maven 解决包冲突的就近原则来看，5.1.8 离项目的距离为1，4.3.6 的距离为2，因此保留5.1.8版本，再次证实了这一点。\n\n追根溯源\n既然知道了是 spring-web 这个包的问题。我们就访问 maven 仓库，找到对应的版本，访问他的 github 主页。\n\n找到了 github 仓库，进入报错的那个类，通过切换 tags 来切换不同版本对应的源代码，两者进行比较。\n\n对比发现在5.1.8版本 org.springframework.http.converter.json.MappingJacksonValue 中不存在 getJsonpFunction  这个方法。而 4.3.6 中却有。因此可以断定，我们项目本该使用 4.3.6 版本，而 maven 帮我们剔除了 4.3.6 版本，保留了 5.1.8 版本，导致找不到 getJsonFunction 而报错。\n\n解决冲突\n知道了冲突的原因，我们就只需要把 5.1.8 版本的依赖注释掉就行，这样 maven 就会帮我们加载 4.3.6 版本的包了。\n\n同时也可以将 5.1.8 版本的依赖改成 4.3.6 版本，解决冲突。"},"Spaces/Resources/博客/技术类/Spring-与事务":{"title":"Spring 与事务","links":[],"tags":["Spring","事务"],"content":"简介\n事务是让人生厌的八股，也是面试中的常客。网路上关于 Spring 与事务的问题非常多，然而大部分解答都是在「 背答案」，并没有把它的底层逻辑讲清楚，只要问题一经变通，也就无从下手不知所措。\nSpring 使用魔法般的注解 @Transactional 帮我们解决事务的使用问题，给我们带来便利的同时，也屏蔽了底层的细节。屏蔽了底层的细节，也就导致事务相关的使用都是靠着积累的经验，而无法真正理解它。\n**说明：**本文仅对 Spring 中事务的原理进行说明，MySQL 中的事务实现不在本文阐述。\n事务是什么\n事务这个概念有点抽象，可以把它看做由一堆 SQL 语句组成的操作。\n事务可以保证它里面的 SQL 语句要么全部成功，要么全部失败，不存在第三种中间状态。\n事务还有 ACID 四种特性，陈词滥调这里不想过多阐述，可以自行 Google 了解。\nMySQL 中的事务\n首先要说明的是，「 事务」更像是一种约定，数据库可以选择遵守或不遵守该约定。即便是在支持事务的数据库中，它们实现事务的方式也各不相同，MySQL 提供对事务的支持，接下来看看在 MySQL 中要如何使用事务。\n在使用事务之前，需要了解事务相关的一些概念。\n\n事务（transaction）指一组 SQL 语句，对应的是整个转账流程。\n回滚（rollback）指撤销指定的 SQL 语句\n提交（commit）将未存储的 SQL 语句结果写入到数据库\n保留点（savepoint）指事务处理中设置的临时占位符，用于事务回滚到指定的 SQL 语句。\n\n事务处理\n假设这样一个场景：用户注册一个账号，默认金额是 0 元，之后充值了 100 元，两个操作都在一个事务内。对应的 SQL 语句如下。\n-- MySQL 中标识事务开始\nSTART TRANSACTION;\nINSERT INTO user VALUES(1,&#039;zzh&#039;,0);\nUPDATE zzh SET money = 100 where id = 1;\nCOMMIT;\n上诉操作完成了一个事务的提交，倘若要回滚上诉操作只需要将 COMMIT 替换成 ROLLBACK。\nSTART TRANSACTION;\nINSERT INTO user VALUES(1,&#039;zzh&#039;,0);\nUPDATE zzh SET money = 100 where id = 1;\nROLLBACK;\n不知道你发现了没有，提交和回滚都是针对一组 SQL 进行的。用户注册账号成功，但是充值失败，能否让「 充值失败」不影响到用户注册。\n答案是肯定的，上面提到的 SAVEPOINT 就是解决该问题的。\nSAVEPOINT 就像游戏存档一样，可以在事务的执行过程中建立多个存档，遇到异常可以随时返回到指定的存档。如下面的语句，「 注册」会成功，而「充值」失败。\nSTART TRANSACTION;\nINSERT INTO user VALUES(1,&#039;zzh&#039;,0);\n \n-- 创建名为 `register_user` 的保留点\nSAVEPOINT register_user;\nUPDATE zzh SET money = 100 where id = 1;\n \n-- 回滚到 `register_user` 保留点\nROLLBACK TO register_user;\nCOMMIT;\n传统的 JDBC 管理事务\n提交与回滚操作\n看下这段代码，你是否熟悉。\nimport java.sql.Connection;\n \nConnection connection = dataSource.getConnection(); // (1)\n \ntry (connection) {\n    connection.setAutoCommit(false); // (2)\n    // 执行一些 SQL 代码\n    connection.commit(); // (3)\n \n} catch (SQLException e) {\n    connection.rollback(); // (4)\n}\n\n获取数据库连接，获取的方式有多种，现在大多数都是维护一个数据库连接池，然后从连接池分配一个连接。\n把获取到的数据库连接，关闭自动提交。因为事务要交由代码管理，而不是让数据库默认提交。\n当执行完 SQL 代码之后，开始提交。\n数据库进行 COMMIT 提交出现异常，代码中进行捕获，并执行回滚操作。\n\n设置隔离级别与保留点（SAVEPOINT）\n在  jdbc 中设置数据库隔离级别和 SAVEPOINT 也是非常简单。\n \nconnection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); // (1)\n \nSavepoint savePoint = connection.setSavepoint(); // (2)\n \nconnection.rollback(savePoint);  // (3)\n\nsetTransactionIsolation api 就可以设置数据库的隔离级别\nsetSavepoint 创建一个 SAVEPOINT\nrollback 到上一个 SAVEPOINT\n\n可以看到 jdbc 中对数据库事务的操作都是非常简单的，Spring 与 jdbc 实现事务的操作并无太大差别，只是他把这些封装的太好，会让你觉得是魔法，难以理解。\nSpring 的事务魔法\nTransactional 注解\n使用 JDBC 开启事务，需要写大量的 try...catch 。通常 try 代码块执行 SQL 操作，catch 中捕获异常进行回滚。\n来看下 Spring 中为一个方法添加事务有多简单\npublic class UserService{\n    \n    @Transactional\n    public void registerUser(){\n        userDao.save(user);\n    }\n    \n}\n加上 @Transactional 注解等价代码如下：\npublic class UserService {\n \n    public void registerUser(User user) {\n        Connection connection = dataSource.getConnection();\n        try (connection) {\n            connection.setAutoCommit(false);\n \n            userDao.save(user);\n \n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n        }\n    }\n}\n这个操作，相比上面的 JDBC 操作，简便不少。操控事务的样板代码，不用在每个方法中写了，一个注解 Spring 统统搞定。\n因此，Spring 的事务魔法秘密就揭开了。对加了 @Transactional的方法或者类，使用 AOP 的方式，帮你生成数据库的链接，事务开启、提交、回滚代码，仅此而已。\nAOP\n在深入 @Transcational 注解之前，还是要先简单介绍下 AOP 在事务上的实现，这对你理解后面的问题，大有裨益。\n首先要清楚 AOP 在实现事务时，并不会改变原来类的行为，它只是生成了一个代理类。生成代理类的方式有 CGLIB、JDK 动态代理，两种代理方式各不相同，但这里不对代理方式阐述。\n通过一个简单的 Demo 看下这个流程：\n在 UserService 的 registerUser 方法开启事务。\n@Service\npublic class UserService{\n    @Transactional\n    public void registerUser(){\n        // 注册用户代码实现\n    }\n}\nSpring 使用 AOP 为 UserService 生成代理类 UserServiceProxy。\npublic class UserServiceProxy{\n    public void registerUser(){\n      \tConnection connection = dataSource.getConnection();\n        try (connection) {\n            connection.setAutoCommit(false);\n \n            // 调用 UserService 的 registerUser 方法\n            invoke();\n           \n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n        }\n    }\n}\n在 UserController 中注入 UserService 对象。\n@RestController\npublic class UserController{\n    @Autowired\n    private UserService userService;\n    \n    @PostMapping(&quot;/register&quot;)\n    public void addUser(){\n\t\tuserService.registerUser();\n    }\n}\n/register 请求的流程如下：\n\n可以看到，Controller  实际上是调用 UserServiceProxy 的 registerUser 方法，然后在代理方法中操控事务，并调用真正的 UserService 的 registerUser。\n或许你还有个疑问：注入的是 UserService ，为什么调用的却是它的代理类？\n这就涉及 Spring  的依赖注入原理，详细可以自行搜索。实际上在 UserController 中注入的是 UserServiceProxy ，而非看到的 UserService。\n一些疑难杂症\n列举一些关于 Spring 事务的疑难杂症，也是面试的常考题。\n为什么 private 方法加 @Transactional 注解不生效?\n这个问题其实是和 AOP 相关的，因为 AOP 无法对 private 方法生成代理。无法代理也就意味着对 priavte 方法的调用，都是直接调用被代理的类。\n为什么 final 方法加 @Transactional 注解不生效?\n原理同上，还是 AOP 无法代理被 final 关键字修饰的方法和类\n为什么类方法相互调用事务不生效？\n事务方法 a调用同类的事务方法 b ，在外部调用 a 方法，b 方法的事务不生效。\npublic class UserService{\n    \n    @Transactional\n    public void a(){\n        // do something\n        b();\n    }\n    \n    @Transactional\n    public void b(){\n        // do something\n    }\n}\n \n \npublic class test(){\n    userService.a();\n}\n其实这个只需要分析下调用过程就清楚了：\n\n先调用代理类中的 a 方法，然后代理类中调用真正的 a 方法。\nUserService 的 a 方法执行过程中，发现要调用 b 方法，因此调用了自己的 b 方法。\n\n可以看到，a 调用 b 的时候，并没有先经过代理类，而是直接在 UserService 中执行了，所以 b 的事务不会生效。\n\n为什么注入自己就能解决相互调用问题？\n同样是上面的代码，只需要在 UserService 中注入自己，b 的事务就生效了。\npublic class UserService{\n    \n    @Autowird\n    UserService userService;\n    \n    @Transactional\n    public void a(){\n        // do something\n        userService.b();\n    }\n    \n    @Transactional\n    public void b(){\n        // do something\n    }\n}\n \n \npublic class test(){\n    userService.a();\n}\n还记得上面说的依赖注入吗，这里注入自己，实际上注入的是 UserService 的代理类。因此在执行 userService.b() 这段代码时，会调用代理类的 b 方法，所以 b 的事务生效。\n"},"Spaces/Resources/博客/技术类/Stream":{"title":"Stream","links":[],"tags":["Java","Stream"],"content":"什么是 Stream 流\n流就相当于工厂的流水线工作，传送带上是一件件产品，而传送带周围是一些工人。有的负责把挑出次品，把它放到其他另一条流水线中重新加工，有的负责根据产品颜色进行收集，等等。如下图所示。\n\n三个员工对传送带上的产品进行操作，老王负责收集把黄色产品挑出，老周负责把产品按先后排序，而老赵负责把残次品挑拣出来，拆开零件放到新的床送带中，继续加工。传送带的终点就是篮子，产品都流向篮子里面。\n流的操作就是如此。在没有流之前，我们要自己从一堆产品中找到残次品很难。但是我们有了流之后，我们有了流水线，有了工人，我们就可以让工人帮我们收集，让他们来处理，我们只是充当老板的角色，下达命令即可。在 Java 的流 (Stream) 中，我们只需要使用一些命令，剩下的交给程序本身去执行。这样做既减少了代码量，又能高效完成我们的需求，真是两全其美。\n在上面的过程中，我们把老王和老周，以及老赵操作叫做中间操作。因为他们并没有把产品收集起来，他们只是把其他不合格的产品过滤挑出，产品最终都是到篮子里面。但是你装产品不一定是用篮子，你也可以使用箱子，等其他容器。我们把使用这些容器装产品的操作称作终结操作。在 java 中，**中间操作就是返回为 Stream 的操作，终结操作就是返回非Stream 的操作。**下面会详细讲解。\nStream API\n创建 Stream\n\nCollection.stream()\nStream.of()\nString.chars()\nIntStream.range() 等\n\nStream 中间操作\n\nfilter 按照输入的条件，过滤流中的元素\nmap\nsorted 对流中的元素排序\n\nStream 终结操作\n\nforEach 遍历流中的元素\ncount / max / min 统计元素个数 、最大元素、最小元素\nfindFirst / findAny 找到第一个元素、随机找一个元素\nanyMatch / noneMatch 是否有匹配的元素、没有匹配的元素\ncollect 等\n\n从方法名中我们就能了解它的用处，更为详细的 API 操作可以查看 Stream 源代码。\nCollector 操作\nCollector 操作是 Stream 中最强大的操作，他就是我们上面例子中提到的「篮子」「箱子」等。它具有以下 API\n\ntoSet / toList / toCollection\njoining()\ntoMap()\ngroupingBy()\n\n通过这些 API 操作，使得我们能将流中的元素收集起来\n下面通过一些实际案例，加深对 Stream 的理解。\n案例1\npublic class User {\n        private String name;\n        private int age;\n \n        User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n \n        public String getName() {\n            return name;\n        }\n \n        public void setName(String name) {\n            this.name = name;\n        }\n \n        public int getAge() {\n            return age;\n        }\n \n        public void setAge(int age) {\n            this.age = age;\n        }\n}\n现在有个需求筛选出年龄大于等于60的用户，然后将他们按照年龄从大到小排序，将他们的名字放在一个LinkedList中返回。我们可以使用 Stream 写出如下代码\n public static LinkedList&lt;String&gt; collectNames(List&lt;User&gt; users) {\n        return users.stream()\n                .filter(user -&gt; user.age &gt;= 60)\n                .sorted(comparing(User::getAge).reversed())\n                .map(user -&gt; user.name)\n                .collect(toCollection(LinkedList::new));\n    }\n解析：要使用 Stream 首先就需要创建它users.stream()，根据要求筛选出年龄大于 60 的用户 filter(user -&gt; user.age &gt;= 60)，然后使用 sorted 对筛选后的用户按照年龄排序。由于我们要返回的是一个字符串列表LinkedList&lt;String&gt;，而我们 Stream 中的元素都是对象类型，因此我们使用 map(user -&gt; user.name)，把User 映射成 String 类型，这样 Stream 中的元素都是用户的名字了。最后，使用 collect 操作将用户的名字收集成一个 Linked ，这样就解决了我们的需求。\n通俗解释：我们作为老板，我们要创建一条流水线，然后安排工人在流水线旁边进行操作。安排员工老赵把用了60年以上的产品，筛选出来。筛选完后，安排老周按使用时长进行从大到小排序。排序之后，安排老王把可用的零件拆下来，最后用一个篮子收集这些可用的零件。\n案例2\n统计一个给定的字符串中，大写英文字母（A,B,C,…,Z）出现的次数。例如，给定字符串”AaBbCc1234ABC”，返回6，因为该字符串中出现了6次大写英文字母 ABCABC\n    public static int countUpperCaseLetters(String str) {\n        return (int) str.chars()\n                .filter(Character::isUpperCase)\n                .count();\n    }\n解析：String 类型创建流 str.chars()，然后使用 filter 进行过滤操作，过滤出大写字母 filter(Character::isUpperCase)，接着对过滤出的字母进行统计，完成需求。\n更多关于 Stream 操作 demo点击这里\n并发流\n可以通过并发提高互相独立操作的性能。\n互相独立操作指的就是，操作相互之间不影响。例：1个人割麦子需要10天，那10个人割相同面积的麦子就只需要1天。\n非互相独立操作就像女人生孩子，1个女人十10个月生1个孩子，但是10个女人并不是一个月就能把孩子生出来。\n在正确使用的前提下，可以获得近似线性的性能提升。要使用并发流我们可以使用 parallelStream()创建并发流。或者在原有流的基础上，使用 parallel() 方法将流转化为并发流。\n使用一个简单的案例来使用并发流，统计 1 到 100万之间的质数个数 。原始的 Stream 写法如下\nIntStream.range(1,100_0000).filter(是否为质数).count()\n并发流写法\nIntStream.range(1,100_0000).parallel().filter(isPrime).count();\n因为统计个数属于互相独立操作，就像两个人数羊群有多少只绵羊一样，两人分别数自己区域的羊，然后再加起来汇总。\n对于并发流来说，使⽤要⼩⼼，性能要测试，如果你不知道⾃⼰在做什 么，就忘了它吧。对于详细的操作可以参考《Effective Java 第三版》42-48节。"},"Spaces/Resources/博客/技术类/String":{"title":"String","links":[],"tags":["String","Java"],"content":"首先我们要有一个概念，互联网基本上就只干一件事「处理字符串」。我们看的纷繁复杂的网页，都是通过字节传输的，然后经过一个指定的编码转化成人类能看懂的字符串。因此能处理好字符串是 Web 服务器的基本要求，像 Java，PHP，Python，Ruby等。\nString 的不可变性\n背过一些八股文面试题的人都知道 String 是不可变的，那么问题来了，「不可变的定义是什么？」，「String 是如何保证不可变的呢？」\n不可变性，当创建一个String s = &quot;abcd&quot;对象的时候，JVM 的堆内存就生成了一个 String 对象，并且它的值是 abcd，而 s 变量只是指向这个对象。我们说的不可变性指的就是 JVM 生成的对象值不可变，比如刚才的 abcd，创建出来之后它就一直都是 abcd，无法被改变。\n经常使用字符串的人开始疑惑了，那我 String s = &quot;abcdel&quot;不是也可以吗？String 的值不是改变了吗？\n的确，我们是可以给 s 这个变量重新赋值。但是我们给他赋值实际上是 JVM 新创建了一个值为 abcdel 的 String 变量，然后变量 s 从指向值为 abcd 的对象，改为指向值为 abcdel 的对象。原来值为 123 的对象还是存在 JVM 中，并且值并没有改变，只是暂时没有变量指向这个对象罢了。上面的操作，可以用如图所示。\n\n了解上面的知识后，回到新的问题上来，String 是如何保证不可变性呢？\n打开 String 的源代码，我们可以发现，String 类以及它的字符数组变量都是被 final 关键词修饰的。这就意味着 String 无法被继承，并且 char[] value 的地址指向无法修改，而且 String 所有的公开 API 都没有修改 char[] value 的方法，这就保证了 String 的不可变性。\n\n优点\n线程安全，不可变的对象天生就是线程安全的，可以随心所欲的在线程之间传递。\n**存储安全，**为什么说是存储安全呢？因为遵守了 hashCode 的约定。\n正是因为 Stirng 的不可变性，才能实现存储安全。我们可以想象一下有一个 Map&lt;String,String&gt; map = new HashMap&lt;&gt;();，假如 String 是可变的话，那么就违反了 hashCode 的约定，想了解 hashCode 的相关约定访问这里 。\n如图所示，有三个字符串 “a”，“c”，通过计算分别得到了对应的 hashCode。如果 String 是可变的行不行呢？我们可以通过反证法来证明。现在假如 String 是可变的，那么当字符串从 a 变成了 c（即 String a = &quot;a&quot; 到 a = &quot;c&quot; ），他的 hashCode 要不要改变呢？分两种情况。\n\n如果不改变 hashCode，那就违反了 hashCode  的第二条约定「两个对象 equals 方法为 true，则生成的 hashCode 相等」。显然 a.equals(c) 为true，按照约定 a 和 c 的 hashCode 应该相等。但我们的前提是 a 的 hashCode 不改变，因此 a 和 c 的 hashCode 并不相等，前后矛盾。\n如果改变 hashCode ，那么就违反了 hashCode 的第一条约定「两个对象相等，hashCode 也相等」。例如我们通过如下代码让 a 和 c 为同一个对象，此时的 a == c。\nString a = &quot;123&quot;;\nString c = a;\n如果此时 a 改变了值，hashCode 也会跟着变化。但是 a == c 依然为 true，因为他们所引用的内存地址都是相同的。hashCode 规定对象相等返回相同的 hashCode ，而我们的前提是值改变，hashCode 改变，也是前后矛盾。\n通过反证法，证明了 String 必须是不可变的，才能达到存储安全的目的。\n缺点\n每当想修改字符串的时候，都必须创建新的对象来维持它的不可变性。比如下面这个循环，循环 10 次，就创建了 10 个对象，当循环次数上升到一定程度，就会给内存管理带来巨大的压力。\nString text = &quot;0&quot;;\nfor (int i = 0; i &lt; 10; i++) {\n    text = text + i;\n}\n注意事项\n当我们想创建值相同的两个 String 对象，有以下三种方式\n// 方法一\nString a = &quot;123&quot;;\nString b = &quot;123&quot;;\n \n// 方法二\nString a = new String(&quot;123&quot;);\nString b = new String(&quot;123&quot;);\n \n// 方法三\nString a = &quot;123&quot;;\nString b = a;\n我们分别用 == 和 equals 方法来判断 a，b是否相等，三种方式输出的结果分别会是什么呢？\n方法一，a，b 的值都是 “123”，因此很简单，a.equals(b)肯定为 true，那么 a == b 呢？答案是 true。因为有「字符串常量池」的存在，当 a 创建出来，字符串常量池创建 “123” 这个字符串常量，当 b 赋值的时候，发现字符串常量池中已经有相同的对象，因此直接让 b 指向这个对象，此时 a 和 b 都指向同一个对象。如图\n\n方法二，a 和 b 都是通过 new 方法，各自声明了一个值为 “123” 的对象，因此这是两个不同的对象。所以，a == b 为 false，a.equals(b) 为 true。此时的 a 和 b 是指向不同的对象的，虽然他们的值都是 123。\n\n方法三，a 赋值 b，把 a 的地址指向给 b一份。因此，a，b 两个变量都是引用同一个对象，因此 a==b 为 true，a.equals(b) 也为 true。图中就是 a 指向的内存地址是 0x45，然后通过 String b = a b 得到 a 传来的地址，所以也指向 0x45 这个内存。\n\nStringBuilder 与 StringBuffer\n虽然 String 是不可变的，但是在实际生产中我们还是需要可变字符串，这要怎么解决呢？就拿上面那段循环代码来说，每次都要创建一个新的变量，循环次数多了必然占用过多内存。**StringBuilder **就是个可变字符串，因此我们可以使用 StringBuilder 来改进这段代码，这样就避免了创建多个对象。\nStringBuilder text = new StringBuilder(&quot;0&quot;);\nfor (int i = 0; i &lt; 10; i++) {\n    text = text.append(i);\n}\nStringBuffer 也是可变字符串，与 StringBuilder 的区别是：StringBuilder 线程不安全，但是速度快；StringBuffer 线程安全，速度相对较慢。因此，要根据实际生产环境，选择合适的类，大多数情况优先使用 StringBuilder。\nString，StringBuffer 和 StringBuilder 更多 API，请参考 Java 官方文档。"},"Spaces/Resources/博客/技术类/Web-中的-Session":{"title":"Web 中的 Session 到底是什么?","links":["Spaces/Resources/博客/国外博客翻译/停止使用-JWT-作为-Session"],"tags":["Web"],"content":"\n博客参考：blog.by24.cn/archives/about-session.html#comment-10457\n推荐阅读： Stop using JWT for sessions停止使用 JWT 作为 Session\n\n在 Web 开发中，会使用一些技术来维持用户登录状态。此时，你会立刻想到 Session，但如果要你解释为什么能维持登录状态，你也只能说：大概是 SessionId 之类的，巴拉巴拉。\n是的，之前别人这么问我，我估计也是扯这些东西。你要问为什么是这些东西，那我只能跟你说八股上是这样写的。\n大部分人从八股中了解 Session 知识，但这些还不足以让你对它有清晰的认知。\n不信我问你几个问题，SessionId 是什么？SessionData 是什么？面试官常问的 Session 和 Cookie 的关系？Sever-Side Session 和 Client-Side Session 是什么？Java 常用的 Web 容器 Tomcat 是如何处理 Session 的?\n如果你无法清楚的解释上面的问题，那么这篇文章非常适合你。\n登录状态与 Session\nSession 翻译成「会话」，他表示的是一次「谈话」，谈话期间双方可以任意通信。\n在 Web 开发领域，Session 做的就是维持用户登录状态。那么它是怎么做的呢？\n回想一下登录的场景，输入账号密码登录后，Cookie 中会多一个 SessionId 信息，该 SessionId 是你的身份证，后续的请求 Cookie 都会包含该 SessionId，这样服务就知道你是「你」。\n那么问题来了，服务端是如何根据你的 SessionId 来判断你是「你」的？\n当然是登录的时候，把你的信息给「存」了起来，用 SessionId 把你的信息关联起来。流程如图：\n\n用户渣渣丰登录时，服务查找 “zzf” 用户信息，将用户信息存到 Session存储中心，然后返回 SessionId。渣渣丰后续的请求都不用再登录了，带上 SessionId=10010，服务器去 Session 存储中心查 id 为 10010 的数据，便能直接获取用户信息。若找不到，则表示用户未登录，走登录流程即可。\n返回给客户端的 id 称作 SessionId，SessionId 关联的数据就是 SessionData。Session 这个模糊的概念就可以简单的理解为：SessionId + SessionData。\n两种 Session 存储策略\nServer-Side Session\n上面的登录过程中，SessionData 是存储在服务端的，称作 Server-Side Session,，这也是大多数网站使用的存储策略。他的特点是客户端传输只需要传 SessionId，在没有理解 Session 前，就很容易把 SessionId 当成 Session 本身，而无视了 SessionData 的存在，这正是很多人理解不了 Session 的原因。\n对于还未登录的新用户，去访问系统的其他请求，此时用户并未携带 SessionId。服务器会处理当前请求，新增一条 Session 数据，其中 SessionData 为空，然后返回 SessionId，并提示用户登录。\nClient-Side Session\n与 Server-Side Session 相反，Client-Side Session SessionData 是在客户端（浏览器）存储的。每次向服务器发起请求，都要带上 SessionData 信息。\n因此，这种情况都压根不存在 SessionId 这个概念，很多人也很容易因此搞混，不清楚 Session 究竟存在哪里。\n对于新用户来说，本地没有任何信息，服务器便会初始化一个空的 SessionData 返回。后续的通信中，SessionData 才会被填充有意义的数据。\n这种做法，很明显有个巨大漏洞：用户直接修改本地的 SessionData 数据，冒充管理员怎么办？\n因此，使用 Client-Side Session 需要使用加密或者签名等机制，来保证数据安全，确保 SessionData 数据都是由服务端生成的。\nSession 和 Cookie 关系\n严格来说，Session 和 Cookie 其实没有半毛钱关系，只是 Cookie 常用做 Session 的载体，因此很多人也被弄得迷迷糊糊。\n还记得上面客户端「带」信息（SessionId / SessionData）的过程吗，信息传给服务端需要一个载体，这个载体可以是任何服务器能接收的东西，例如放在 URL 中，我们也完全可以把 Session 信息放到 Header 中，事实上也有很多网站是这么做的，比如一些禁止使用 Cookie 的网站。\n大多数人选择使用 Cookie，自然是有他优势所在。服务端可以设置 Cookie 中的信息，且禁止客户端修改，这样能防止 Cookie 信息被篡改。由于 Cookie 中的信息在通信中，双方都能接收，因此 Cookie 是很适合存 Session 信息。\n总之，Cookie 只是一个用户存储和传输 Session 信息的工具，仅此而已。\nWeb 容器对 Session 的支持\n在 Java 开发中，经常使用到 Tomcat 容器，他提供了对 Session 的支持。 Tomcat 也是属于 Server-Side Session，查看 Cookie 可以发现他使用 JESSIONID 字段存储 SessionId，SessionData 则存储在服务端的内存中。\nTomcat 默认使用 StandardManager 来管理 SessionData，查看源代码可以发现，Tomcat 容器在退出时将 Session 数据持久化到磁盘中，启动时从磁盘中加载 Session。\n对于 Tomcat 来说，他的「Session 存储中心」就是内存，但 Session 也支持其他方式的存储，例如 MySQL、Redis，甚至可以直接存成文本文件。Spring Session 就对 Session 做了全方位的支持，使得 Session 更易用。\nSession 和 JWT\nSession 和 JWT 本身就并非对立面，甚至是「一家」的。JWT 是一种生成 Token 的方式，他通过签名保证 Token 信息不被篡改。\n使用 JWT 的时候，也是登录时候拿到一个 token，后续所有请求都带上 token。你可能会说，哎这不是 Server-Side Session 的方式吗？\n并非如此，服务端并没有保存任何信息。相反用户的信息 (token) 是被客户端持有的，只不过该信息并非明文，需要服务端解密才能查看。\n因此，JWT 实际上就是 Client-Side Session，比直接传输 SessionData，他将传输内容变得更安全精简，只需一串字符即可。服务端只需要按照既定的规则验证签名，解析用户信息即可，也不用额外存储任何信息。\n总而言之，Session 更像是一套用于维持客户端和服务端通信的方案，而 JWT 则是具体实现。"},"Spaces/Resources/博客/技术类/Web-前后端基础架构原理":{"title":"Web 前后端基础架构原理","links":[],"tags":["Web"],"content":"当我们打开浏览器去访问一个网站时，发生了什么？在了解整个过程之前，我们应该先了解一些基本概念\n计算机网络\n首先我们需要明确一点的是，当我们访问一个网站的时候，实际上是在与一个主机进行交互。就像去商店购物一样，只要你不差钱，商店有的，它都能提供给你。\n主机（Host）\n主机简单来说就是一台电脑，只不过它的作用更多，可以响应浏览器发送的请求。我们平时所用的电脑也可以充当一台服务器，只不过需要一些专业的操作，才能把它变成主机。\n那么问题来了，世界上有很多台主机，我们在浏览器输入 www.taobao.com 的时候，它是怎么帮我们找到淘宝的主机的？\nIP 与域名\n每个 IP 对应一个主机，因此只要我们知道 IP 地址就可以正确地找到对应的主机了。说到这里可能还有个疑问，我们明明输入的是一个网址，也没有看见 ip 地址啊，他怎么知道我访问的是那一台主机？这个就要说到 DNS 的功劳了。首先用 ip 去找对应的主机是没问题的，我们输入的网址本质上就对应一个 ip，只是我们没有察觉。DNS 就是把输入的网址，找到对应的 ip ，然后返回给我们。这样我们就本能的以为，只要输入网址就能找到对应的网站了，这是 DNS 给我们的错觉。\nDNS 是个网络上的服务，他包含了域名和 ip 地址的映射关系。windows 本机上有个 hosts 文件，可以自己添加和修改网址和 ip 的对应关系，假如我们把 www.taobao.com 对应的 ip 改成 127.0.0.1，这样在浏览器再次输入www.taobao.com 就找不到原本的淘宝网站了，而是映射到本机。\n端口\n现在请假设一个场景：你有一台电脑，电脑连了一根网线，同时电脑上开了好几个程序，像 QQ、淘宝、微信。你有没想过，一根网线传的数据，他怎么知道哪个是 QQ 要的数据，哪个是淘宝返回的数据呢？\n区分不同应用的数据，我们就用到了端口，不同应用他所对应的端口不一样的。网线中传输的数据，每个数据包都有对应的端口信息，就像一列火车一样，每个人的目的地不一样，有的在广州下车，有的在深圳下车，目的地不一样。数据也是这样，根据端口到达不同的应用中去。\n我们可以经常看到网址前面有 http 或 https，他们都对应着不同的端口号。HTTPS 协议的默认端⼝是443，HTTP协议的默认端口是80。别看我们访问网站的时候没有看到端口号，其实浏览器已经在后面偷偷帮我们补上了。\nTCP 协议\n当我们向远程的服务器发起请求时，TCP 协议就开辟了一条双车道的「高速公路」，不过在这条路上跑的是数据。同时数据也是一个一个的字节，所以也叫字节流，TCP是基于流的协议 。由于是双车道，所以我们可以和服务器同时接受和发送数据，这叫做全双工协议， tcp就是全双工协议。半双工协议就是类似生活中的「对讲机」，只有对方说完，我们才能说话。\nTCP 协议本质上就是规定字节流如何发送和接收\nHTTP 协议\nHttp 是在 TCP 协议之上的一层协议。Http 定义了文本之外的东西如何被传输。我们把发送给服务器的字节流叫做 HTTP Request ，比如我们访问豆瓣首页。我们就会向服务器发送如下字节流。\n\n服务器收到请求之后就会返回一个 HTTP Response 字节流，除了 Headers 之外，还返回了HTTP Response Body（响应体） ，response body 可以是文本，也可以是及二进制数据，包括图片、声音、下载的文件等。\n\n刚才访问的豆瓣网站，就返回了一个 response body，一个 html 文件。我们得浏览器收到这个 html 文件，就会根据他的结构，标签去解析和展示他。我们看到的页面就是浏览器解析之后的样子。\n"},"Spaces/Resources/博客/技术类/interview":{"title":"interview","links":[],"tags":[],"content":"Java 基础\n\n为什么需要装插箱？\n\n为了兼容集合类，由于 List 不放便，因此使用装箱类型表示他的集合 List\n\n\nMethod.invoke(obj,args) / Method.invoke(null,args) static / non-static 字段同理。\n异常中 finally 中的字节码实现，是将 Finally 块中的代码分别复制到 try 和 catch 末尾的。\n\nIO\n\n基本的 IO 模型：阻塞、基于流的。\n基本的 IO 模型：由于是阻塞的，因此被迫有多个线程才能同时处理多个 IO 事件、有多个线程就会产生竞争条件（锁、同步、CAS）\n为什么需要 NIO：线程、上下文切换及其昂贵、IO 多路复用。\n\nJVM\n\n栈内存分配？何时分配？\n\n当代码中创建了「无人引用」的对象时，编译器在编译过程会将代码优化，当方法栈被调用时该对象在栈上进行分配，简轻 GC 的负担。\n\n\n方法区常量池\n\nClass 对象，Java 7 永久代、Java 8 元空间。\n\n\n字节码转换：编译器前端后端\n\njava → 抽象语法树 → class （编译器前端）\n\n\n字节码指令（参照 Java 虚拟机规范）\n\nINVOKESPECIAL：调用特殊的方法：construct、private、super、static 方法\nINVOKEVIRTUAL：方法调用\nPUTFIELD：对象写值，例如：user.name = “xxx”；\n\n\nJava 8 的三层类加载体系：\n\nBootstrap (JVM 核心类) / Ext(扩展类加载器) / App (应用类加载器)\n\n\n常用 JVM 命令与问题排查\n\njps：列举 jvm 进程信息。jstack：线程调用栈信息。jmap：dump 堆内存信息。\n\n\nJava 的引用链\n\n日常使用的都是「强引用」，弱引用、虚引用、影子引用\n\n\n什么是垃圾？\n\n可达性分析，沿着 GC root 能访问到的都是非垃圾、其他都是垃圾\n\n\nGC root 有哪些？\n\n线程、native 方法、栈帧中的局部变量表、Class 引用的 static field\n\n\n什么是 safepoint？\n\n所有线程停止的地方（安全点）\n\n\nGC  过程\n\n等待 safepoint （干活的人都停下来）\n引用分析 (找到垃圾)\nFinalize 队列 （把垃圾放到队列，最终判断是否要回收）\n分代垃圾回收 （回收垃圾）\n\n\n分代垃圾回收\n\n年轻代：Survivor0 / Survivor1 / Eden\nGC 次数多了，提升到老年代。\n永久代 / 元空间\n\n\n不同的垃圾回收算法\n\n老年代/年轻代（串行、并行算法），年轻代：压缩拷贝 老年代：压缩整理\n之前的 GC 需要一个 STW 过程，因此为了降低 STW 的时间使用了 CMS，又由于与之前的串行并行不兼容，因此单独使用了一个 ParNew\n当前算法：G1。 未来算法：Shenandoad / ZGC\n\n\nGC 调优：参考网上文档，看看过程。\nGC 问题：OOM、CPU 100% ( cpu 一值在执行，死循环 )\n\n多线程基础\n\nThread / Runnable / Callable 关系\n\nThread 是真正的线程，对应内核中的线程。Runable 无法返回，且不抛出 checked 异常。Callable 只能交由线程池运行。\n\n\nThread 声明周期：\n\nnew: 线程创建\nrunnable: 分配了任务\nterminated: run 方法执行完。\nblocked: 线程阻塞、等待获取锁\nwaiting:  等待、等待被唤醒\ntime waiting: 超时等待。\n\n\nThreadLocal 实现原理：\n\n具体的数据并非保存在 ThreadLocal，而是保存在线程里面。好处就是：线程结束或者销毁，他所持有的数据也会被销毁。\n\n\nInterruptedException 异常，当 wait、sleep 等方法运行抛出。用于线程任务的中断。\n\n线程同步\n\nsynchronized 锁住的是什么?\n\n锁住的永远都是对象，有普通对象实例，Class 对象，this\n\n\nsynchronized 底层实现\n\n方法：modifiers - sync  有对应的标志位\n代码块：进入的时候有 MONITORENTER / MONITOREXIT 两条字节码指令。\n\n\n锁升级（膨胀）、锁消除、锁粗化、自旋锁（八股先不急）\nvolatile 是什么？\n\n关键字，保证了共享变量对其他线程的可见性，任何一个线程写入之后，其他线程应该都可见。\n实现：JVM 立刻把共享变量刷新到主内存，其他线程都从主内存读即可。\n\n\n指令重排序\n\n编译器发现同一线程的指令执行互不干扰，于是与不同的顺序方式去执行。\n\n\n为什么有同步的时候不需要 volatile ?（有规定）\n\nsynchronized / Lock / AtomicX\n\n\n\nJUC 包（简化多线程开发）\n\n乐观锁和悲观锁\n\n悲观锁，Synchronized，锁住的对象在某一时刻只能被一个线程持有，严格保证了数据安全，但是上下文切换的性能开销相对较大。例子：一群人维圈抢一个凳子，谁快谁先做椅子，抢到椅子的人离开后，剩下那群人继续抢这个椅子，一直持续下去。\n乐观锁，基于 CAS。\n\n\nAQS （抽象的队列同步器）原理：基于队列的同步容器（工具），里面有一个状态，该状态是原子更新的，如果没有办法成功更新该状态，则代表没有线程获取锁，反之有线程获取到锁。\nCAS 实现和底层原理：\n\n原理：内存位置的内容与给定值进行比较，并且仅当它们相同时，才将该内存位置的内容修改为给定的新值。\n例子：内存位置 V，程序执行从 V 中取到的值为 10，需要对值进行自增 1 操作，因此新值为 11 。程序开始执行，之前从 V 中取到的值为 10，获取当前 V 中的值，如果为 10，表示 V 中的值没有被修改，因此把 11 放进 V 中，如果为 11  表示 V 中的值被其他线程篡改了，因此此次更新失败，并把现在 v 中的值 11 返回保存，继续进行重试，直到成功。\n\n\nConcurrentHashMap 原理：\n\nJava 8：哈希表加链表或红黑树，并发扩容，CAS。锁的粒度很细。\n\n\nCountDownLatch：主线程 await 等待，其他线程使用 countDown 数量减1，数量为 0 时，继续执行主线程代码。\n\n主线程：做核酸。其他线程：核酸排队，10人一组。工作人员清点组人数，来一个就减 1 直到减为 0，安排该组进行核酸。\n\n\nCyclicBarrier：await 等待，当所有数量的线程都在 await，开始执行。\n\n每个大白需要负责一条核酸线路，共 5 条。需要所有大白在场，才开始进行核酸检测，先来的大白就等待（await），直到5个人都来齐了，开始进行核酸检测。\n\n\n线程池（一家公司，核心员工数量 预计10人，除核心员工外还可以多招5个外包员工）\n\n参数：核心员工、外包员工人数、超过多长时间没事干就开除员工\n如何工作：\n\n当新项目来的时候，发现核心员工数量不到10人，招一个核心员工来处理这个项目。\n如果项目来的时候，所有核心员都在干活，那我们就给尝试给项目排期（放入队列）\n如果排期失败（核心员工没时间处理新项目），就去招一个外包员工。如果人数已经达到最大上限（核心员工+外包员工 = 15）或者公司倒闭了，就拒绝该新项目（拒绝项目也有策略）。\n\n\n公司接不了新项目了，如何拒绝：\n\n放弃该项目\n谁建的新项目，自己去执行\n直接丢弃排期项目中最晚的项目，然后再把该新项目加入排期，再去试试看能不能完成。\n直接摆烂、不管这个丢弃的项目\n\n\n需要注意的地方\n\n需要明确项目中最大支持的线程\n大概知道线程池的工作状态\n\n\n\n\n\n计算机原理/操作系统\n\n进程之间的通信：管道 / 信号 / 共享内存 / socket (tcp)\n僵尸进程\n\n当父进程创建了子进程，且子进程销毁后，子进程会留下 task 数据结构，exit code 等相关信息保留一段时间，便于父进程调用，此时子进程是僵尸状态。父进程调用后就会删除相关信息，但是当父进程不调用或者自身销毁后，子进程的留下的信息如何处理？\n解决方法：Linux 的 init 进程会定时把自身设置僵尸进程的父亲，然后把他们清理。\n\n\n常见系统问题排查与僵尸进程\n\nTCP / UDP / HTTP / HTTPS / SSH\n\ntcp 可靠传输，自动重传。三次握手、四次挥手\n\n明文、基于流。\n\n\nudp 尽最大可能交付，允许错误发生。场景：视频、语音、直播。\nSSH 连接流程\n\n在服务器上设置自己的公钥信息。\n使用 SSH 命令连接服务器，此时 SSH 会用你的私钥加密一小段数据，传输给服务器。\n服务器使用公钥，进行解密，解密成功建立连接。\n\n\nRSA 非对称加密\n\n公加私解：保密传输\n私加公解：数字签名\n\n\nHTTPS 的 SSL handshake 流程\n\n请求服务器，服务器用私钥加密一段数据（数字签名），把加密后的数据和公钥返回给客户端\n计算机中的 CA 机构对公钥进行检查认证，验证通过往下执行，否则会提示。\n客户端根据用返回的公钥对加密的数据进行解密，解密成功即可确认该服务器是想要请求的服务器。\n客户端用公钥加密一段数据（对称加密算法），返回给服务器。服务器用私钥进行解密，得到对称加密算法，此时客户端与服务器 HTTPS 连接已经建立完成\n后续的通信使用对称加密算法，对内容进行加密解密。\n\n\n\nRedis\n\nRedis 为什么这么快？\n\n单线程，避免了上下文切换。\n数据结构优化\nIO 多路复用\n\n\nRedis 支持的数据结构\n\nString / List / Set / Zset / Hash\n延时队列实现 - Zset score 设置为时间戳\n不带消费保证消息队列\n\n\nRedis 的两种持久化\n\nRDB / AOF：全量 / 增量\nBGSAVE / CopyOnWrite\n\n\nRedis 淘汰策略\n\nLRU - Least Recent Used 最近最少使用\nnoeviction 不淘汰，内存超过设置的值丢出异常。\nallkeys-lru 所有的 key 使用 lru 的方式淘汰\nvolatile-lru 过期的 key 使用 lru 的方式淘汰\nallkeys-random 所有的 key 随机淘汰\nvolatile-random 所有过期的 key 随机淘汰\nvolatile-ttl 淘汰超时的 key，和快要过期的 key\n\n\nRedis 主从？\n\n一个 Master， 若干个 Slave 同步\n\n\nRedis 哨兵机制\n\nMaster 和若干个 slave，以及 Sentinel，其中 Sentinel 用来监控 redis 集群状态。当 master 挂掉，Sentinel 就会知道，并且选一个 slave 称为新的 master，然后通知应用程序做变更。\n\n\n分布式锁\n\nSETNX TIMEOUT，命令在指定的 key 不存在时，为 key 设置指定的值，这种情况下等同 SET 命令。当 key存在时，什么也不做。并设置个超时时间避免死锁。\nredlocks?\n\n\n缓存雪崩\n\n缓存突然挂了，所有的流量涌到数据库上\n解决方案：限流（熔断）只处理指定数量流量、服务降级。\n\n\n缓存穿透\n\n使用一个不存在的 key 频繁 访问数据库。\n解决方法：把找不到的情况也放在 redis 中，同正常的情况一致处理。\n\n\n缓存与数据库的一致性（左耳朵耗子：缓存更新的条路)\n\n数据库\n\nB+ 树，是多叉树，高度很低。Hash 索引。\nB+ 树特点：减少磁盘 IO，每次读取尽可能多的数据、范围查找、磁盘预读（把数据和周围的数据都读取做缓存）\nHash特点：快，但是无法进行范围查找\n聚簇索引和非聚簇索引\n\nInnoDB 聚簇索引，只有主索引关联对应并持有的数据，非主索引存储主索引的指针（也称回表），因此通过非主索引的查找如下：非主索引 → 主索引 → 数据。\nMyISAM 非聚簇索引，主索引和非主索引都关联并持有数据。\n\n\n乐观锁悲观锁\n各种隔离等级\nMySQL 索引优化\n\n最左匹配原则：创建联合索引 “a,b,c” 时，实际上创建了三个索引，a索引，a,b 索引，a,b,c 索引。根据查询条件选择索引。\n排查：explain 命令，查看对应的语句使用索引的情况。\n索引失效：不满足最左匹配或者使用了函数。例如：where date(create_at) &lt; ‘2022-05-01’\n\n\nMySQL 主从\n\n什么是 Binlog: 记录所有对数据库更改的一个日志，二进制文件。用于数据库主从同步和备份。\n主从同步过程：主库发生写请求，对应的 Binlog 会进行修改。binlog 会发送给从库，binlog在从库中有个 relaylog(中继日志)，把relaylog 和当期那从库合并。\n\n\n\n消息队列\nRPC 与 Dubbo\n\nRPC 是如何工作？\n\n代理模式：JDK 动态代理、Cglib 字节码增强\n二者优缺点：本质都是生成一个字节码，JDK 只能代理接口，而 Cglib 是代理一个类，功能更强大。\n\n\nDubbo 是如何工作？\n\n官网图\n\n\n负载均衡、服务注册、健壮性\n\n负载均衡算法：roundrobin（轮流）、加权轮流、Sticky（粘性）、hash（客户端 ip 进行 hash）\n服务注册：每个服务提供者把自己注册到服务中心中\n健壮性：\n\n当注册中心挂掉，不影响到消费者和服务者通信。\n当服务提供者挂掉后，服务消费者应自动的重连下一个机器，自动恢复\n所有的提供者挂掉，消费者可以预先配置默认的返回值\n\n\n\n\n限流算法\n\n计数器：设定接口的值，例如1000，每个请求进来都减1，当变成负数之后，不处理请求。后台设置定时任务，每秒将该值设置为 1000，这样就可以达到 1000qps。缺点：1000 瞬间变成0，服务器会一直拒绝其他请求，导致无响应。\n漏桶：请求都放在漏斗中，处理完成的请求通过尖嘴流出，漏斗溢出的请求不处理。\n令牌桶：令牌生成器，往桶里放令牌。每个请求需要去桶拿令牌消耗，能拿到请求继续，否则请求结束。当令牌桶的令牌被消耗完之后，请求则需要等待令牌生成器生成令牌，才能往下继续。\n\n\n\nZookeeper 与分布式\n\n分布式序列号生成算法\n\n雪花算法\n\n\n分布式事务\n分布式一致性\n\n强一致：用户所做的修改所有服务器上立刻得到更新，可用性和性能相对差\n弱一致（最终一致）：下完订单，刷新回到未付款状态，再次刷新已支付\n\n\n保证分布式一致性\n\n一致性 Hash，请求计算 hash 选择最近的 hash 节点。节点分布不均，可以设置虚拟节点\n\n\n\nSpring / SpringMVC / Spring Boot\n\nIOC / DI 及其实现原理\n容器 / bean 声明周期\nAOP 实现及原理：JDK 动态代理和 Cglib 字节码增强。\n设计模式：refresh 模板方法，单例模式，代理模式，工厂模式。\nSpring Boot 改进\n\n流程配置全部自动化掉，Spring 和 SpringMVC 有的他都有\n基于注解的，减少 xml\nAuto configuration 自动配置\n内置 Tomcat 等 Servlet 容器\n\n\nSpring Boot 缺点\n\n像魔法，封装的太好了。使用者不明白他是如何工作的\njar 包比较大，内存比较多\n\n\n\nCI 与持续集成\n\n概念：程序员写代码，提交代码，测试环境中进行测试，测试无误发布到生产环境，生产环境出 bug 又要回滚。可以看到从提交代码之后的每个步骤，程序员都需要手动的进行操作，比如发布，部署项目，手动测试项目，回滚项目等等。我们要做的是，程序员只需要负责编写和提交代码，剩下的工作都交给自动化工具去做。\n流程：本地开发环境 → 版本控制系统 (Git) → CI 服务器（Jenkins）→ 测试环境服务器、预生产服务器、生产服务器\n\nwhat do you do?\n\n研究文本抄袭算法 SimHash、了解 Handlp、斯坦福 MOSS 服务。\n学英语\nJava 8 - Java 18 历代的变化，有哪些新特性，自己的项目在使用 Java 17\n简单学习了 LaTeX，CV 也是使用开源项目 Awsome CV 和 LaTex 编排的。\n学习 Groovy 脚本语言\n"},"Spaces/Resources/博客/技术类/java9-history":{"title":"Java 9 语言特性","links":[],"tags":["Java9"],"content":"接口中允许添加私有方法\njava 8 中添加了 default 方法，但这些方法之间却无法优雅的复用代码。例如：methodA 和 methodB 都需要调用 biFunction 方法，于是只能将 biFunction 方法声明成 default。\npublic interface Java8Interface {\n    default void methodA(int a, int b) {\n        // do something\n        biFunction(a, b);\n    }\n \n    default void methodB(String a, String b) {\n        // do something\n        biFunction(a, b);\n    }\n \n    default void biFunction(Object a, Object b) {\n        // do something\n    }\n}\n声明一个新的 default 方法当然可行，但却不符合接口的原则。将不必要的方法，暴露出去会给调用者带来困扰。\npublic interface Java9Interface {\n    default void methodA(int a, int b) {\n        // do something\n        biFunction(a, b);\n    }\n \n    default void methodB(String a, String b) {\n        // do something\n        biFunction(a, b);\n    }\n \n    private void biFunction(Object a, Object b) {\n        // do something\n    }\n}\n允许私有方法后，只需把原来的 default 改成 private 即可。\ntry-with-resource 优化\nJava 7 之前关闭资源需要写如下代码:\nBufferedReader br = new BufferedReader(...);\ntry {\n    return br.readLine();\n} finally {\n    if (br != null) {\n        br.close();\n    }\n}\nJava 7 之后引入了 try-with-resource ，简化了 finally 块的代码，现在只需这样:\ntry (BufferedReader br = new BufferedReader(...)) {\n    return br.readLine();\n}\n但是需要使用的资源一多，代码就会变成这样：\ntry (BufferedReader br1 = new BufferedReader(...);\n    BufferedReader br2 = new BufferedReader(...);\n    BufferedReader br3 = new BufferedReader(...)) {\n    return br1.readLine() + br2.readLine() + br3.readLine();\n}\nJava 9 之后：\nBufferedReader br1 = new BufferedReader(...);\nBufferedReader br2 = new BufferedReader(...);\nBufferedReader br3 = new BufferedReader(...);\ntry (br1; br2; br3) {\n    return br1.readLine() + br2.readLine() + br3.readLine();\n}\n注意：变量声明在 try 外面，很容易误导用户在 try 语句结束后，仍调用资源，这会导致运行时产生错误。\nBufferedReader br1 = new BufferedReader(...);\ntry (br1) {\n    System.out.println(br1.readLine());\n}\nbr1.readLine(); // 此时资源已关闭，调用会报错\n_ 不再是有效标识符\nJava 9 之前可以将 _ 下划线设置为变量，虽然编译器会警告，但运行不会报错。\nint _ = 123;\nSystem.out.println(_);\nJava 9 之后，代码会编译失败，会得到如下提示:\njava: 从发行版 9 开始, &#039;_&#039; 为关键字, 不能用作标识符\n菱形符号\nJava 7 引入了菱形符号 &lt;&gt;，让编译推断构造器参数类型。\n// java 7 之前\nList&lt;String&gt; names = new ArrayList&lt;String&gt;();\n \n// java 7 之后\nList&lt;String&gt; names = new ArrayList&lt;&gt;();\n自动参数类型推断，简化了代码。但是匿名内部类的参数推断，却不支持。\n这段代码在 Java 7 中，编译器会报错。Java 9 支持匿名内部类的类型推断，代码能正确执行。\n&lt;T&gt; Result&lt;T&gt; create(T content) {\n    return new Result&lt;&gt;(content) {\n      // 实现方法\n    };\n}"},"Spaces/Resources/博客/技术类/《Effective-Java》---Object-通用方法":{"title":"《Effective Java》- Object 通用方法","links":[],"tags":["Java","Effective-Java"],"content":"在日常 coding 中，我们会经常使用或者覆盖 Object 对象中的方法，如：equals、toString、hashcode 等。除此之外，还有 clone、finalize 方法。限于作者实力，很少用到这两个方法，即使看过原书也是一知半解，因此不敢用来「忽悠」别人。因此，这篇文章只对 equals、toString、hashCode、compareTo（该方法并非 Object 的方法）进行讲解。\n\n强烈推荐去看原书《Effective Java》，Java 程序员不能没有这本书，就像西方不能没有耶路撒冷。\n\nequals 覆盖最佳实践\nequals 方法对于刚入行的人既熟悉又陌生。给人的感觉是知道这个方法，但是在实际工作中从来没有用过。虽然我也用的很少，但还是知道它的用处，以及在日常业务代码中的一些技巧，作用。\nequals 作用\n一句话概述：比较两个对象是否相等。仅仅是比较对象是否相等，好像不值得拿出来一说。因为是 Object 的方法，因此所有的类都可以重写这个 equals 方法，满足不同类的需求，以及和 Java 中的集合类搭配使用，会产生不一样的化学反应（后面会具体描述）。\n业务场景与 equals 产生的化学反应\n\n假设老板给你提这样一个需求：在一组用户数据中，筛选出每个省份，年龄不重复用户数据。例如不能包含两条籍贯江西，年龄一岁的用户\n\n你可能会想到，每次往筛选好的集合中添加数据，都要进行判断，插入的数据在集合是否有重复，这样就写成了一个双重 for 循环\n private List filter(List&lt;User&gt; noDuplicatedUserList, List&lt;User&gt; allUserList) {\n        for (User user1 : allUserList) {\n            for (User user2 : noDuplicatedUserList) {\n                if (user1.getHome.equals(user2.getHome) &amp;&amp; user1.getAge().equals(user2.getAge())) {\n                    continue;\n                }\n                noDuplicatedUserList.add(user1);\n                break;\n            }\n        }\n     return noDuplicatedUserList;\n    }\n任务当然可以完成，但是你掌握一些 equals 的用法后，你就可以开始玩一些「骚操作」了。\n我们开始覆盖 User 类的 equals 方法，使得这个行为变得更简单，equals 覆盖后代码如下：\n private List filter(List&lt;User&gt; noDuplicatedUserList, List&lt;User&gt; allUserList) {\n        for (User user : allUserList) {\n            if(!noDuplicatedUserList.contains(user)){\n            \tnoDuplicatedUserList.add(user);\n            };\n        }\n     return noDuplicatedUserList;\n    }\n是的，重写完 equals 之后，只需要使用 contains判断两个对象是否相等即可，因为 contains方法内部使用的就是对象的 equals 方法。\n你还可以将代码更简化，让他返回一个去重的 HashSet 即可，代码如下：\n private Set filter(List&lt;User&gt; allUserList) {\n      return new HashSet&lt;&gt;(allUserList);\n }\n覆盖 equals 注意事项\n覆盖 equals 能帮我们解决问题，但必须使用得当，如果覆盖的 equals 方法，没有遵守相关约定，那么你的程序必然会在一些类的使用上出现 bug。出现 bug 一点都不可怕，可怕的是你不知道 bug 出现在哪，检查代码也发现不了错误，到头来才发现原来是这个不起眼的 equals 导致的。\n\n\n自反性：对于任何非 null 的引用值 x，x.equals(x) 必须返回 true。\n\n\n对称性：对于任何非 null 的引用值 x，x.equals(y) 返回 true，y.equals(x) 也必须返回 true。\n\n\n传递性：对于任何非 null 的引用值 x，y，z，x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 必须返回 true。\n\n\n一致性：如果两个对象相等，在没有改变对象的前提下，他们就始终相等。\n\n\n非空性：所有的对象都不能等于 null，x.equals(null)，因此在一些 equals 方法中都会进行 null 检查，如下：\n\n\nif(o == null){\n   return false;\n}\n看到这些规定，你可能头都炸了，我就写个 equals 还要遵守这么多约定，我还不如直接使用第一种方法呢。别急，往下看，最佳实践有人已经帮你总结出来了。\n覆盖 equals 最佳实践\n了解 equals 的注意事项后，以下经验就能帮助我们优雅地，高质量地覆盖 equals。拿上面的 User 来举例说明，步骤如下。\n步骤一：使用 == 操作检查对象是否相等，如果是，返回 true。\nif(obj == this) return true;\n步骤二：使用 instanceof 操作符检查「参数是否为正确类型」\nif(!(obj instanceof User)){\n\treturn false;\n} \n步骤三：把参数转化成正确的类型（需要先通过步骤二的检查）\nUser user = (User) obj;\n步骤四：比较参数中的字段与该对象的字段，匹配返回 true，不匹配返回 false;\nif(user.getHome().equals(home) &amp;&amp; user.getAge.equals(age)){\n    return true;\n}\nreturn false;\n完整的 equals 方法\npublic boolean equals(Object obj){\n\tif(obj == this) return true;\n \n\tif(!(obj instanceof User)){\n\t\treturn false;\n\t} \n \n\tUser user = (User) obj;\n\tif(user.getHome().equals(home) &amp;&amp; user.getAge.equals(age)){\n    \treturn true;\n\t}\n\treturn false;\n} \n \n这样就写完了一个高质量的 equals 方法。但是还需要注意的是，覆盖 equals 方法，必须也覆盖 hashCode 方法（原因见下一节）。equals 的参数是 Object 对象，而不是具体的某个类，因为前者才是覆盖了 equals 方法，后者只是类中的一个普通方法。\nhashCode 覆盖最佳实践\n覆盖 equals 为什么一定要覆盖 hashCode\n回答这个问题很简单，其实就是违反了 hashCode 的约定：两个对象相等，则必须返回相同的 hashCode。\n由于覆盖了类的 equals 方法，导致对象相等的逻辑发生了改变，而类的 hashCode 方法还是使用的 Object 提供的方法，就会导致相同的对象返回不同的 hashCode。\n你可能觉得 hashCode 不同就不同嘛，但是你也就此失去了使用 HashMap，HashSet 等集合类的权利，强行使用会给你的代码带来未知的 bug，因为这些类都是根据 hashCode 约定来实现的。\n我们可以通过一个例子演示该行为带来的问题，代码如下：\nMap&lt;User, String&gt; m = new HashMap&lt;&gt;();\nm.put(new User(&quot;江西&quot;,&quot;18&quot;), &quot;渣渣辉&quot;);\n我们向 HashMap 插入了一条数据，你可能期望 m.get(new User(&quot;江西&quot;，&quot;18&quot;))会返回「渣渣辉」，但很可惜并不是，而是返回 null。\n这是因为，虽然是两个是相同的对象，但是没有覆盖 hashCode 方法，导致存进 map 的对象的 hashcode 和 取值对象 hashcode 不一样，因此就会取不到对应的 value。\n覆盖 hashCode 方法\n计算 hashCode\n\n我们在方法中初始化变量 result，并让他的值等于第一个需要计算字段的值。\n如果字段是基本类型，我们就使用它的装箱基本类型的 hashCode 方法，计算该字段的 hashcode。\n如果是对象，并且类的 equals 方法调用了该对象的 equals 方法进行比较，则我们也需要在类的 hashCode 方法中递归地调用该对象的 hashCode 方法。\n如果是数组，则需要对数组中的重要元素使用上诉的方法计算 hashCode。如果所有元素都很重要，则可以使用 Arrays.hashCode 方法\n\n合并返回 hashCode\nresult = 31 * result + c;  // 其中 C 为单个字段的 hashCode 值\n这里估计你又会好奇，为什么是要乘 31。首先 31 是一个奇素数，如果是偶数的话并且乘法导致数据溢出，就会产生信息丢失。31 有个很好的特性，可以使用移位和减法来代替乘法，可以获得更好的性能，如：31 * i == (i &lt;&lt; 5) - i。\n我们把上述实践运用到 User 类中：\npublic int hashCode(){\n\tint result = String.hashCode(home);\n    result = 31 * result + String.hashCode(age);\n    return result;\n}\n这样写算是比较高效的合理的覆盖，有时我们需要让 hashCode 值尽可能地不会造成冲突，我们可以使用 Guava 包下得 Hashing。如果对性能没有该要求可以使用 Objects 提供的静态 hash 方法 Objects.hash(home, age);。\n如果是一个不可变类，且每次计算 hashCode 的开销比较大，我们可以把 hashCode 值保存到对象内部，这样下次计算 hashCode 时可以直接把保存的 hashCode 返回。\npublic class User{\n\tprivate int hashCode;\n    \n    @Override public int hashCode(){\n        int result = hashCode;\n    \tif(result == 0){\n            // 执行相应的 hashCode 计算操作\n            hashCode = result; // 计算完成记得赋值保存\n            \n        }\n        return result;\n    }\n \n}\n优雅地覆盖 toString\n我们在开发中，使用打印语句打印对象，或者在 debug 中查看对象的信息，经常能看到如下形式：User@1b456 。上诉这些行为都默认的调用了对象的 toString 方法，如果类本身没有覆盖 toString 的话，则会调用 Object 的 toString 方法，如下：\n   public String toString() {\n        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());\n    }\n从打印的对象信息来看，给我们的开发调试，提供不了任何有用的信息，因此覆盖 toString 旨在提供更多有效的信息，而不是那一串干巴巴的 User@1b456。\n在 toString 方法中应该包含一些与类相关的信息。例如 User 类，可以返回  User={&quot;江西&quot;, &quot;18&quot;}，这样清晰明了，比 User@1b456 不知好了多少。当 toString 生成的格式没有那么清晰时，就应该考虑在 javadoc 中添加格式说明，让这一过程容易被调用者接收。\n\ntips: 应该在抽象类中编写 toString 方法，让他的子类享有公共的 toString 方法。大多数集合类就是如此，例如：ArrayList 使用的就是 AbstractCollection 的 toString 方法。\n\n总而言之：如果 toString 能够为你的开发和调试等带来美观的格式，返回对象简明有用的描述，那你就应该毫不犹豫的覆盖它。\n优雅地实现 Comparable 接口\n虽然这博客说的是 Object 通用方法，但是必须说明的是 compareTo 并不是 Object 中的方法，而是 Comparable 接口的唯一方法。因为该方法很重要，且使用频率很高，所以就放在一起介绍。实现了 Comparable 接口的类，就表明该类有内在的排序关系，当然这个排序肯定是自己定义的。\njava 中的有序集合类会根据其中元素类的 compareTo 方法，将内部的元素进行排序。例如：TreeSet、TreeMap 等。\n撞脸 equals\ncompareTo 方法在官方文档的说明如下：\n\n将此对象与指定对象进行比较。当该对象小于、等于、大于指定对象的时候、分别返回一个负整数、零或者正整数。如果由于指定的对象类型与该对象类型不一致、则会抛出 ClassCastExcetion 异常。\n\n除了上诉说明，compareTo 方法还必须遵守和 equals 类似的约定：\n\n\nsgn(x.compareTo(y)) == -sgn(y.compareTo(x))，其中 sgn 是根据表达式的值为负数、正数、零，分别返回 -1、1、0。上面那个公式翻译过来就是：如果 x 大于等于 y，则 y 一定小于或等于 x，并且暗示着后者抛出异常时，前者也必定抛出异常。反之亦然。\n\n\n可传递性：如果 x 大于 y，并且 y 大于 z，则 x 必须大于 z。反之亦然。\n\n\n如果 x.compare(y) == 0，则 sgn(x.compare(z)) 等于 sgn(y.compare(z))。\n\n\n强烈建议，但非必要。(x.compareTo(y) 等于 (x.equals(y))。\n\n\n相信看完 equals 的约定，遵守这些约定对你来说应该是小菜一碟了。遵守这些约定，就能安全的使用有序集合类，以及包含搜索和排序算法的工具类。\n与 equals 的区别\n上面提到的强烈建议，与 equals 保持同等性。即当 compareTo 比较两个对象相等时， 两个对象进行 equals  方法比较也应该相等。\n\n如果违反这条建议，那么它的顺序就与 equals 不一致。如果一个类的 compareTo 方法强加了一个与 equals 不一致的顺序，那么这个类仍然可以工作，但是包含该类元素的有序集合可能无法遵守集合接口（Collection、Set 或 Map）的一般约定。这是因为这些接口的一般约定是根据 equals 方法定义的，但是有序集合使用 compareTo 代替了 equals 实施同等性检验。\n\n以下例子可以很好的解释。\nJava 中的 BigDecimal 类，它的 compareTo 方法与 equals 不一致（没有遵守上述的建议）。如果你创建一个空的 HashSet 实例，然后添加 new BigDecimal(“1.0”) 和 new BigDecimal(“1.00”)，那么该 HashSet 将包含两个元素，因为添加到该集合的两个 BigDecimal 实例在使用 equals 方法进行比较时结果是不相等的。但是，如果你使用 TreeSet 而不是 HashSet 执行相同的过程，那么该集合将只包含一个元素，因为使用 compareTo 方法比较两个 BigDecimal 实例时结果是相等的。\n因此，在使用具有排序功能的集合类时，需要特别注意 compareTo 和 equals 实现，防止引入 bug 。\n编写 comparaTo 方法\n应该杜绝使用关系运算符 ”&gt;” 和 ”&lt;” 来表示大小关系，推荐使用包装类型提供的 compareTo 方法，来比较值。假设用户的年龄值为 int 类型，比较年龄可以使用如下方法：\npublic int compareTo(User user){\n    if(age &gt; user.getAge()){\n        return 1;\n    }else if(age &lt; user.getAge()){\n    \treturn -1;\n    }else{\n    \treturn 0;\n    }\n}\n上面的写法也能达到比较的目的，但是很容易出错，而且需要比较的字段一多整个逻辑就很复杂。所有的装箱类型在 java7 中已经提供了静态的 compare 方法，并且也都实现了 comparable 接口。\n\n我们给 User 类添加一个字段 name，然后对他进行排序，先比较年龄，然后根据姓名进行排序\n\n使用包装类型的 compareTo 方法，如下：\npublic int compareTo(User user){\n    int result = age.compareTo(user.getAge);\n    if(result == 0){\n        result = name.compareTo(user.getName());\n    }\n    return result;\n}\n使用包装类型的静态 compare 方法，如下：\npublic int compareTo(User user){\n    int result = Integer.compare(age, user.getAge);\n    if(result == 0){\n        result = String.compare(name, user.getName());\n    }\n    return result;\n}\n在 java 8中，Comparator 接口配置了一组比较器构造方法，使得构造比较器非常简单，并且代码的可读性非常高。还是上面的示例，我们为 User 类编写一个比较器。\nprivate static final Comparator&lt;User&gt; COMPARATOR = \n    comparingInt(User::getAge)\n\t\t\t.thenComparing(User::getName);\n \npublic int compareTo(User user){\n   return COMPARATOR.compare(this, user);\n}\n上面的代码为 User 类编写了一个比较器，先比较年龄，然后比较名字。定义好比较器后，就直接在 User 的compareTo 方法使用即可。comparingInt 对应比较 int 类型，相似的也有 comparingLong_、和 _comparingDouble等。\n一个错误地实践，有时我们会把比较结果的正负来判断大小，我们就很容易偷懒写出如下代码：\npublic int compare(int value1, int value2){\n\treturn value1 - value2;\n}\n然后使用它的比较结果，来判断是正还是负，以此来判断 value1 和 value2 的大小关系,但是我们却没有考虑过整数溢出的情况。因为 int 类型最大，最小能表示正负21 亿左右的数字，假如 value1 是 int 类型最小值，value2 是正数，两者相减就会导致整数越界。因此使用官方为我们提供的比较方法 Integer.compare(value1, value2)，更为安全实用。"},"Spaces/Resources/博客/技术类/《Maven-实战》":{"title":"《Maven 实战》笔记","links":[],"tags":["Maven"],"content":"当项目需要被其他项目引用时，使用 mvn clean install 安装到本地仓库，其他项目就可以引用该项目。\n我们打包的默认 jar 包不能直接运行的，因为带有 main 方法的信息类不会添加到 mainfest 中（ jar 文件中 META-INF/MANIFEST.MF 文件，没有 Main-Class一行）。为了生成可执行的 jar 文件，需要借助 maven-shade-plugin，配置该插件。\n使用 Maven 命令快速创建一个 maven 项目\n使用命令 mvn archetype:generate 根据提示选择需要的骨架，输入 groupId，artifactId，version 等信息，创建项目。需要注意的是：maven2 中使用上面的命令，会去下载最新的版本，而不是稳定的版本，可能导致运行失败。maven3 则默认是下载稳定的版本。\n坐标\n\n**groupId：命名通常为域名反向一一对应。**比如 google.com 可以命名为 com.google。\nartifactId：命名推荐的做法是使用实际的项目名称作为 artifactId 的前缀。比如项目名是 demo，下面有个 hello 模块，就可以命名为 demo-hello。\n**version：**定义当前项目的版本信息。\npackaging：定义元素打包方式，打包方式通常与所生成的构件文件扩展名对应。例如指定为 jar 则构件的文件扩展名为 .jar，war 也如此。不定义 packaging 时，默认打包为 jar。打包方式会影响到构建的生命周期，比如 jar 和 war 打包会使用不同的命令。\nclassifier：定义构建输出的一些附属构建。例如项目打包生成 demo.jar 文件，打包过程中可能还需要 javadoc 文件，就可以配置对应的插件来生成 javadoc 文件。\n\n依赖的配置\n\ntype： 依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，默认为 jar。\nscope： 依赖的作用范围。\noptional： 标记依赖是否可选。\nexclusions： 用来排除传递性依赖。\n\n依赖的范围\n前置知识：Maven 编译项目主代码的时候使用一套 classpath，在编译执行测试的时候使用另一套 classpath，而实际运行 Maven 项目时候又会使用一套 classpath，因此总共有三套 classpath。\n依赖范围就是来控制与这三种 classath（编译 classpath，测试 classpath，运行 classpath）的关系。如果没有指定依赖范围，就会默认使用 compile依赖范围。\n依赖范围与 classpath 关系\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n依赖范围 （Scope）对于编译 classpath 有效对于测试 classpath有效对于运行时 classpath 有效例子compileYYYspring-coretest—Y—JUnitprovidedYY—servlet-apiruntime—YYJDBC 驱动实现systemYY—本地的 maven 仓库外的类库文件\n传递性依赖和依赖范围\n传递性依赖：A ⇒ B ⇒ C，假设 A 依赖 B，B 依赖 C。称 A 对于 B 是第一直接依赖，B 对于 C 是第二直接依赖，A 对于 C 是传递性依赖。\n上面说了依赖范围不仅与三种 classpath 有关系，还对传递性依赖产生影响。如下表格所示，最左边的一行表示第一依赖范围，最上面一行表示第二直接依赖范围。\n依赖范围影响传递性依赖\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncompiletestprovidedruntimecompilecompile——runtimetesttest——testprovidedprovided—providedprovidedruntimeruntime——runtime\n助记规律：\n\n当第二直接依赖范围是 compile 时，传递性依赖范围与第一直接依赖范围一致。\n当第二直接依赖范围是 test 时，依赖不会得以传递。\n当第二直接依赖范围是 provided 时，只传递第一依赖范围也为 provided的依赖。\n当第二直接依赖范围是 runtime 时，传递性依赖范围与第一直接依赖范围一致，但 compile 除外，此时传递性依赖范围为 runtime。\n\n依赖调节\n就近原则：A ⇒ B ⇒ C(1.0），A ⇒ B ⇒ D ⇒ C(2.0)，前者的路径长度为2，后者为3，因此 C(1.0) 被解析使用。\n先声明先使用：遇到长度一样的，无法使用就近原则，就根据声明顺序，先声明的先解析使用。\n可选依赖\n假设 A 依赖 B，B 依赖 X 和 Y，B 对于 X 和 Y 的依赖是可选依赖。A ⇒ B，B ⇒ X（可选），B ⇒ Y（可选），可选依赖不会得到传递，换句话说选择 X 或者 Y，对于 A 都不会有任何影响。\n可选依赖在 dependency标签中需要添加 &lt;optional&gt;true&lt;/optional&gt;用来标记为可选依赖，因此 B 需要添加 X 和 Y 的依赖，并且分别在 dependency标签加上 &lt;optional&gt;true&lt;/optional&gt;。\n当需要指定所使用的依赖时，需要在外层声明需要使用的依赖，上面的例子就需要在 A 中引入 X 或者 Y 的依赖。在理想的情况下，尽量避免可选依赖的使用。\n远程仓库认证\n当我们使用 &lt;repository&gt;&lt;/repository&gt; 配置好一个远程仓库后，大部分情况下无需认证就可以直接访问，但是处于安全考虑，我们需要提供一些认证信息才能访问。此时，我们就需要配置认证信息，一般在 setting.xml 文件中配置，如下：\n&lt;setting&gt;\n  ...\n  &lt;server&gt;\n    &lt;id&gt;remoteRepository&lt;/id&gt;\n    &lt;username&gt;admin&lt;/username&gt;\n    &lt;password&gt;admin&lt;/password&gt;\n  &lt;/server&gt;\n  ...\n&lt;/setting&gt;\n文件中配置了认证信息，账号密码都是 admin，需要注意的是 id 的值要与配置的远程仓库的 id 一致。\n部署至远程仓库\n编写项目的 pom.xml 文件，配置 distributionManagement 元素，代码如下：\n&lt;project&gt;\n  ...\n  &lt;distributionManagement&gt;\n    &lt;repository&gt;\n      &lt;id&gt;&lt;/id&gt;\n      &lt;name&gt;&lt;/name&gt;\n      &lt;url&gt;&lt;/url&gt;\n    &lt;/repository&gt;\n    \n    &lt;snapshotRepository&gt;\n      &lt;id&gt;&lt;/id&gt;\n      &lt;name&gt;&lt;/name&gt;\n      &lt;url&gt;&lt;/url&gt;\n    &lt;/snapshotRepository&gt;\n  &lt;/distributionManagement&gt;\n  ...\n&lt;/project&gt;\n其中 distributionManagement 包含两个子元素，前者表示发布版本构件的仓库，后者表示快照版本的仓库。两个元素都需要配置 id，name，url，id 为远程仓库的唯一标识，name 为了方便阅读（取名），url 远程仓库地址。\n发布到远程仓库的时候，往往需要认证，认证步骤与远程仓库认证一致。之后使用命令 mvn clean deploy maven 就会把项目构建输出到对应的远程仓库。\n镜像\n**如果仓库 X 可以提供仓库 Y 存储的所有内容，那么就可以认为 X 是 Y 的一个镜像。**换句话说，任何一个从 Y 仓库获取的构件，都可以从它的镜像中获取。由于地理原因，国内访问 maven 中央仓库很慢，因此就需要配置一个镜像，通常使用阿里云的镜像居多。配置文件如下：\n&lt;mirror&gt;\n    &lt;id&gt;aliyunmaven&lt;/id&gt;\n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n    &lt;name&gt;阿里云公共仓库&lt;/name&gt;\n    &lt;url&gt;maven.aliyun.com/repository/public&lt;/url&gt;\n&lt;/mirror&gt;\n改配置文件中 &lt;mirrOf&gt; 的值为 central，表示任何访问该仓库的请求都会转到这个镜像中。如果镜像需要认证，也可以基于这个 &lt;id&gt; aliyunmaven，配置仓库认证。\nMaven 的 &lt;mirrOf&gt; 标签还支持一些更高级的配置：\n\n&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;匹配所有远程仓库\n&lt;mirrorOf&gt;external: *&lt;/mirrorOf&gt;匹配所有不在本机上的远程仓库**。**\n&lt;mirrorOf&gt;repo1,repo2&lt;/mirrorOf&gt;匹配仓库 rpeo1，repo2，使用逗号分隔多个远程仓库。\n&lt;mirrorOf&gt;*,！repo1&lt;/mirrorOf&gt;匹配所有远程仓库，repo1除外。\n\n生命周期\nmaven 的生命周期其实就是软件从初始化到发布上线经历的一系列过程。maven 将这个过程抽象化了，每个周期所执行的操作都是交给插件完成。\nmaven 拥有三套相互独立的生命周期，分别是 **clean，default，site。**clean 负责清理项目，default 负责构建项目，site 负责建立项目站点。\n每个生命周期都包含一些阶段（phase），这些阶段都是有顺序的，并且后面的阶段依赖于前面的阶段。比如 clean 生命周期包含: pre-clean，clean，post-clean 阶段，当用户调用 pre-clean，只有 pre-clean 阶段会执行，当调用 post-clean 时，pre-clean，clean，post-clean 都会执行。由于三个生命周期互不影响，当调用某个生命周期的某个阶段时，对其他的生命周期没有任何影响。\nclean 生命周期阶段\n\npre-clean 执行清理前需要完成的工作\nclean 清理上一次构建生成的文件\npost-clean 执行清理后需要完成的工作\n\ndefault 生命周期阶段（主要）\n\nvalidate 验证项目是否正确并且所有必要的信息都可用\ncompile 编译项目的源代码\ntest 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求打包或部署代码\npackage 将编译后的代码打包成可分发的格式，例如 JAR。\nverify 对集成测试的结果进行任何检查，以确保满足质量标准\ninstall 将包安装到本地存储库中，作为本地其他项目的依赖项\ndeploy 在构建环境中完成，将最终包复制到远程存储库以与其他开发人员和项目共享。\n\nsite 生命周期阶段\n\npre-site 执行生成项目站点前需要完成的工作\nsite 生成项目站点文档\npost-site 执行生成项目站点后需要完成的工作\nsite-deploy 将生成的项目站点发布到服务器上\n\n命令行与生命周期\n一些常见的 Maven 命令，解释其执行生命周期：\n\nmvn clean 调用 clean 生命周期的 clean 阶段，即执行 pre-clean 和 clean阶段。\nmvn test 调用 default 生命周期的 test 阶段，即执行 validate、compile、test 阶段。\nmvn clean install 调用 clean 生命周期的 clean 阶段，以及 default 生命周期的 install 阶段。即执行 pre-clean和 clean阶段，以及 validate到 install的所有阶段。\nmvn clean deploy site-deploy 调用 clean 生命周期的 clean 阶段，default 生命周期的 deploy 阶段，以及 site 生命周期的 site-deploy 阶段，实际执行过程按照上面类推。\n\n插件目标和插件绑定\n插件目标\n一个插件往往能执行多个任务，因此插件具有多个功能，插件的每个功能就是一个插件目标 (goal)。\nmaven-dependency-plugin就有十多个目标，每个目标对应一个功能。例如：dependency:list、dependency:tree分别是不同的功能，这是一种通用的写法，冒号前面是插件前缀，冒号后面是该插件的目标。类似的，compiler:compile（这是 maven-compiler-plugin 的 compile 目标）和 surefire:test（这是 maven-surefire-plugin 的 test 目标）。\n插件绑定\nmaven 的生命周期与插件相互绑定，具体而言就是生命周期的阶段与插件的目标相互绑定。例如 mvn compile就是 default 生命周期 compile 阶段与 maven-compiler-plugin 插件的 compile目标绑定。\n内置绑定\n为了简化配置，maven 为一些核心的生命周期阶段绑定了很多插件的目标。当用户调用对于的生命周期阶段时，绑定的插件目标就会执行相应的任务。\n例如：clean 生命周期的 clean 阶段，就绑定了 maven-clean-plugin插件的 clean 目标绑定。site 生命周期的 site 阶段绑定 maven-site-plugin 插件的 site 目标，site-deploy 阶段绑定到 maven-site-pugin插件的 deploy目标。\n由于项目的打包类型会影响构建的具体过程，因此 default 的生命周期阶段与插件的目标绑定关系与打包类型有关系。\ndefault 生命周期的内置插件绑定关系（打包类型为 jar）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n生命周期阶段插件目标执行任务process-resourcesmaven-resources-plugin:resources复制主资源文件至输出目录compilemaven-compiler-plugin:compile编译主代码至输出目录process-test-resourcesmaven-resources-plugin:testResources复制测试资源文件至测试输出目录test-compilemaven-compiler-plugin:testCompile编译测试代码至测试输出目录testmaven-surefire-plugin:test执行测试用例packagemaven-jar-plugin:jar创建项目 jar 包installmaven-install-plugin:install将项目构建输出到本地仓库deploymaven-deploy-plugin:deploy将项目构建输出到远程仓库\n上面只是列举了 default 生命周期绑定了插件的阶段，并非 default 的所有阶段。\n自定义绑定\n除了上面的内置绑定外，插件还支持自定义绑定，拿 maven-compiler-plugin插件举例\n \n &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n               \t &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;diy-compile&lt;/id&gt;\n                        &lt;phase&gt;verify&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;testCompile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n&lt;/plugins&gt;\n \n上面代码将 maven-compiler-plugin插件的 testCompile目标绑定到 default 上面周期的 verify 阶段。当运行 mvn verify 时，该插件的 testCompile 目标就会执行。phase 表示绑定的声明周期阶段，因为插件可以在一个生命周期阶段运行多个方法，所以可以配置多个目标，即多个 goal。\n有的时候，没有使用 phase，插件目标目标也能绑定到声明周期的阶段中去。这是因为很多插件在目标的编写时候已经定义好了默认绑定的阶段。可以使用命令查看 mvn help:describe -Dplugin=compiler  -Ddetail 查看插件的详细信息，默认绑定的阶段等。\n当一个阶段有多个插件目标绑定时，执行顺序与插件的声明顺序有关，先声明先执行。\n插件配置\n插件目标像 Java 中的函数一样，执行相应的功能，并且还有参数，这些参数的具体值，我们可以配置，传递给插件目标。\n命令行插件配置\n命令行插件配置算是比较经典的配置手段了，在 Java 中可以使用 -D 参数配置系统属性。Maven 简单的重用了该参数，在检查插件的时候检查系统属性，实现了插件参数的配置。\n例如：maven-compiler-plugin 插件就提供了一个 maven.test.skip的系统属性，通过配置是否跳过测试。以下是该插件 testCompile目标的 skip 参数详细信息。\n skip\n      User property: maven.test.skip\n      Set this to &#039;true&#039; to bypass compilation of test sources. Its use is NOT\n      RECOMMENDED, but quite convenient on occasion.\n \n可以看到该参数可以使用 maven.test.skip，因此可以编写命令 maven install -Dmaven.test.skip=true 用来跳过测试。\nPOM 插件配置\n对于一些固定常用的参数，可以直接在 pom 文件中配置，使用 configuration 配置 参数，如下：\n    &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;warSourceExcludes&gt;WEB-INF/classes&lt;/warSourceExcludes&gt;\n                &lt;/configuration&gt;\n   &lt;/plugin&gt;\n如果需要插件在不同声明周期执行相同的目标，但是执行的参数不一样，就需要另外配置。\n &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n               \t &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;diy-compile&lt;/id&gt;\n                        &lt;phase&gt;install&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;testCompile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                        &lt;configuration&gt;\n                  \t\t\t\t\t...\n                \t\t\t  &lt;/configuration&gt;\n                    &lt;/execution&gt;\n                   \n                      &lt;execution&gt;\n                        &lt;id&gt;diy-test&lt;/id&gt;\n                        &lt;phase&gt;verify&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;testCompile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                        &lt;configuration&gt;\n                  \t\t\t\t\t...\n                \t\t\t  &lt;/configuration&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n&lt;/plugins&gt;\n如上同一插件的同一目标绑定了不同的声明周期阶段，具体的参数配置只需要在各自的 configuration 配置即可。\n聚合与继承\n聚合\n为了方便使用命令管理多个模块，就需要用到**聚合。**例如：项目中有 A，B 两个模块，需要对两个项目都执行清理 操作，因此你需要跑到 A 模块下执行 mvn clean命令，然后再跑到 B 模块下执行相同的命令。模块较多的话就比较麻烦。\n使用聚合就可以解决上述问题。新建一个聚合模块，然后将聚合模块的打包方式修改成 pom，并使用标签 modules引入模块 A，B，然后对聚合模块操作即可。示例代码：\n&lt;packaging&gt;pom&lt;/packaging&gt;\n&lt;modules&gt;\n  &lt;module&gt;A模块目录名称&lt;/module&gt;\n  &lt;module&gt;B模块目录名称&lt;/module&gt;\n&lt;/modules&gt;\n聚合模块可以与其他模块同级，同级只需要将 module 改为 &lt;module&gt;../A模块目录名称&lt;/module&gt; ，特别注意的是聚合模块的打包方式一定要修改成pom。\n继承\n继承的出现是为了消除重复，Java 如此，Maven 中的 pom 也是如此。假如有 A，B两个模块都需要 spring-core 2.0 版本的依赖，正常的做法就是在两个模块中分别声明同一个 spring-core 依赖。\n使用继承消除重复配置，新建一个模块 C，修改打包方式为 pom (与聚合操作一致)，接着引入 spring-core依赖，即可。这时 A，B 模块只需要继承 C 的 pom 即可，代码如下。\n&lt;parent&gt;\n  &lt;groupId&gt;C 模块groupId&lt;/groupId&gt;\n  &lt;artifactId&gt;C 模块artifactId&lt;/artifactId&gt;\n  &lt;version&gt;C 模块version&lt;/version&gt;\n  &lt;relativePath&gt;C 模块pom.xml路径（相对路径）&lt;/relativePath&gt;\n&lt;/parent&gt;\n引入 C 模块的坐标信息，并使用 relativePath 指向 C 模块的 pom 文件路径。Maven 会首先根据 relativePath 找 pom，找不到就去本地仓库找，如果不配置 realtivePath，那默认值是 ../pom.xml，也就是说 Maven 默认父 模块在当前模块的上一层目录。\n在上面的例子中 A，B 模块可以不用声明 gruopId 和 version，这些信息都从 C 模块中继承过来了，如果子模块要使用自己的 groupId 和 version 直接显示的声明即可。\nMaven 可继承的 POM 元素\n\ngroupId 项目组 ID ，项目坐标的核心元素。\nversion 项目版本，项目坐标的核心元素。\ndescription 项目的描述信息。\norganization 项目的组织信息。\ninceptionYear 项目的创始年份。\nurl 项目的 url 地址。\ndeveloers 项目的开发者信息。\ncontributors 项目的贡献者信息。\ndistributionManagerment 项目的部署信息。\nissueManagement 缺陷跟踪系统信息。\nciManagement 项目的持续继承信息。\nscm 项目的版本控制信息。\nmailingListserv 项目的邮件列表信息。\nproperties 自定义的 Maven 属性。\ndependencies 项目的依赖配置。\ndependencyManagement 醒目的依赖管理配置。\nrepositories 项目的仓库配置。\nbuild 包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等。\nreporting 包括项目的报告输出目录配置、报告插件配置等。\n\n依赖管理\n上面说到依赖可以继承，但是并不是每一个模块都需要引入父模块的依赖。例如一个工具模块，就不太需要 spring这些依赖包，但是因为继承关系，导致工具模块也引入了这些包，为了避免这种情况就需要使用新的元素 dependencyManagement。\ndependencyManagement 可以让子类自行的选择继承父模块的依赖，只需要将父模块的依赖用元素 dependencyManagement包裹起来即可。例如父模块依赖代码如下：\n&lt;dependencyManagement&gt;\n  &lt;dependencies&gt;\n    \n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n      &lt;version&gt;2.5.6&lt;/version&gt;\n    &lt;/dependency&gt;\n    \n     &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;/groupId&gt;\n      &lt;artifactId&gt;junit&lt;/artifactId&gt;\n      &lt;version&gt;5.0&lt;/version&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    \n  &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n子模块引用父模块依赖，代码如下：\n &lt;dependencies&gt;\n \n     &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;/groupId&gt;\n      &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n   \n  &lt;/dependencies&gt;\n子模块 pom 直接引用所需要的依赖坐标即可，上面代码只引用了父模块的 junit 依赖，因此 spring-core 不会被引入。子模块还去掉了依赖的 version 和 scope 信息，这是因为继承了父模块的 pom，完整的依赖声明已经在父 pom 中了，因此子模块只需要 groupId 和 artifactId 就能获取对应的依赖信息，这样使用也能使所有子模块统一依赖版本，降低依赖冲突概率。\nimport 和 dependencyManagement\n上面的章节说到过依赖范围 import，import 需要配合 dependencyManagement 使用。作用是将目标模块的 pom 中的 dependencyManagement 配置，导入并合并到当前模块的 pom 的 dependencyManagement 配置中。\n例如想要在另一个模块中使用父模块完全一样的 dependencyManagement 配置，需要在 pom 编写如下代码：\n&lt;dependencyManagement&gt;\n  \n  &lt;dependencies&gt;\n  \t&lt;dependency&gt;\n      &lt;groupId&gt;父模块 groupId&lt;/groupId&gt;\n      &lt;artifactId&gt;父模块 artifactId&lt;/artifactId&gt;\n      &lt;version&gt;父模块 version&lt;/version&gt;\n      &lt;type&gt;pom&lt;/type&gt;\n      &lt;scope&gt;import&lt;/scope&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n \n&lt;/dependencyManagement&gt;\n插件管理\n插件管理的思想和依赖管理一致。在父 pom 中使用 pluginManagement 包裹插件，即可达到与依赖管理一样的效果。\n子模块使用插件只需要声明 groupid 和 artifactId即可。若子模块需要修改插件的配置信息，只需要在模块中覆盖父类的配置即可。\n继承和聚合关系\n都要将打包方式改为 pom，一个模块可以既是聚合模块，又是父模块。\n约定优于配置\n我们都知道 Maven 项目的源代码文件夹是 src/main/java，编译输出文件夹是 target/classes/，这是 maven 的约定，我们只需要准守即可。当然想要自己改变这些约定也可以做到，但是不推荐。我们准守的这些约定实际上是 maven 的超级 pom 帮我们配置了这些信息。\n所有的 maven 项目都隐式地继承了超级 pom，这个超级 pom 配置了源代码目录路径，编译输出路径，测试代码路径等等，这些配置信息就是我们要准守的约定。超级 pom 可以到 maven 的安装目录下 /lib/maven-model-builder-x.x.x.jar文件（x.x.x 代表的是 maven 版本 ），解压之后找到 org/apache/maven/pom-4.0.0.xml 文件即可查看配置信息。这是我本机的超级 pom 的部分配置信息\n &lt;build&gt;\n    &lt;directory&gt;${project.basedir}/target&lt;/directory&gt;\n    &lt;outputDirectory&gt;${project.build.directory}/classes&lt;/outputDirectory&gt;\n    &lt;finalName&gt;${project.artifactId}-${project.version}&lt;/finalName&gt;\n    &lt;testOutputDirectory&gt;${project.build.directory}/test-classes&lt;/testOutputDirectory&gt;\n    &lt;sourceDirectory&gt;${project.basedir}/src/main/java&lt;/sourceDirectory&gt;\n    &lt;scriptSourceDirectory&gt;${project.basedir}/src/main/scripts&lt;/scriptSourceDirectory&gt;\n    &lt;testSourceDirectory&gt;${project.basedir}/src/test/java&lt;/testSourceDirectory&gt;\n    &lt;resources&gt;\n      &lt;resource&gt;\n        &lt;directory&gt;${project.basedir}/src/main/resources&lt;/directory&gt;\n      &lt;/resource&gt;\n    &lt;/resources&gt;\n    &lt;testResources&gt;\n      &lt;testResource&gt;\n        &lt;directory&gt;${project.basedir}/src/test/resources&lt;/directory&gt;\n      &lt;/testResource&gt;\n    &lt;/testResources&gt;\n    &lt;pluginManagement&gt;\n      &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt;\n      &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt;\n      &lt;plugins&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;\n          &lt;version&gt;1.3&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.2-beta-5&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.8&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.5.3&lt;/version&gt;\n        &lt;/plugin&gt;\n      &lt;/plugins&gt;\n    &lt;/pluginManagement&gt;\n  &lt;/build&gt;\n反应堆\n之前使用到聚合的知识，用一个聚合模块包含多个模块，只要对聚合模块操作即可影响到包含的模块。我们把包含的这一堆模块叫做**反应堆。**为啥叫反应堆呢，因为需要发生反应，在构建这些模块的时候肯定存在一个构建顺序，依次构建。\n例如聚合模块 A，按顺序包含模块 B，C，D。按照正常理解，对 A 模块进行构建时，我们会认为，B，C，D 会按照顺序依次构建，但实际的构建顺序却不一定是我们预期的那样。\n实际的构建顺序是这样的：Maven 先按照顺序读取 pom，如果 pom 没有依赖模块，那么就构建该模块，否则就构建其依赖模块，若依赖模块还依赖其他模块，则进一步构建依赖模块。\n在实际开发中可以使用一些参数，来决定需要构建的模块，或者指定模块构建的顺序。假设模块 A，模块 B 都依赖于模块 C。\n\n-am， 同时构建所列模块的依赖模块。例如：mvn clean install -pl A -am，结果顺序：C ，A。\n-amd 同时构建依赖于所列模块的模块。例如：mvn clean install -pl C -amd，结果顺序：C，A，B\n-pl 构建指定的模块，模块间用逗号分隔。例如：mvn clean install -pl A，B\n-rf  在完整的构建顺序基础上指定从哪个模块开始构建。例如：mvn clean install -pl C -amd -rf B 结果顺序：C，B，A\n"},"Spaces/Resources/博客/技术类/一个简单的分布式部署流程":{"title":"一个简单的分布式部署流程","links":[],"tags":["分布式","部署"],"content":"使用 3 种不同的方式，将项目部署成 3 个实例，每个实例监听不同的端口，由 Nginx 负责将请求转发到对应的实例中，完成请求流程。\nDocker 启动 MySQL，Redis\n首先使用 Docker 启动一个全局的 Redis，MySQL，Nginx，让项目连接上对应的数据库。\n获取并启动 MySQL\n获取最新的 MySQL 镜像\ndocker pull mysql\n启动 MySQL\ndocker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql\n获取并启动 Redis\n获取最新的 Redis 镜像\ndocker pull redis\n启动 Redis\ndocker run -p 6379:6379 -d redis\n使用 Maven Exec 插件进行部署\n在项目的 pom 文件中，引入并配置 exec 插件，代码如下：\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n                &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.0.0&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;executable&gt;java&lt;/executable&gt;\n                    &lt;arguments&gt;\n                        &lt;argument&gt;-classpath&lt;/argument&gt;\n                        &lt;classpath/&gt;\n                        &lt;argument&gt;com.github.hcsp.Application&lt;/argument&gt;\n                    &lt;/arguments&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n改配置信息指定了可执行程序 java，指定使用 classpath 中的 jar 包，配置了主类（即程序入口），完成以上配置即可使用 mvn exec:exec 运行程序，演示项目运行的端口为 8081。\n使用 java -jar 方式运行部署\n使用 maven 命令对项目进行打包\nmvn package\n得到一个可执行的 jar 包：xxx.jar，接着使用命令执行该 jar，并指定端口为 8082\njava -Dserver.port=8082  -jar xxx.jar\n使用 Docker 部署项目\n在当前项目文件中编写 Dockerfile\nFROM java:openjdk-8u111-alpine\n \nRUN mkdir /app\n \nWORKDIR /app\n \nCOPY target/spring-aop-redis-mysql-0.0.1.jar /app\n \nEXPOSE 8080\n \nCMD [&quot;java&quot;,&quot;-jar&quot;, &quot;spring-aop-redis-mysql-0.0.1.jar&quot;]\n根据编写好的 Dockerfile 生成一个 Docker 镜像文件，在当前目录运行如下命令\ndocker build .\n构建好镜像之后运行该镜像文件\ndocker run -v /C/Users/Administrator/Desktop/application.properties:/app/config/application.properties -p 8083:8081 镜像id\n由于项目默认使用的 Redis 和 MySQL 连接都是 localhost，因此在 Docker 中运行该项目会访问不了数据库，因此，我们在本地重写了 application.properties 文件，并把该配置文件映射到 Docker 内部，使得 Docker 内的项目可以读取并使用该配置文件（配置文件有优先级关系，详情点击）。\n使用并配置 Nginx，完成分布式部署\n获取最新的 Nginx\ndocker pull nginx\n在启动 Nginx 之前需要对它进行配置\nevents {}\nhttp {\n    upstream backend {\n        server 192.168.110.112:8081;\n        server 192.168.110.112:8082;\n        server 192.168.110.112:8083;\n    }\n    \n    server {\n    \t\tlisten 80;\n        location / {\n            proxy_pass http://backend;\n        }\n    }\n}\n上面配置的意思是：Nginx 监听 80 端口，并对所有 80 端口的请求转发给 backend，backend 里面又配置了三个服务，这三个服务就是上面用三种方式开启的。由于没有配置具体的转发规则，因此 Nginx 会使用默认的负载均衡机制轮询，即请求在三个服务之间均匀分布。详细的负载均衡机制点击这里。\n由于 Nginx 是 Docker 启动的，因此需要把本地编写的配置文件映射到 Docker 容器内部，使用 -v 参数。最后 Nginx 的启动命令如下，其中 --restart=always 表示 Nginx 遇到错误会自动重启。\n docker run --restart=always -v /C/Users/Administrator/Desktop/nginx.conf:/etc/nginx/nginx.conf -p 80:80 -d nginx\n启动完成后，本机上所有的 80 端口请求都会交给 Nginx 去处理，Nginx 把请求转发到对应的服务上，服务完成请求解析，执行相应过程，返回结果，流程结束。\n结语\n使用了 3 种方式部署 Java 项目，但还是推荐使用 Docker 方式。使用 Docker 编写好一个 Dockerfile，然后构建一个 Docker 镜像，要运行多个服务，使用该镜像启动多个容器即可，非常方便。\nDocker 是未来的趋势，学习并使用 Docker 很有必要。最近打算使用 Docker 打造一个 Java 开发环境，理想的结果是本机使用 IDEA，其他所有的环境都在一个 Docker 镜像中，只需要让本机的代码和 Docker 内部的代码保持同步即可。\n下一节搞个 Docker 基本概念介绍，以及理解并手动编写自己的 Dockerfile。"},"Spaces/Resources/博客/技术类/初识多线程":{"title":"初识多线程","links":[],"tags":["多线程","Java"],"content":"在编程学习中，我们都要接触到多线程，多线程会帮系统性能带来很大提升，但是这种提升是风险与收益并存的。因此，学习并掌握多线程原理至关重要。\n单线程与多线程\n既然有多线程，那肯定是有单线程的。那单线程是什么呢？单线程就是在特定时间系统只做一件事，这就和人一样只能「一心一意」，不能「三心二意」。\n平时开发中跑的 Java 程序大多都是单应用，对于一些没有什么访问量的系统来说，能勉强支撑。反之，访问量较大的话，一个线程难以处理，很影响用户的体验。就像一片麦子一个人割，和10个人一起割时间完全不同的。因此，我们就需要用到多线程来解决性能问题。\n创建多线程\n在 Java 设计之初，就考虑到了线程，因此「多线程」在 Java 中是提供了语言级别的支持。在 Java 中使用多线程也很方便。创建线程最简单的方法就是使用 new Thread()，如下代码所示\npublic class Demo {\n    public static void main(String[] args) {\n        new Thread(Demo::wheatHarvest);\n        new Thread(Demo::hoeing);\n    }\n \n    private static void wheatHarvest(){\n        System.out.println(&quot;开始割麦子&quot;);\n    }\n \n    private static void hoeing(){\n        System.out.println(&quot;开始锄地&quot;);\n    }\n}\n上面创建两个线程，一个给他 wheatHarvest()割麦子的任务，另一个给他 hoeing()锄地的任务。创建了两个线程之后，这两件事是同时执行的，并不会说非要割完麦子，才去锄地。但上面只是创建了线程，分配了要执行的任务，线程并没有执行，要让线程执行必须调用线程的 start()方法，线程才会执行。如下\nnew Thread(Demo::wheatHarvest).start();\nnew Thread(Demo::hoeing).start();\nstart 和 run 的区别\n刚开始学习多线程的时候经常将这两个方法搞混，现在重新复习一下。\n**start 方法就是让线程开始执行，而 run 是要等待线程执行完才往下执行。**如下，start 方法可以让割麦子和锄地同时运行\nnew Thread(Demo::wheatHarvest).start();\nnew Thread(Demo::hoeing).start();\n而 run 方法则是，先割麦子，等麦子割完了，然后再去锄地\nnew Thread(Demo::wheatHarvest).run();\nnew Thread(Demo::hoeing).run();\n在这个方法上实现中，run 方法和我们的单线程基本没区别，而且还额外增加了线程的开销。\n线程安全问题\n既然多线程能给系统性能带来提升，那我们就可以无脑使用吗？答案肯定不是的。既然享受了多线程给我们带来性能上的提升，同时我们也要承担多线程带来的安全问题。\n问题来源\n多线程问题的来源就是，所有被线程共享的变量。当多个线程去操作一个共享变量的时候，线程安全问题就会出现。我们看如下代码，我们使用多线程操作，把共享变量 i 自增1，把结果打印看看会发生什么\npublic class Demo {\n    private static int i = 0;\n \n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 100; i++) {\n            new Thread(Demo::modifySharedVariable).start();\n        }\n \n    }\n    \n    private static void modifySharedVariable() {\n        i++;\n        System.out.println(i);\n    }\n}\n这份代码，肯定会有人认为程序会按顺序输出 1~100，实际上不是如此。你可以把代码复制到自己的环境中运行，得出的结果可能会出乎你的意料，输出的顺序都乱了，并且可能会出现重复输出。为什么会出现这种情况呢？这是因为 i++操作并非是一个原子操作\n那什么是原子操作呢？原子操作就是一个不可分割的操作，之所以称作「原子操作」，我猜想和高中学的化学有关，原子是不可再分割的粒子，因此计算机就引用了这一概念。在多线程中，一个事情在某一时刻只能被一个线程操作，称作原子操作\n回到刚才的 i++操作，表面上我们以为是一步操作，实际上它包含了三个步骤：第一步，取 i 的值。第二步，把 i 的值加 1。第三步，把修改后的值写回 i。\n我们使用两个线程来举例，线程1，线程2。线程1先执行，执行到 i ++的第二步操作，先取 i 的值，取到 i 的值为 0，然后把值加1，这个时候值变为 2，但是请注意，这个值并没有写回 i 中。这时，线程2开始执行了，它把 i++ 操作执行完了。由于线程1并没有把值写回 i 中，因此线程2 取到 i 的值依然为 0，把值加 1，写回到 i 中，完成 i++ 操作，并执行输出语句，打印 i 的值为1，到此线程2完成了。此时线程1继续执行刚才未完成的步骤，把值写回到 i 中，刚才线程1计算的值为1，因此把 1 写回到 i 中，完成 i++操作，打印 i 的值仍然为1。经过上面的操作，会发现 i 被重复写入了，因此我们无法保证输出的结果是 1~100。\n你可能会有疑问，为什么线程1执行的好好的，线程2突然就插一脚呢？\n这是因为，在微观上（cpu 眼中），**多线程问题来源就是 cpu 的上下文切换，每个线程都会占用固定的时间周期，超过时间换线程执行。**上面的例子就刚好是 cpu 的上下文切换，导致了1 这个值重复写入到 i 中。\n我们打开 QQ，打开微信，打开浏览器，我们都认为他们是在同时运行的。但实际上都是 cpu 在进行切换，一会切换到微信，一会切换到浏览器，一会到 QQ，由于这个速度很快，我们就主观的认为他们是在同时运行的。多线程也是如此。\n线程不安全的表现（死循环，死锁，哲学家用餐）\n\n著名的 HashMap 的死循环问题可以点击该链接，了解详情。\n\n死锁详解\n以下是一个简单的死锁 Demo\npublic class Demo {\n    private static Object lock1 = new Object();\n    private static Object lock2 = new Object();\n \n    public static void main(String[] args) {\n        new Thread1().start();\n        new Thread2().start();\n    }\n \n    static class Thread1 extends Thread {\n        @Override\n        public void run() {\n            synchronized (lock1) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n \n                synchronized (lock2) {\n                    System.out.println(&quot;拿到lock2&quot;);\n                }\n            }\n        }\n    }\n \n \n    static class Thread2 extends Thread {\n        @Override\n        public void run() {\n            synchronized (lock2) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n \n                synchronized (lock1) {\n                    System.out.println(&quot;拿到lock2&quot;);\n                }\n            }\n        }\n    }\n}\n以上这段代码运行之后，控制台并没有输出，但是程序还在一直执行。代码最初声明了两把锁 lock1 和 lock2，使用synchronized 关键字，去获取锁。例如 synchronized(lock1)表示，需要拿到 lock1 才会执行后面的代码块，执行完{}包裹的代码块，锁才会释放。需要注意的是，一把锁同时只能有一个线程拿到。\n因此上面的程序执行流程是，主线程开辟了两个线程，Thread1 和 Thread2，并开始执行。其中 Thread1 需要先获取 lock1，获取之后线程休眠 500ms，然后再去获取 lock2。Thread2 则是先去拿到 lock2，休眠 100ms，然后再去拿 lock1。当 Thread1 去拿 lock2 时，发现 lock2 被拿了，于是 Thread1 等待；Thread2 准备去拿 lock1 的时候发现，lock1 被拿走了，于是 Thread2 等待。Thread1 和 Thread2 都在等待彼此释放自己需要的锁，于是产生了死锁等待。\n简单的死锁排查\n既然死锁了，我们就要需要先拿到死锁的进程 id\n在 Linux 中使用 ps aux | grep java，列出所有 java 进程的 id。或者使用 java 自带的 jps 命令，列出所有 java 进程。\n之后使用 jstack 命令打印进程的栈信息，通过输出的栈信息来排查死锁。\n\n一个经典的多线程问题哲学家用餐\n\n**预防死锁产生的原则：所有的线程按照相同的顺序获取资源的锁。**上面的例子 Thread1 和 Thread2 获取锁的顺序不不一致，Thread1 先拿 lock1，Thread2 先拿 lock2。假如两个线程都先去拿 lock1 或者 lock2，那就不会产生死锁了。\n实现线程安全的基本手段\n为了规避和解决线程带来的安全问题，我们可以采取一些措施\n使用不可变类\n使用 Integer / String 这些不可变类。\n使用 synchronized 同步块\n**方法一：**synchronized（一个对象）把这个对象当成锁\npublic class Demo {\n    private static Object lock1 = new Object();\n    private static int i = 0;\n \n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 100; i++) {\n            new Thread(Demo::modifySharedVariable).start();\n        }\n    }\n    \n    private static void modifySharedVariable() {\n        synchronized (lock1) {\n            i++;\n            System.out.println(i);\n        }\n    }\n}\n还是上面的代码，我们把声明了一个锁，并在 modifySharedVariable方法体中使用 synchronized关键字。这样线程每次执行这个方法的时候，都会先去获取 lock1，当代码块中的代码执行后，lock1 被释放，其他的线程才能继续拿 lock1 去执行。\n**方法二：**static synchronized 方法，把 Class 对象当成锁\npublic class Demo {\n    private static int i = 0;\n \n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 100; i++) {\n            new Thread(Demo::modifySharedVariable).start();\n        }\n    }\n \n    private synchronized static void modifySharedVariable() {\n        i++;\n        System.out.println(i);\n        \n    }\n}\n这次不声明锁，而是直接在 modifySharedVariable方法上使用 synchronized关键字。在 static 方法上使用 synchronized，实际上是把这个类的 Class 对象当成锁。因此每次访问这个方法都要去拿到 Class 对象，也保证了 i++ 顺序执行。\n**方法三：**实例的 synchronized 方法把该类的实例当成锁。（调用的对象）\npublic class Demo {\n    private static int i = 0;\n \n    public static void main(String[] args) {\n        Demo object = new Demo();\n \n        for (int i = 0; i &lt; 100; i++) {\n            new Thread(object::modifySharedVariable).start();\n        }\n    }\n \n    private synchronized void modifySharedVariable() {\n        i++;\n        System.out.println(i);\n \n    }\n}\n当 synchronized 声明在普通的方法上，实际上是把调用的对象当成锁。上面的代码是通过 Demo 类的一个实例 object 来调用 modifySharedVariable 方法的。因此，object 就被当成锁，也保证了 i++ 顺序执行。上面的代码也可以改成这样\npublic class Demo {\n    private static int i = 0;\n \n    public static void main(String[] args) {\n        Demo object = new Demo();\n \n        for (int i = 0; i &lt; 100; i++) {\n            new Thread(object::modifySharedVariable).start();\n        }\n    }\n \n    private void modifySharedVariable() {\n        synchronized (this){\n            i++;\n            System.out.println(i);\n        }\n    }\n}\n直接用 synchronized (this)，这与 synchronized 声明在实例方法，功能是等价的。\n使用 Collections 工具类\n我们可以使用 Java 给我们提供的 Collection 的工具类，把不安全的 Collection 变成安线程全的。像 Collections.synchronizedList()，Collections.synchronizedSet() 等等\n例如将普通的 Map 变成线程安全的 Map\n  Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());\n使用 JUC（java.util.concurrent） 包\njuc 包提供了很多线程安全的类，遇到线程安全问题，我们都可以把不是线程安全的类，换成线程安全的。\n**原子操作类：AtomicInteger、AtomicBoolean..，**之前的我们得 i++ 操作不是原子的，可以使用原子操作类 AtomicInteger，来进行替换。使用 AtomicInteger 的 incrementAndGet方法，就可以实现原子自增1的操作。\n**线程安全集合：**ConcurrentHashMap，ConcurrentLinkedQueue 等。在任何使用 HashMap 有线程安全问题的地方，都可以无脑使用ConcurrentHashMap 替换\nReentrantLock （可重入锁）\nReentrantLock 所做的事情和 synchronized 几乎一样。\n**区别在于 ReentrantLock 可以自己定义加锁和解锁时机。**使用 synchronized 关键字，执行完代码块中的代码，锁就会释放，但是有的时候我们需要在其他地方释放锁，而不是执行完就释放。因此可以使用 ReentrantLock 加锁，在适当的时机解锁\npublic class Demo {\n    private static final ReentrantLock reentrantLock = new ReentrantLock();\n    private int i = 0;\n \n    public static void main(String[] args) {\n \n        Demo object = new Demo();\n        for (int i = 0; i &lt; 100; i++) {\n            new Thread(object::modifySharedVariable).start();\n        }\n    }\n \n    private void modifySharedVariable() {\n        reentrantLock.lock();\n        i++;\n        reentrantLock.unlock();\n        System.out.println(i);\n    }\n}\n还是之前的例子，如果你对输出结果并不关心的话，进入到 modifySharedVariable方法后，先使用 reentrantLock.lock() 获取锁，等 i++ 操作结束之后，使用 reentrantLock.unLock() 释放锁。reentrantLock 获取锁和释放锁的操作时机，都可以根据实际情况自己定义。\n**Tips：可重入锁相关概念。**如下 Demo\npublic class Demo {\n    public static void main(String[] args) {\n        Demo object = new Demo();\n        object.a();\n    }\n \n    private synchronized void a() {\n        System.out.println(&quot;a&quot;);\n        b();\n    }\n \n    private synchronized void b() {\n        System.out.println(&quot;b&quot;);\n    }\n}\na 和 b 方法都使用 synchronized 声明了，主线程调用声明了一个实例调用 a 方法。根据前面学的知识，调用 a 方法需要拿到实例锁，然后执行 a 方法。a 方法中又调用了 b 方法，b 方法也需要拿到实例锁，但是因为 a 已经拿到了实例锁，并且 synchronized 也是可重入锁，所以调用 a 方法中调用 b 方法无需再去获取实例锁，这就是可重入锁的概念。\n\n可以点击查看 StackOverflow 上的大牛对于可重入锁的概念的理解链接\n\nObject 类里的线程方法\n说方法之前，了解下 Java 线程中的 6 种状态\n\n**初始（NEW），**创建一个线程对象，但没有调用 start 方法\n**运行（RUNNABLE），**开始执行操作（得到 CPU 使用权）\n**阻塞（BLOCKED），**线程阻塞与锁\n**等待（WAITING），**需要其他线程唤醒，或中断\n**超时等待（TIMED_WAITING），**可以指定时间后，自行返回\n**终止（TERMINATED），**线程执行完毕\n\n使用代码解释这几个状态\npublic class Demo {\n \n    private static int i = 0;\n \n    private static Object lock = new Object();\n \n    public static void main(String[] args) {\n        new Thread(Demo::modifySharedVariable).start();\n        new Thread(Demo::modifySharedVariable).start();\n        new Thread(Demo::modifySharedVariable).start();\n    }\n \n    public static void modifySharedVariable() {\n        synchronized (lock) {\n            i++;\n            System.out.println(i);\n            lock.wait();\n        }\n    }\n}\n用 new 一个线程的时候就是初始状态，调用了 start 方法，线程进入运行状态。假如第一个线程更快一步拿到 lock，这时其它两个线程就处于阻塞状态，当 lock 调用 wait() 方法，拿到 lock 的线程就进入等待状态，然后释放 lock，当线程方法执行完之后，线程进入终止状态\nwait() 方法\n让当前线程进入等待状态。调用 wait 方法之前，必须先拿到锁。当调用 wait 方法之后，拿到的锁也就会释放。\nnotify()\n随机唤醒一个处于等待状态的线程。\nnotifyAll()\n唤醒所有处于等待状态的线程。\n\n实现生产者消费者模型 demo，可点击查看。\n\n线程池与 Callable / Future\n什么是线程池\n在前面提到，我们每次使用线程都要先创建一个线程，然后使用给他分配任务，最后调用他的 start 方法执行这个任务。上面的步骤看起来没多大问题，仔细想想看，要是任务一多，每次分配任务的时候都要创建一个新的线程，这个创建线程的花销在 Java 世界中是很「昂贵的」。\n类比到生活中，公司每次新接一个项目都去招一些人，做完项目就炒了，然后下次又来一个新的项目，又要去招人，这对于 HR 来说很麻烦。市面上的策略大多都是，招一群有潜力的人才，然后公司培养，有项目来就参与项目开发，下次再遇到新项目还是用之前招的人，这样就减少了公司频繁找人的开销。\n线程池就是预先定义好若干个线程，每次需要线程的时候就去调用，避免了每次创建线程的开销，这与公司找人的策略是一样的。\n定义线程池\n使用 Executors 类去创建相应的线程池，并且可以配置线程的信息，使用 newFixedThreadPool方法，创建固定数量的线程池。\n ExecutorService executorService = Executors.newFixedThreadPool(10);\nRunable 与 Callable\n在线程池中，都是使用 submit 方法提交并执行任务。使用 submit 方法的时候可以发现，它接收两个不同类型的参数。一个是与之前多线程相同的参数 Runable，而另一个则是 Callable。通过查看两者源代码可以发现，前者是没有返回值的，而 Callable 则有返回值。\n\n\n我们可以发现 submit 方法返回了一个 Future 对象，Future 泛型的值与 Callable 里 call 方法返回的值是一样的。\nFuture\n**Future 表示异步计算的结果，也可以理解未来返回的结果。**例如：我们让一个工人去割麦子，他去执行之后，我们只需要看看仓库是否增加了这么多麦子即可。工人割麦子的时候，我们可以去干其他事情，只需最后看结果就行。这个 Future 就是工人割的麦子总量。\nFuture 的常用 API\n\nget() 方法即可拿到返回的数据（拿到麦子）\nget(long timeout, TimeUnit unit) 给定等待时间，拿到结果（在规定时间内，检查割了多少麦子）\ncancel() 方法取消当前线程的任务（不让工人割麦子）\nisCancelled() 方法判断当前线程是否在正常结束之前被取消（不让工人割麦子之后，检查麦子是否割完）\nisDone() 判断当前线程是否执行完成（检查麦子是否割完）\n\n使用多线程实现 Word Count\nWordCount 就是给定一段或者多段文本（假设每个单词之间都是用空格分隔），记录每个单词出现的次数。\n实现思路：可以定义一个线程池，线程池中线程的数量可以根据参数传递。每个线程的任务就是读取文件的一行，然后统计该行每个单词出现的次数。最后把每个线程执行的结果汇总，这样就完成了。\n先把整个思路的代码写好，通过参数 threadNum定义了线程池中线程的数量。使用 Map&lt;String,Integer&gt; 记录单词出现的次数，Future&lt;Map&lt;String, Integer&gt;&gt; 表示线程返回的结果， List&lt;Future&lt;Map&lt;String, Integer&gt;&gt;&gt; 就表示多个线程返回的集合。\n由于有多个文件，因此使用 for 循环对每个文件都要进行统计操作。threadPool.submit(() -&gt; workJob(file)) 提交了任务并执行，任务就是 workJob，即统计一行，单词出现的次数，返回的结果是Future&lt;Map&lt;String,Integer&gt;&gt;，再用刚才定义好的集合 futures，把所有线程返回的结果收集起来。\nfutures 收集完成后，开始遍历这个集合，把线程返回的结果进行统计合并，使用 mergeWorkResultIntoFileResult得到一个最终的结果，然后把最终的结果返回，程序执行结束。\npublic static Map&lt;String, Integer&gt; count(int threadNum, List&lt;File&gt; files) throws ExecutionException, InterruptedException {\n \n        ExecutorService threadPool = Executors.newFixedThreadPool(threadNum);\n \n        List&lt;Future&lt;Map&lt;String, Integer&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();\n \n        for (File file : files) {\n            futures.add(threadPool.submit(() -&gt; workJob(file)));\n        }\n \n        Map&lt;String, Integer&gt; finalResult = new HashMap&lt;&gt;();\n        for (Future&lt;Map&lt;String, Integer&gt;&gt; workResult : futures) {\n            mergeWorkResultIntoFileResult(workResult.get(), finalResult);\n        }\n \n        return finalResult;\n    }\n接下来是具体的方法实现，首先是 workJob() 方法。统计一行文本中，单词出现的次数。\n先读取一行文本保存到字符串，然后 split() 方法对单词进行分割，得到单词数组 words。把单词数组遍历，map 记录单词出现的次数。其中 result.getOrDefault(word, 0) + 1 方法表示：从 map 中拿到 key 为 word 的值，如果存在这个 key，就对这个 key 的值进行 +1 操作，然后 put 进去。如果不存在这个 key，就使它的值默认为 0，然后再进行 +1 操作，put 进去。\n   private static Map&lt;String, Integer&gt; workJob(File file) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));\n \n        Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;();\n        String line;\n        while ((line = bufferedReader.readLine()) != null) {\n \n            String[] words = line.split(&quot; &quot;);\n            for (String word : words) {\n                result.put(word, result.getOrDefault(word, 0) + 1);\n            }\n        }\n        return result;\n    }\n最后的工作 mergeWorkResultIntoFileResult()，把线程返回的结果，合并统计，得到最终结果。统计的操作和 workJob() 方法类似。把合并的结果返回即可。\n    private static Map&lt;String, Integer&gt; mergeWorkResultIntoFileResult(Map&lt;String, Integer&gt; workResult, Map&lt;String, Integer&gt; fileResult) {\n        \n        for (Map.Entry&lt;String, Integer&gt; entrySet : workResult.entrySet()) {\n            String word = entrySet.getKey();\n            int mergerResult = fileResult.getOrDefault(word, 0) + entrySet.getValue();\n            fileResult.put(word, mergerResult);\n        }\n \n        return fileResult;\n    }\n至此，一个使用多线程的 wordcount 功能实现。代码可以点击看源代码，后续会在代码中更新其他方法实现 WordCount。\n多线程应用场景\n\n\n不推荐：对于 cpu 密集型应用稍有折扣。cpu 密集型操作会把 cpu 跑满，因此再使用多线程去操作，性能上很那有提升。\n\n\n推荐：IO 密集型操作（文件 IO，网络 IO），这两个操作相比 cpu 的执行速度慢如蜗牛，因此用多线程来执行，性能上会有很大提升。\n\n\n多线程性能提升的上限：单核 cpu 100%，如果是多核就是 N*100%。当 cpu 跑满的时候，就很难有「闲工夫」去处理其他请求。\n\n"},"Spaces/Resources/博客/技术类/单例实现的几种方式":{"title":"单例实现的几种方式","links":["writing"],"tags":["Java","单例"],"content":"什么是单例\n单例是一个只实例化一次的类，即类仅存在一个对象。\n私有化构造器 + 静态成员变量\n显示声明构造器，并使用 private 关键字将其私有化，避免使用 new Object 来创建对象。需要使用该实例，只需要通过成员变量 INSTANCE 访问即可。\npublic class MySingleton {\n    public static final MySingleton INSTANCE = new MySingleton();  \n    private MySingleton(){}\n}\n缺点：会被 AccessibleObject.setAccessible 方法利用反射调用私有构造函数，实例化新的对象。\n私有化构造器 + 静态工厂方法\n该单例实现方法与上面基本一致，只需要将成员变量私有化，添加工厂方法来访问该成员变量即可。获取实例只需要调用 getInstance 即可。\npublic class MySingleton {\n    private static final MySingleton INSTANCE = new MySingleton();  \n    private MySingleton(){}\n    \n    public static MySingleton getInstance(){\n        return INSTANCE;\n    }\n}\n缺点：同上。\n实现序列化需要注意的问题\n使用上述两种方法实现单例，且需要实现可序列化时，仅仅是实现 Serializable 接口是不够的，要维护单例保证，应声明所有实例字段为 transient，并提供 readResolve 方法（Item-89）。\n否则，每次反序列化实例时，都会创建一个新实例，在我们的示例中，这会导致出现虚假的 MySingleton。为了防止这种情况发生，将这个 readResolve 方法添加到 MySingleton 类中。\n详细的解决方法可以查看《Effective Java》第三版 Item 89。\n单元素枚举\n优点：默认提供了序列化机制，提供了对多个实例化的严格保证，即使面对复杂的序列化或反射攻击也是如此。\npublic enum MySingleton{\n    INSTANCE;\n}\n缺点：当类需要扩展超类时，enum 便不在适合。\n延迟加载单例（双重检查不成立？）\n延迟加载即只有第一次调用时，才进行初始化。\npublic class MySingleton {\n    private static MySingleton INSTANCE = null;  \n    private MySingleton(){}\n    \n    public static MySingleton getInstance(){\n        if (INSTANCE == null) {\n            INSTANCE = new MySingleton();\n        }\n        return INSTANCE;\n    }\n}\n当程序第一次调用 getInstance 方法时，MySingleton 实例才被初始化。\n该延迟加载在多线程情况下，可能会创建多个实例，因此需要对 getInstance 方法进行加锁处理。\n  public synchronized static MySingleton getInstance(){\n        if (INSTANCE == null) {\n            INSTANCE = new MySingleton();\n        }\n        return INSTANCE;\n    }\n加锁的意图在于第一次初始化的时候，保证只有一条线程进入到 if 语句中，生成实例。直接在方法上加锁，会导致性能下降。因为每次去取该实例都要去获得锁，所以需要对该方式进行优化。\n public static MySingleton getInstance(){\n        if (INSTANCE == null) {\n            synchronized (MySingleton.class){\n                if (INSTANCE == null) {\n                    INSTANCE = new MySingleton();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n该方法称作 双重检查 ，保证了多线程环境下，只生成一个实例，且后续对该实例的调用都不会进行加锁处理。\n由于类加载以及对象初始化的特殊性值，会导致该双重检查不成立，可以使用 volatile 关键字声明变量，防止指令重排，实现最终目的。想了解该问题具体产生的原因，可以查看。\npublic class MySingleton {\n    private static volatile MySingleton INSTANCE = null;  \n    private MySingleton(){}\n    \n     public static MySingleton getInstance(){\n        if (INSTANCE == null) {\n            synchronized (MySingleton.class){\n                if (INSTANCE == null) {\n                    INSTANCE = new MySingleton();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n}\n一份来自 Java 巨佬关于 双重检查的阐述，点击这里 。"},"Spaces/Resources/博客/技术类/命令行的入门与详解":{"title":"命令行的入门与详解","links":[],"tags":["命令行"],"content":"什么是命令行\n操作系统都有内核的概念，内核是直接与硬件打交道的。我们通过包裹内核的一层壳（ shell ）来与内核打交道。\n广义的命令行包括一切通过字符终端控制计算机的⽅式\n\nWindows - cmd/PowerShell/Git bash\nUNIX/Linux系列：sh/zsh/Terminal, etc.\n\n为什么需要命令行\n\n因为基本所有公司的服务器都运⾏在 Linux 上 ，所以不得不用\n将工作自动化（暂时没有接触到的领域）\n相比 GUI，命令行更容易开发维护，bug 更少\n远程连接命令行占用资源远低于 GUI\n命令行上的开发者工具更丰富\n\n不同平台命令行启动方式\n\nWindows：cmd/PowerShell/WSL\nUNIX/Linux：⼀开机就是，不⽤找。Mac OS 对应的是终端。\n\n命令行的全部要素\n命令是由可执行程序和参数组成的。例如：git add test.txt，git 就是可执行程序，git 后面所有的都是**参数，**即 add test.txt 。命令行输入命令，会把参数原封不动地交给可执行程序解释。\n可执行程序（Executable）\n什么样的东西是可执行的呢？在 Windows 和 Linux / Unix有着不同的区别\n\nWindows：只要是 exe / bat / com 结尾的文件都是可执行文件\nLIunx / Unix：文件有 x 权限，表示该文件为可执行文件\n\n可执行程序的位置\n\nWindows：Path 环境变量或当前⽬录\nUNIX / Linux：PATH 环境变量\n\n可以在脚本的第一行指定解释器（shebang），假设 zzf.sh文件中有如下代码：\n#!/usr/bin/env node\nconsole.log(123)\n#!/usr/bin/env node 意思是在 PATH 环境变量找到 node 解释器位置，来解释 zzf.sh 文件。也可以使用 node.exe 文件的绝对路径。\n#!/d/node\nconsole.log(123)\n从环境变量找解释器和使用绝对路径是等价的，但是一般都是从环境变量去找，更为灵活。\n参数\nUNIX 参数的约定\n\n使用一个 ”-” 后面只能跟一个字符，例如：-a -f  等等。后面跟多个参数的话可以合并，例如：-a -f 合并成 -af\n使用两个 ”-” 后面可以跟一个单词，例如： ls -a  显示所有文件，等价于 ls --all \n\n然而，Java 并不鸟 UNIX 参数约定，例如：当我们查看当前 Java 版本，使用命令 java -version ，一个 ”-” 后面跟了一个单词，与 UNIX 参数约定不符\n参数一些注意事项默认情况下 “&quot;符号会进行展开。假设当前目录存在一个‘mainA.class 文件，并且 export A=123 设置环境变量 A 为123， 使用 Java mainA‘ 运行该文件，等价于‘Javamain123‘ 。即，把A 替换成 123，如果不进行替换，就要使用单引号包裹起来，即 Java &#039;main$A&#039; 。双引号包裹内容也会进行替换。\n因此得出以下结论\n\n单引号：不会对引号的内容做处理\n双引号：对引号里的内容替换\n空格：当做参数处理\n\n环境变量（Environment variable）\n\n进程（Process）\n\n进程是计算机程序运⾏的最⼩单位\n独占⾃⼰的内存空间和⽂件资源\n\n\n每个进程都和⼀组变量相绑定\n\n传递不同的环境变量可以让程序表现出不同的⾏为\nCLASSPATH/GOPATH\n\n\n在进程的fork过程中，环境变量可以被完全继承\n所有的操作系统/编程语⾔都⽀持环境变量\n局部和全局的环境变量\n\n局部变量：只在当前环境生效\n全局变量：全局生效的变量\n\n\n\n我们可以通过 export / set 设置环境变量，通过 echo 读取环境变量 。修改全局变量就需要在全部变量文件中修改，不同操作系统对应的文件不同。\n工作目录（Working directory）\n工作目录就是输入命令行时，所处的目录即为工作目录。绝对路径是以根目录开头的路径，相对路径是相对于当前目录的路径。\n进程的输入与输出\n标准输⼊ stdin ，进程将从标准输入中得到输入数据。例如使用 rm -rf * 命令，会提示是否确认删除，当我们回复y 的时候，就时一个标准输入。\n输出的重定向，我们可以使用 ”&gt;” 符号来重定向输出，例如在终端输入 date +&quot;%Y-%m-%d %H:%M:%S&quot; &gt; output.txt ，就是将标准输出重定向到 output.txt 文件中，若再次运行该命令，会将之前的 output.txt 文件覆盖 。使用 ”&gt;&gt;” 可以将标准输出追加到 output.txt 文件中。\n标准输出 stdout 和标准错误 stderr 相当于一个进程的两个管道。标准输出对应着文件描述符1，标准错误 对应着文件描述符2。假设我们要将一个进程的标准输出重定向到 output.txt 文件中，我们可以使用 命令 &gt; output.txt 或者  命令 1&gt; output.txt 。同理类推，将进程的标准错误重定向到 error.txt 文件，可以使用    命令 2&gt; error.txt 。要让标准输出和标准错误都重定向到 output.txt 文件，使用  命令 &gt; output.txt &gt; 2&gt;&amp;1 。该命令代表的意思是，先将2（标准错误），重定向到1（标准输出），再把结果重定向到 outout.txt 文件。\n/dev/null 相当于一个垃圾桶的概念，可以把标准输出或者标准输入重定向到该文件。  命令 &gt; /dev/null 即把标准输出丢到垃圾桶里，相当于黑洞一般，把标准输出给「吞」了。\nLinux 文件权限\n任何一个 UNIX 文件都有9位，分成3组，分别是自己（文件创建者），同用户组的人，不同用户组的人。每一组都有 rwx，r 代表读（read），w 代表写（write），x 代表可执行。\n假设有一个需求，我们要当前文件只能被当前用户读写执行。就需要把自己组的 r 设置为1，w 设置为1，x 设置为1，其他组的 rwx 都设置为0，设置完成后对应的二进制分别是 111 000 000 ，对应的十进制就是 700 ，因此使用 chmod 700 当前文件 即可赋予当前用户读写执行权限。\n根据上面的结论，我们需要给所有用户可读可写可执行权限，就需要把所有组的 rwx 设置为1，得到的二进制就是 111 111 111 ，对应的十进制为 777 ，因此 chmod 777 当前文件 表示为所有用户，赋予可读可写可执行权限。\nLinux 常用命令\n\n进⼊⽬录 cd (change directory)\n展示⽂件 ls/ll/ls -alth (list)\n移动/重命名⽂件 mv (move)\n删除⽂件 rm/rm -r/rm -rf (remove)\n拷⻉⽂件 cp/cp -r (copy)\n显示变量 echo\n导出变量 export\nGit系列操作 git pull/push/add/commit/…\n新建⽬录 mkdir/mkdir -p (make directory)\n当前⽬录 pwd (print working directory)\n显示⽂件 cat (concatenate and print files)\n编辑⽂件 vi\n"},"Spaces/Resources/博客/技术类/字符串与编码":{"title":"字符串与编码","links":[],"tags":["字符串","Java"],"content":"我们都知道，在网络通信和存储的都是字节流，都是一大串的 0 和 1。不知道大家有没想过，存储既然是 0 和 1，为什么我们看到得都是一个个字符，汉子，英文？是不是计算机在背后偷偷的把字节转化成我们人类能看懂的语言？答案是肯定的。\n字符集相关概念\n既然计算机帮我们把字节转成人类的语言，那么肯定存在着一种映射关系「字节 ⇒ 人类语言的映射」，我们把这种关系称为字符集。把字节转化成人类看懂的字符，这一过程称为编码，反之称为解码。\n假如世界都用同一份字符集，同一种编码和解码方式那么就不会存在我们常见的「乱码」问题了。但正是因为世界多样性，也导致了字符集的多样性，每个国家语言不同，所使用的字符集，编解码方式也可能不同。\n假如我们把阿拉伯数字看作字节，把不同语言的翻译看做编解码方式。因此，1，2，3 翻译成汉字就成了一，二，三；翻译成英文就成了 one，two，three。假如，本应该使用中文编码的字节，却使用了英文编码，这就会让没有学过英语的人看不懂，不懂 one，two，three 是什么，对于他们来说这就是乱码。\n字符集 Unicode\n在字符集群魔乱舞时代，有人站了出来。他把所有的地区性编码方案废弃，重新搞了一个包括了地球上所有文化、所有字母和符号的编码 Unicode。其中 uni 是英文前缀，表示「单一，一个」，因此 Unicode 的字面意思也很好理解，百度百科上翻译成「统一码，也叫万国码、单一码」。\nUnicode 的设计非常的简单：从一个数字映射到一个字符。图中简单地演示了 unicode 的映射关系，实际上的对应关系并非如此。\n\n图中所示，把左边的数字编号称作码点（code point）。\nUnicode 数据类型\n现在换位思考下，如果让你来设计 Unicode 码表，你会用什么数据类型来存储上面的数字编号呢？\n现在来对比下这些数据类型关系\nbyte --&gt; 0~255 --&gt; 256\n    \nshort --&gt; 2 bytes --&gt; 65536\n    \nint --&gt; 4 bytes --&gt; 约 42 亿\n很显然 byte 不合适，256个数，存中文都不够。short 存中文可能勉强够用，但是这还要包含其他国家的文字啊，加起来肯定不够用。int 42 亿个，足够全世界的文字使用， 因此选用 int 类型，实际上 Unicode 也是这么做的。\n缺陷\n上面提到为了包含全世界所有的文字，Unicode 使用了 int 类型。int 4个字节，对于编号在前面的字符，就会造成空间浪费。例如编号为 1 的字符，把编号转换成字节就变成 “00000000  00000000  00000000 00000001”，我们会发现前三个字节都是 0，这样造成了空间浪费。本来一个字节就能表示的编号，硬是多占用了3个字节，编号靠后的还好，靠前的大多都浪费流量，浪费空间。\n如图我们把前四位编码成 4 个字节，编码后的前三个字节都是 0。更何况Unicode 兼容了 ASCII 码表，前128 位都是常用的一些字符，本来字母 “a” 只需要占用一个字节，经过 Unicode 编码后需要占用 4 个字节，不利于传输和存储。\n\n常见的两种编码方案：UTF-8，UTF-16\n正是因为 Unicode 对于靠前的码位太占空间了，所以就有了 UTF-8，UTF-16 等编码方案，用来解决空间占用问题。其实我们也很容易想到一种解决方案：把常用的字符用一个字节存储，不常用的用多个字节存储，这样就避免了 Unicode 缺陷\nUTF-16\nUTF-16 根据码位所处的范围进行不同编码。\nU+0000 至 U+D7FF 以及从 U+E000 至 U+FFFF 的码位\n第一个 Unicode 平面（码位从 U+0000 到 U+FFFF ）包含了最常用的字符。只要处于这个范围内，UTF-16 就使用两个字节存储它。我们的汉字基本上都是处于该范围，因此在 UTF-16 中，汉字大多都是两个字节。\nU+10000 至 U+10FFFF 的码位\n当处于码点处于该范围时，UTF-16 就使用 4 个字节进行存储。因此，UTF-16 将常用的字符用 2 个字节存储，不常用的用 4 个字节存储，相比 Unicode 空间节省了不少。\n一个简单的 UTF-16 编码过程\n21608  --&gt;  &quot;周&quot;  // 已知「周」字在 Unicode 的码位是 21608\n------------------\n5468     \t\t\t\t\t// 转换成 16 进制\n「周」字的码位，转成 16 进制得到 5468，然后判断所属范围，很显然属于上面的第一种范围，因此「周」字需要两个字节存储 54 68。我们可以在程序中打印出来 System._out_.println(&#039;\\u5468&#039;)。\nBOM\n两个字节代表一个字符，在存储传输过程中存在着顺序问题。拿刚才的「周」字举例，虽然我们认为在传输过程中都是按照 54 68的顺序，但实际并非如此。在有的系统他是反过来传输的 68 54，为了解决这个问题，在文件的开头加入了几个不可见的字符，来声明字节顺序。这几个特殊字符称作 BOM（byte order mark），即字节顺序标记。\n上面的字节存储传输的方式，也有专业的名称**。**这个在编码中叫做大端（Big Endian 简写 BE）和小端（Little Endian 简写 LE）。在很多文本编辑器也有出现，比如我在使用的 Notepad2，就支持 UTF-16 LE BOM 和 UTF-16 BE BOM 编码方式。\n顺带一说的是，Java 程序内部的存储编码方式就是 UTF-16。\nUTF-8\n先说一个结论：如果没有意外，所有的编码方案都改成 UTF-8，UTF-8 是对多语言支持最好的一种解决方案。在 Mac/Linux 默认编码就是 UTF-8，由于历史原因，Windows 默认的中文编码是 GBK。\nUTF-8 是一种可变长的编码方式，那它是怎么做的呢？他对所有的码表进行分区，第一个分区占用一个字节，第二个占用两个字节，以此类推，最多支持到 6 个字节。UTF-8 兼容了 ASCII 码表，因此 ASCII 码表的字符在UTF-8 中占用一个字节，属于下面第一行的范围。我们使用的汉字，属于第三行的范围，因此汉字在 UTF-8 中编码占 3 个字节。下面展示了从 1 到 4分区范围。\nU+ 0000 ~ U+  007F: 0XXXXXXX\nU+ 0080 ~ U+  07FF: 110XXXXX 10XXXXXX\nU+ 0800 ~ U+  FFFF: 1110XXXX 10XXXXXX 10XXXXXX\nU+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX\n例如：「周」字的码位 21608，转换成 16 进制 5468 属于第三行的范围，根据他的编码规则会生成 3 个字节，编码过程如下：\n\t\t5     4     6     8\n\t 0101  0100  0110  1000    对应的二进制\n\t---------------------------\n\t 0101    010001   101000   根据第三行的模板，每个字节中 &quot;x&quot; 的数量分成三组\n 1110XXXX  10XXXXXX 10XXXXXX   第三行模板\n 11100101  10010001 10101000   代入模板\n    E5        91       A8     \n不知道大家有没思考过一个问题：UTF-8 编码之后，计算机怎么知道该读几个字节？例如上面的 11100101  10010001 10101000计算机怎么知道这 3 个字节是一起的，而不是分 3 次读单个字节呢？\n其实仔细观察分区之后的模板就能发现端倪，第一分区首字节的第一位是 0，第二分区首字节前两位两个 1，第三个分区有三个1，计算机就是根据这个特点来进行读取的，当读到第一个字节前几位有几个 1 就读几个字节。刚才的「周」第一个字节有三个 1，因此计算机就连续读三个字节。由于这一特性，UTF-8 是不需要 BOM 的，但是 windows 的记事本默认都会加上 BOM，不支持不带 BOM 的编码（最近好像支持了），UTF-8 带\n这个模板是如何设计生成的呢？编解码的算法是如何实现的呢？这里不展开（主要是我也不会），维基百科搜 UTF-8 就好了（推荐），或者访问他人博客，了解相关内容。\nGBK\nGBK（国标扩展） 字符集，简称国标扩。GBK 完全不鸟 Unicode 标准，对于中文统一采用 2 个字节编码，因此在 GBK 编码中汉字是占用两个字节。\n乱码的来源也与 GBK 有关，如果文件是用 Unicode 字符集编码，而你却使用 GBK 去解码，就会导致乱码问题。比如「周」字，在 Unicode 的码位是 21608，而在 GBK 的码位是 55004，通过去查 GBK 码位 21608 对应的字符就不是 「周」这个字了。\n现在互联网的主流都是使用 UTF-8 编码，GBK 只适合给国人使用的网站上，局限性太大。\n简单的测试\n测试 1：一份用 UTF-16 编码的全英文文本，更改编码方式为 UTF-8，存储占用会减少吗？答案是会，因为 UTF-16对英文用两个字节编码，而 UTF-8 中英文属于第一分区，因此占用一个字节，所以改为 UTF-8 之后差不多减少一半的空间占用。\n测试 2：一份用 UTF-8 编码的全汉字文本，更改编码方式为 UTF-16，和 GBK，存储占用会发生什么变化？答案是都会减少占用，GBK 对中文是两个字节编码，UTF-16 对大多数中文也是两个字节编码，而 UTF-8 对中文是 3 个字节编码，因此占用会减少。\n一些小感悟\n写这篇博客的时候，遇到很多问题，本来只是想写 UTF-8 和 Unicode 的，越往下写的时候发现还有很多东西没有掌握，因此一边消化（幸运的是消化难度还能接收），一边写了这篇博客，终于是把字符，乱码相关的搞明白了。\n当我感叹 UTF-8 编解码算法的时候，搜了下发明者 Ken Thompson，这么多优秀的作品都与他有莫大的关联，Unix，正则，UTF-8，以及现在火热的 Go 语言，还获得图灵奖，我也只能顶礼膜拜。了解的越多，发现了计算机领域基本上所有伟大的东西，都是那么一小撮人发明的。如图是 Ken Thompson 相关的简介，想具体了解可以去维基百科搜索。\n"},"Spaces/Resources/博客/技术类/字节码加载与执行":{"title":"字节码加载与执行","links":[],"tags":["字节码","Java"],"content":"字节码\n字节码是高级语言和 JVM 通信的桥梁，高级语言只做一件事：把代码编译成字节码。因此，完全可以编写一套自己的编程语言，定义他的语法规则，然后将实现一个编译器，将代码转为字节码即可。\n来看看 Java 中的字节码长什么样子，源代码如下：\npackage com.greek.shop;\nimport org.junit.jupiter.api.Test;\nclass ShopApplicationTests {\n \n    @Test\n    void test() {\n        int i = 0;\n        System.out.println(i);\n    }\n}\n编译之后部分字节码如下：\n\n图中的字节码，正在一行行地执行指令，这些指令作用可以参考 Java 字节码指令表。\n不知你是否察觉，我们可以直接编写字节码，而不再需要高级语言编译成字节码，这当然是可行的，因为我们熟知的「动态代理」就是这么做的。\n字节码加载\n编译器把高级语言编译成字节码文件，那么 JVM 又是怎么加载和执行字节码的呢？\n不知你注意到没，在使用 IDE 运行程序时，好像只要点击绿色箭头代码就可以运行了。IDE 好像有魔力一般，但实际上那个绿色箭头只是在后台「偷摸」地拼接一个命令行，启动一个 JVM ，仅此而已。\n你可以通过控制台查看到 IDE 帮你拼接的命令行，命令行中有一个参数 “-classpath”，这个 classpath 就指明了 JVM 加载字节码路径。想更多了解 Java 启动命令相关知识，可以参考我之前写的博客。\n使用 classpath 指明了加载路径，于是 JVM 便使用类加载器 (ClassLoader) 加载字节码。\n类加载器只有一个作用，负责加载字节码文件，仅此而已。他也支持动态加载代码，动态生成代码等，用一段代码简单演示动态加载代码过程。\n   \t\tScanner scanner = new Scanner(System.in);\n        String version = scanner.next();\n \n        File jar = new File(&quot;fastjson-&quot; + version + &quot;.jar&quot;);\n        if (jar.exists()) {\n            \n            ClassLoader classLoader = new URLClassLoader(new URL[]{jar.toURI().toURL()});\n            Class fastJson = classLoader.loadClass(&quot;com.alibaba.fastjson.JSON&quot;);\n            System.out.println(fastJson.getField(&quot;VERSION&quot;).get(null));\n        } else {\n            System.out.println(jar.getName() + &quot; Not Found!&quot;);\n        }\n上诉代码在项目中没有引入任何依赖和 Jar 包，只是在项目根目录中放了两个不同版本的  FastJson jar 包。用户输入 FastJson 版本，类加载器去加载对应的 jar 包，获取成功打印 jar 包的版本信息，这就是个简单的动态加载过程。\n上诉代码可以让 ClassLoader 加载指定版本的 jar 包，其实热部署的原理也类似于此。通过监听器监听对应的文件或文件夹，倘若发生改变，则调用自定义的 ClassLoader 进行重新加载，达到热部署的目的。\n当然类加载器的场景还存在 Mock ，AOP 中，使用过 Mockito 或者 AOP 就会知道，他们都是通过字节码增强的方式生成目标对象的子类，然后交给 JVM 执行。\n双亲委派加载模型\n由于 ClassLoader 只负责加载字节码，因此完全有可能，编写一个恶意的字节码文件，让 ClassLoader 去加载执行它，破环我们的程序。为了程序的安全性，于是就有了**「双亲委派加载模型」**。\n在 Java 8 及之前的双亲委派加载模型如图：\n\n通过图中的关系，可以发现 JVM 的启动不止有一个类加载器，而是有三个。这三个类加载器各司其职，分工明确，且三个类加载器都是继承关系。\n\nApplication ClassLoader （应用类加载器） 是负责加载 classpath 里面的包，即我们编写好的代码，该加载器继承 Extension ClassLoader。\nExtension ClassLoader （扩展类加载器） 负责加载与运行程序相关的 jar 包，像使用的 ArrayList，Object 等等，该类加载器继承 Bootstrap ClassLoader。\nBootstrap ClassLoader（启动类加载器) 负责加载 JVM 启动时至关重要的包。\n\n双亲委派加载模型简单描述就是：子加载器加载类之前，需要先去询问父加载器，如果父加载器不为空且找到该类，则直接返回，否则子加载器才去加载。\n在这个过程中你发现了吗？越核心的类都是由父加载器去加载的，这样在一定程度上保存了程序的安全。倘若你伪造一个 java.lang.Object 类，想让类加载器去加载该 Object 类，这是做不到的。当 Application ClassLoader 去加载伪造的 Object 时，就会先去询问父加载器是否加载该类，显然该 Object 类已经被 Extension ClassLoader 加载，只不过加载的 Object 并非你伪造的 Object，因此你伪造的 Object 并不会被加载。\n神奇的类\n自定义一个 ClassLoader 并且实现了 loadClass 方法，如果加载的类名字为 BadClass 则使用自定义的类加载器去加载，否则由父加载器加载。然后将加载好的 BadClass 字节码文件，实例化一个 BadClass 对象。详细代码如下：\npackage com.greek;\n \nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\n \npublic class MyClassLoader extends ClassLoader {\n    public static void main(String[] args) throws Exception {\n        BadClass bad = (BadClass) new MyClassLoader().loadClass(BadClass.class.getName()).newInstance();\n    }\n \n    @Override\n    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {\n        if (name.contains(&quot;BadClass&quot;)) {\n            try {\n                byte[] bytes = Files.readAllBytes(new File(&quot;target/classes/com/greek/BadClass.class&quot;).toPath());\n                return defineClass(name, bytes, 0, bytes.length);\n            } catch (IOException e) {\n                e.printStackTrace();\n                throw new ClassNotFoundException(&quot;Class &quot; + name + &quot; Not Found!&quot;);\n            }\n        } else {\n            return super.loadClass(name);\n        }\n    }\n}\n当你运行这段代码时，你会发现竟然报错了，在我的控制台中错误信息如下：\n\n什么？两个相同的类包名也完全一样，竟然不能互转，，真是令人大跌眼镜。\n那么为什么会这样呢？这是因为这两个 BadClass，不是由同一个类加载器加载的。BadClass 在 JVM 中是由 Application ClassLoader 加载的，上面的代码使用 MyClassLoader 覆盖 loadClass 逻辑，主动去加载 BadClass 并用加载的字节码实例化一个 BadClass 对象，但由于声明的对象和实例化的对象并非相同的类加载器加载的，就会导致类型转换异常。\n同样的在 Java 的 instanceof 方法，类加载器也会被检查，若不是同一个类加载器加载的类，则 instanceof 判断为 false，代码如下：\n        Object badClass =  new MyClassLoader().loadClass(BadClass.class.getName()).newInstance();\n        System.out.println(badClass instanceof BadClass);\nJIT Compiler\n有了类加载器加载字节码，还需要将字节码「翻译」成对应平台的指令。这个「翻译」过程由两种方式：编译执行和解释执行。\n解释执行就是每执行一行就把该行翻译成机器指令，类似于「同声传译」。自然他会比较慢，因为每次执行都需要一个转换的过程，但是它对于跨平台是很方便的，因为，不用操心平台是否能看懂字节码，只需要带个同声传译的翻译即可。\n编译执行就是把要翻译的内容，提前翻译好，然后直接给到平台。这样的好处是执行快，平台不用等你翻译，它直接拿翻译好的文件阅读即可。缺点也很明显，就是不灵活，在 Windows 平台运行，要提前翻译成 Windows 的指令，在 Liunx 平台运行，又要翻译成 Liunx 的指令，且翻译后的文件都比较臃肿。\n那么 HotSpot 是用的那种方式呢？\n答案是混合模式，它既不想丢失解释执行的便利性，也不想失去编译执行的速度，所以采取了折中的方案。他把一些常用的方法采用编译执行编译好，以提升执行的代码执行速度，其他的则采用解释执行。\nJIT Compiler 全称是 Just In Time Compiler（即时编译器），HotSpot 就是使用该编译器动态地发现 JVM 运行时的热点，然后针对这些热点编译成相应的 native code ，提高运行效率。\n小结\n至此，字节码的加载与执行过程已经结束了，他的神秘面纱也被揭开。\n高级语言通过编译器编译成字节码，JVM 使用类加载器去加载字节码。字节码存在安全性问题，因此 JVM 采用双亲委派机制去加载字节码。又因为每次执行都需要将字节码编译成机器指令，效率并不高，因此采用了即时编译 JIT 技术，这样既保证了效率又保证了跨平台性。\n纵观整个过程发现，编程语言到可以执行的机器指令，经历了不止一次编译过程。把从高级语言到字节码的过程称为编译前端。 从字节码到机器指令的过程称为编译后端。 两个端各司其职，互不干扰，都是通过字节码这个「中介」交流。"},"Spaces/Resources/博客/技术类/布隆过滤器":{"title":"布隆过滤器","links":[],"tags":["布隆过滤器"],"content":"\n问题场景：给定一组文章 id 列表，如何判断文章 a 的 id 在给定的列表中？\n\n我们很容易使用列表、数组、哈希表等将文章 id 先保存起来，判断重复时，直接遍历数组、列表、根据哈希值判断等。\n上面的解决方式，最好的无疑是哈希表。哈希表检索时间复杂度为 O(1)，但是这只限于没有发生哈希冲突的情况下，而且数据量一旦比较大，存储占用也会大大增加，会导致检索性能大大下降。\n对于数据量较大的场景，如何快速检索元素是否包含在另一个集合中，这就引出今天的主角了「布隆过滤器」。\n简介\n\n布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难\n\n简介引用自维基百科，里面有两个概念「二进制向量」，「映射函数」。\n二进制向量就是一堆 bit(位) 的集合，bit 我们都知道就是只能表示 0 和 1。其实我们常使用的 int 有 32 位，因此他也可以看做一个二进制向量。\n下面是一个简单的示例，每一个空格就代表一个 bit，下面的数字表示它的索引：\n\n映射函数我们其实很并不陌生。使用过 HashMap 就应该知道，对 key 使用 hashCode 方法，计算哈希值，这个 hashCode 方法就是一个映射函数，一个 key 只能对应一个哈希值。\n布隆过滤器对一个 key 使用多个映射函数，得到多个值。\n哈希函数映射\n\n布隆过滤器中映射函数\n\n原理\n了解一些基本概念之后，布隆过滤器的原理就很明了了。\n布隆过滤器对于要保存的值使用一系列随机的映射函数，得到二进制向量下标，然后把对应的 bit 置为 1，就是这么简单。\n例如，字符串 “zzh”，经过三个随机的映射函数，对应的下标为 2，7，11 因此对应的 bit 为 1。\n\n我们可以对要插入到的字符串应用同样的哈希函数，然后看二进制向量里对应的bit 是否全为 1 来判断一个元素是否在集合里。\n如果是，则该元素可能在里面，注意是可能。 因为这些位置有可能是由其他元素或者其他元素的组合所引起的，这也就导致了布隆过滤器的误识别率。\n如果不是，则表示该元素一定不在集合中。\n缺点\n我更习惯在介绍一个功能的时候，先把他的缺点说出来，知道缺点的话，后续就可以大胆的应用。\n误识别率\n插入字符串 “zzh” 得到下标 2、7、11\n\n插入字符串 “greek” 得到下标 5、8、9\n\n插入字符串 “gem” 得到下标 2、5、8\n\n可以看到 “gem” 得到的下标对应的 bit 都已经为 1，但是该字符串并不在集合中，这就是布隆过滤器的误识别率。\n删除困难\n删除困难的原因和误识别率是如出一辙。例如我们只想把 “gem” 字符串删除，于是把下标为 2、5、8 的 bit 都置为 0，这样的话 “greek” 和 “zzh” 部分数据就被删除了。无法保证删除的下标影响到其他元素，这就是布隆过滤器删除困难的原因。\n我们也很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。但是这样根本不可行，因为连一个元素是否在集合中都无法百分百保证，又何来的把这个元素删除呢？就好比你想能为开源世界大牛，现在却连 GitHub 都无法保证访问一样。\n规避手段\n识别率和删除困难虽然都是缺点，但都是可以通过一些手段去规避。\n假设在布隆过滤器里面有 k 个映射函数, m 个比特, 以及 n 个已插入元素，那么该过滤器误判率近似于：(1-e-kn/m)k 。因此我们可以通过调整映射函数数量和布隆过滤器的大小来降低误判率。\n对于应该使用多少个映射函数，国外的一篇博客给了较好的答案，引用部分为原文内容，详情点击\n\n对于给定的 m 和 n ，有一个函数可以帮我们确定最优的 k 值: (m/n)ln(2)\n所以可以通过以下的步骤来确定 Bloom filter 的大小:\n\n确定 n 的变动范围\n选定 m 的值\n计算 k 的最优值\n对于给定的_n_, m, and _k_计算错误率。如果这个错误率不能接收，那么回到第二步，否则结束\n\n\n事实上，已经存在许多布隆过滤器变种，他们使用更好的映射函数、支持删除元素、更低的误判率等等。维基百科上记录了 60 多种布隆过滤器的变体。例如：布谷鸟过滤器、布卢姆过滤器、等等，他们相比原始的布隆过滤器往往有更强的特性，详情访问wiki\n优点\n查询效率和插入效率高，时间复杂度为 O(k) ，k 为映射函数的数量。因为你每次查询或者插入一个元素时，都是通过 k 个函数计算对于的 bit 下标，然后检查对应的 bit 位是否为 1 或者将 bit 位置位 1。\n空间效率。布隆过滤器的空间效率取决于你期望的误判率，期望的误判率越小，所需的空间就要更大，因此无法具体量化。我们可以简单的和 HashMap 做个对比。\n假设 HashMap 和布隆过滤器都保存字符串 “zzh”，且布隆过滤器使用 3 个映射函数。HashMap 仅保存这个字符串需要 6 个字节，即 48 bit，而布隆过滤器只需要 3 个 bit。\n一些应用场景：URL 黑名单判断、垃圾邮箱判断、弱密码检测、比特币钱包同步等等。"},"Spaces/Resources/博客/技术类/操蛋的-Git":{"title":"操蛋的 Git","links":[],"tags":["Git"],"content":"Git 中的一些抓狂经历，平时遇不到，一遇到就很操蛋。\n\n部分参考：Oh Shit, Git  git-flight-rules\n\nbranch\n本地分支太多了，老子要删掉。\n# 看一眼本地有哪些分支\ngit branch \n \n# 删掉本地对应分支\ngit branch -d &lt;本地分支名&gt;\n远程分支有点多余，老子要删掉。\n# 看一眼远程有哪些分支\ngit branch -r\n \n# 删掉远程对应分支\ngit push origin --delete &lt;远程分支名&gt;\n要从远程分支 checkout 一个新分支\n# 常规写法\ngit checkout -b &lt;本地分支名&gt; &lt;远程分支名&gt;\n \n或\n \n# 简写\ngit checkout --track &lt;远程分支名&gt;\n老子忘记当前分支是基于哪个分支创建的了\ngit reflog show &lt;分支名&gt;\ncommit\n老子提交信息打错了，要把提交信息改一下\n# 输入命令根据提示修改提交信息\ngit commit --amend\n老子提交之后（还未 push），发现还有东西忘记提交了\n# 正常 add\ngit add &lt;忘记提交的文件路径&gt;\n \n# 把这次提交合并到最新的一次提交中\ngit commit --amend --no-edit\n靠，点错了。这个文件不应该提交，撤回这次提交（未 push）\n# 本质上是让 head 指针指向上一次提交\ngit reset --soft HEAD@{1}\n \n或\n \n# 让 head 指针指向上一次的 commit \ngit reset --soft &lt;commit id&gt;\nreset\n我要让当前分支恢复成最初的样子\n# 重置当前分支到的最近的一次提交\ngit reset HEAD --hard\n \n# 重置当前分支到的远程分支的最新一次提交\ngit reset &lt;远程分支名&gt; --hard\n我要把文件移出暂存区\ngit reset head --mixed \n \n或\n \ngit reset head\nmerge\n靠，merge 错分支了，我要恢复 merge 前的状态\n# ORIG_HEAD 变量保存了 merge 前的 HEAD 变量\ngit reset --hard ORIG_HEAD\ncherry-pick\n\n\n摘樱桃，把一次或多次 commit 应用到当前分支\n\n\noh shit! 最新的提交解决了一个历史 bug，其他分支代码也要修改这个 bug。\n# 应用场景：假设已修复 bug 的分支是 bug-fix，需要修改 bug 的分支是 release-1.0\n \n# 1.切换到需要修改 bug 的分支\ngit checkout release-1.0\n \n# 2.使用 cherry-pick\ngit cherry-pick &lt;bug 修复的 commit id&gt;\n \n或\n \ngit cherry-pick bug-fix\nrevert\n\n\n用于撤销历史的某次更改，例如：bug 或者功能\n回滚某次发布\n\n\n产品加了个没卵用的功能，现在要上线，这个功能还要不要？\n# 不上线该功能：把该功能对应的 commit id 并 revert,之后会产生一个新 revert 提交。\ngit revert &lt;commit id&gt;\n \n# 最终还是决定要上: 只需对 revert 提交进行 revert\ngit revert &lt;revert 提交的 commit id&gt;\nstash\n我要把改动文件暂存起来，不想提交这些文件\n# 给改动存储\ngit stash\n \n或\n \n# 给改动取名并存储\ngit stash save &lt;自定义名称&gt;\n忘记了 stash 中存储了哪些改动\n# 列举所有的 stash 信息\ngit stash list\n我要取出改动，应用到 feature 分支\n# 切换到 feature 分支，把改动取出应用到 feature 分支并自动删除 stash\n# 命令末尾加 &lt;stash id&gt; 应用指定的 stash \ngit stash pop\n \n或\n \n# 把改动取出应用到 feature 分支,stash 不会删除\n# 命令末尾加 &lt;stash id&gt; 应用指定的 stash \ngit stash apply\n老子要手动删除 stash 信息\n# 删除全部的 stash 信息\ngit stash clear\n \n# 删除指定的 stash 信息\ngit stash drop &lt;stash id&gt;\ntag\n我去，tag 怎么用啊，老板跟我说打个 tag\n# 创建 tag\ngit tag &lt;标签名&gt;\n \n# 将创建的 tag 推到远程仓库\ngit push origin &lt;标签名&gt;\n \n丢，手抖打错了 tag 名称，怎么删了这个 tag 啊\n# 删除本地 tag\ngit tag -d &lt;标签名&gt;\n \n# 删除远程仓库中的 tag\ngit push --delete origin &lt;标签名&gt;\nlog\n嗨，忘记上次提交改了哪些文件\n# 查看每次提交文件\ngit log --name-only \n \n或\n \n# 查看每次提交的文件，以及对文件进行的操作\ngit log --name-status\n "},"Spaces/Resources/博客/技术类/文件与-IO":{"title":"文件与 IO","links":[],"tags":["IO"],"content":"流\n1.I/O流是什么?\n对于陌生的东西，最好通过类比的方法去了解。我对于流的理解：流就是一系列数据。通过生活中常见的现象进行类比，比如：流中全部是水，我们称为“水流”，流中全是电子，我们称为“电流”。那我们可以根据流中的数据类型，来给流命名。再回到计算中，流中是字节的我们叫“字节流”，是字符的叫“字符流”，等等。\n对于笔者来说，在Java开发中需要用到获取文件信息，经常需要用到流。那个时候不理解流，只知道抄着代码，这里改改那里修修。以至于，每当需要操作文件的时候不知道如何开始下手，对于整个流程不清楚。每当去百度文件操作的时候，又发现很多种实现方法，用的流都不一样，实现起来也有细微差别，搞得笔者也是心态爆炸，于是下决心把这块内容梳理好，方便以后使用。\n关于这部分内容目前存在以下几个问题：\n\n如何理解文件在流中的角色？\n文件操作的整个流程？\n文件操作选用什么流？\n不同的流的差异与特点\n\n流的一些补充: 上面粗略解释了流，现在需要对流进行一个补充。我们说的电流和水流都是从一端流向另一端（可能并不是很准确），比如：电池的电子从负极流向正极，电池的负极像一个电子的生产者一样，而正极就像一个消费者或者接收者一般；还有地下水到你家的水龙头一样，地下水通过加工提取到人引用。通过这两个例子，可以得出一个结论，流的操作或者使用至少需要一个生产对象和一个接受对象。在计算机世界中已经为这两个对象命名，输入对象和输出对象。\n2.流的分类\n关于流的分类，在Java中有如下3种分类标准：\n\n按照流的流向分，可以分为输入流和输出流。\n按照操作单元划分，可以分为字节流和字符流。\n按照流的角色划分，可以分为节点流和处理流\n\n流的分类解读：\n\n根据流向分类：在上面的内容补充中，说流都是从一端流向另一端，说明了流有方向。所以根据流的方向可以分为输入流和输出流，辨别输入流和输出流需要选参照中心。我们以程序作为参照中心，读取本地磁盘上的文件，程序端接收，就说明该是输入流；将程序产生的数据保存到磁盘，程序段输出，就说明是输出流。在Java中所有的IO流的类都是从以下4个抽象类基类中派生出来的：InputStream/Reader所有输入流的基类，前者是字节输入流，后者是字符输入流；OutputStream/Writer所有输出流的基类，前者是字节输出流，后者是字符输出流\n根据操作单元划分：首先需要理解什么是操作单元，我把他理解为所操作数据的最小单位。我们知道一个字符等于两个字节，字节流取数据按照一个一个字节取，字符流取数据就是一个字符一个字符取。就好比，我们用调羹喝汤，一调羹的量就好比字节，而用勺子喝汤，一勺子的量就好比字符，只不过一勺子比一调羹的量多很多，而字符是一个字节的两倍。\n根据流的角色划分：节点流和处理流。节点流：可以从一个特定的数据源(称作节点)读写数据，如：内存，硬盘，文件等。处理流：可以理解为，根据实际需求在节点流的基础上进行的二次开发和封装。\n\n 例子1：说明处理流和节点流的关系：想象一个场景，计算机每一次读写的时候都访问硬盘，如果访问次数很频繁的话，性能表现就不佳，而且硬盘的寿命也会减少。所以为了满足这种场景，就设计了缓存流，一次读取较多数据到缓存中，以后的每一次读取都从缓存中访问，直到缓存中的数据读取完毕。用一个生活的例子解释缓存流，吃饭的时候我们不用碗装饭(缓存流)的话，每吃一口都要去电饭锅里面铲，有了碗(缓存流)之后，我们可以把饭装进碗里，吃完了碗里的，我们再去电饭锅里铲。这样就大大减少了去电饭锅里装饭的次数，提高了效率。\n 例子2：因为我们的流的操作最小单位是字节或者字符，为了方便Java程序员使用对象，我们就需要在原来节点流的基础上进行二次开发和封装。比如我们读取一个本地的文本文件，需要一个字节流，又由于流里面是字节，而我们希望方便程序员使用对象来保存这些数据，就在该流的基础上进行开发(具体如何实现，本人暂时也不清楚)，原来的字节流就变成了一个对象流，流里面的内容不在是字节，而是对象，这样就方便了程序员对于该信息的获取。\n以下是关于字节流和字符流，以及节点流和处理流的详细分类图\n\n\n3.关于字符流和字节流的选择\n之前在学校做课设的时候，每次做到文件关于文件读取的时候，关于选择字节流还是字符流的选择都是含糊不清，每次都是去网上找代码，这部分知识不是很清楚。现在重新把知识捡起来好好梳理一遍。首先不管是文件读写还是网络发送接收，信息的最小存储的单位是字节。由此可能读者又会问了，既然最小存储单元是字节，那么有了字节流为什么还要字符流呢?\n解答: 在编程领域中，由于语言的不同，中文等一些其他语言一个字就需要两个字节表示，即一个字符，所以如果不使用字符流的话，就会出现乱码等问题。在日常使用中遇到图片，音频等媒体文件采用字节流比较好，而涉及到字符操作的使用字符流比较好。\n使用文件对象\n说明： 一个File对象就是一个具体的文件或者文件夹目录（作用：指定文件或文件夹保存的路径）。让然，指定的文件或文件夹目录在电脑上不一定存在。以下代码演示了文件对象的用法以及常用的方法。\n//创建一个文件对象，指定他的目录：D盘目录下的java文件夹\nFile file = new File(&quot;D:\\\\java\\\\test&quot;);\n \nboolean exists()  //判断文件或者文件夹是否存在\nboolean isDirectory()  //判断是否是文件夹\nboolean isFile()  //判断是否是文件\n \nlong length()  //获取文件的长度\nlong lastModified() //获取文件最后修改时间\nboolean setLastModified(long time)  //设置文件最后修改时间\nboolean renameTo(File dest)  //文件重命名\n    \n注：renameto方法重新命名，指的是在磁盘上文件&quot;1.txt&quot;变成&quot;2.txt&quot;但是通过file.getName()获得的文件名还是“1.txt”,无论是命名前还是命名后。\n \nString[] list()  // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹)\nFile[] listFiles() // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）\n      \nString getParent()   // 以字符串形式返回当前文件所在文件夹\nFile getParentFile() // 以文件形式返回当前文件所在文件夹\n \nboolean mkdir()    // 创建文件夹，如果父文件夹不存在，创建就无效。举例：使用第一行的file对象，如果D盘\t\t\t\t   // 根目录下没有java文件夹,则目录创建失败，java目录，test目录都没有创建。\n    \t\t\t\t\nboolean mkdirs()   // 创建文件夹，如果父文件夹不存在，就会创建父文件夹。举例：如果D盘根目录下没有java\t\t\t\t   // 文件夹,就会连同java文件夹一并创建，java目录和test目录都创建成功。 \n \nboolean createNewFile()  // 创建一个空文件,如果父文件夹不存在，就会抛出异常。\n \n/*\n\t由于创建文件，父文件夹不存在就会抛出异常，所以创建文件的时候需要先创建父文件夹。使用上面提到的方法创建文件夹。例如:file.getParentFile().mkdirs();\n*/\nFile[] listRoots()  // 列出电脑上所有的盘符c: d: e: 等等\nboolean delete()    //删除文件或者文件夹\nvoid deleteOnExit() // JVM结束的时候，刪除文件，常用于临时文件的删除\n流与文件\n       在做课设的时候经常会遇到文件的读取等功能，在还没弄清楚流的时候就已经强迫使用文件操作，导致每次遇到文件读取问题都是网上copy类似代码，却不能很好的理解代码执行流程，或者理解了也很快就忘记了，因为这个记忆点并不深。所以现在打算简单的梳理下文件的读取操作。\n       开始之前，我们需要思考下几个问题：1.先要搞清楚”流向”，我们把我们的程序作为参照物，我们的程序是要读取文件还是写入文件？2.是哪个文件？(即文件所在的位置)3.根据文件的类型，我们该选用什么类型的流？通过思考这几个问题，使得我们对于文件的读取流程就会很清晰了。\n\n假设我们程序需要读取D盘根目录下的zzf.txt文本文件,通过使用File构建一个对象file,并告诉我们的程序文件位于D:\\\\zzf.txt\n\nFile file = new File(&quot;D:\\\\zzf.txt&quot;);\n\n告诉程序文件的位置之后，我们就需要构建一个流了。让文件数据通过流，流向程序。构建流的时候我们又需要考虑了，是输入流还是输出流，显然我们在流的章节中说道，数据是流向程序，所以我们要选用输入流。选用输入流之后还要思考,是要字节流还是字符流呢?这个问题我们要确定文件类型，显然我们这里是文本类型的，对于文本前面也提到了最好使用字符流，防止文本里面有中文字符。所以综合来说我们选用字符输入流\n\n/*\n*try后面加括号是Java7中的技术，这样的好处是：把流定义在try()里,try,catch或者finally结束的时候，会自\n*动关闭流。这样就不要像以前一样，需要自己写代码关闭了。\n* 1.首先我们要使用上面生成的文件对象file，用来构建一个输入字符流fis。\n*/\ntry (FileReader fis = new FileReader(file)) {\n//2.因为我们选用的是字符流，所以我们新建一个字符数组用来保存流中的数据，数组长度就是文件的长度\n    char[] content = new char[(int) file.length()];\n//3.使用read方法把流中的数据全部保存到content字符数组中。\n    fis.read(content);\n} catch (IOException e) {\n    e.printStackTrace();\n     }\n\n通过上面的步骤，我们就完成了把D盘目录下的zzf.txt文件内容保存到了content数组中，接下来我们可以\t   对这个数组进行很多操作，比如将数据写入一个txt文件等等。\n继续完善我们的操作，我们把刚才读取的文件数据重新写入到一个新的文件中。根据步骤2中关于选择流的思考，这里我们同样需要思考，流的选择。在了解步骤2的基础下，我们可以快速的得出，我们是需要一个字符输出流\n\n\tFile file = new File(&quot;D:\\\\zzf.txt&quot;);\n//这里我们告诉程序，我们的文件是D盘根目录下的zz.txt文件\n\tFile file1 = new File(&quot;D:\\\\zz.txt&quot;);\n//通过file1对象构建字符输出流\n    try (FileReader fis = new FileReader(file);FileWriter fileWriter = new FileWriter(file1)) {\n            char[] content = new char[(int) file.length()];\n            fis.read(content);\n//将从zzf.txt文件中读取保存的数据content，写入到新文件zz.txt中\n            fileWriter.write(content);\n \n     } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n这样我们就简单的实现了一个文件的读取。有人或许会问，你前面说的节点流和处理流你咋没     用到呢？其实回去看第一部分,再仔细分析的话我们这个字符输入输出流就是一个节点流,所       以我们可以把效率提高一点,在这个基础上我们使用缓存流。\n加上缓存流，提高效率。前面也说了处理流是在节点流上进行二次开发和封装的，所以用到处理流肯定就需要节点流。就像通过文件对象构建流一样，处理流通过节点流来进行构建。\n\n \t\tFile file = new File(&quot;D:\\\\zzf.txt&quot;);\n        File file1 = new File(&quot;D:\\\\zz.txt&quot;);\n        try (FileReader fis = new FileReader(file);FileWriter fileWriter = new FileWriter(file1)) {\n            char[] content = new char[(int) file.length()];\n            //使用节点流FileReader对象构建处理流BufferedReader\n            BufferedReader bufferedReader = new BufferedReader(fis);\n            //读取文件数据\n            bufferedReader.read(content);\n\t\t\t//使用节点流FileWriter对象构建处理流BufferedWriter\n            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n            //写入文件数据\n            bufferedWriter.write(content);\n            //有的时候，需要立即把数据写入到文件，而不是等缓存满了才写出去,这时候就需要用到flush\n            bufferedWriter.flush();\n \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n注意事项:\n\n我们使用流的时候一般都是需要手动关闭的，上面的代码都没有写出关闭的代码，是因为我们把流的构建这一步写进了try()里面，所以不需要手动关闭代码，自己写的话，要么和我代码一样，要么就在流使用完之后就写一行代码关闭流。\n还有一个大家可能没有考虑到的情况，我们刚才使用了缓冲流之后，如果手动关闭的话是不是需要关闭两个流呢？实际上，我们只需要关闭节点流就行了，因为处理流是在节点流的基础上构建的，我们关闭了节点流，处理流就失去了节点流，就会自动销毁。\n最后说一个关于缓存流写入的问题，因为缓存流是有缓存空间的，只有缓存空间满了，缓存空间的数据才会写入到文件中。通过查看源代码发现默认设置的缓存空间是8kb。因此，当你使用缓存流读取文件的时候，如果文件大小小于8kb,没有使用flush方法的话，要写入的文件就没有数据，因为数据都在缓存区中。我们使用flush方法就可以将缓存区的数据强制写入到文件中，无论缓冲区的数据大小。\n\n\n"},"Spaces/Resources/博客/技术类/浅析-URL":{"title":"浅析URL","links":[],"tags":["web"],"content":"IP\nip 主要约定了两件事：如何定位一台设备？如何封装数据报文，以跟其他设备交流？\n只要我们处在互联网中我们就至少有一个独特的 IP\n内网与外网 IP\n当我们通过家里的路由器进行上网时，实际上网络返回的请求是先到路由器，路由器再转发给我们的设备，路由器就充当我们与外界网络交互的工具。路由器分配给我们设备的 IP 就是内网 IP，一般来说这个 IP 格式都是 192.168.xxx.xxx 。内网中的设备都可以相互访问。而外网 IP 就是电信/联通之类的运营商给你分配的 IP，只要路由器连上网就会有一个外网 IP。这个外网 IP 不是固定的，当我们重启路由器和光猫，得到的 IP 很有可能就会不一样\n几个特殊的 IP\n\n127.0.0.1 表示自己\nlocalhost 通过 hosts 指定为自己\n\n可以通过修改 hosts 文件将自己定义的名称指定为 自己 ，例如：可以将 zzf 指定为自己\n\n\n0.0.0.0 不表示任何设备\n\n端口 port\n我们已经知道一台机器的 IP，但是还不能访问它，我们还需要端口。\n一台机器可以提供多种服务，并且每个服务都对应一个号码，这个号码就是我们所说的端口。\n一个简单的比喻\n麦当劳提供两个窗口，一号快餐，二号咖啡。当我们去一号窗口点咖啡，会被拒绝，让你去二号点咖啡。去咖啡窗口点快餐也是一样。\n一台机器可以提供多种服务\n\nHTTP 服务默认 80 端口\nHTTPS 服务默认 443 端口\nFTP 服务默认 21 端口\n一共有 65535 个端口\n\n要只要应该用什么端口，可以去维基百科搜索，他会告诉你每个端口该做什么。\n规则\n\n0~1023 端口是留给系统使用的\n只有拥有管理员权限才能使用这预留个系统的端口\n其他端口可以给普通用户使用\n\n更多端口的详细信息，可以访问链接\n域名\n知道 IP 和端口之后，可以正确的享受相应的 服务 了。但是，我们每次都通过 IP 和端口去访问很麻烦，毕竟IP 这串数字太难记了。因此，域名诞生了，域名就是对 IP 的别称。\n我们访问百度的 IP，就不用找它的 IP了，可以直接使用 baidu.com 来替代。我们也可以使用 ping badu.com 命令，根据域名获取到它对应的 IP。\n知识点\n\n一个域名可以对应不同的 IP，这样是负载均衡，防止一台机器扛不住\n一个 IP 也可以对应不同的域名，这个叫做共享主机，穷开发者才会这样做\n\nDNS\n域名和 IP 的关系是如何绑定起来的呢？这个就要靠 DNS 了，它相当于过去的电话本，你要找「张三」的手机号码，就需要找到「张三」这个人，手机号码也同时找到了。\n我们默认使用的 DNS 就是电信/联通之类的运营商为我们提供的，我们也可以自己修改 DNS。\n**过程：**当我们使用浏览器访问 baidu.com ，DNS 会返回它对应的 IP，然后浏览器向对应的 IP 的 80/443 端口发送请求，然后返回百度首页的内容。\n获取网页内容规则\n\n我们可以通过改变访问地址路径做到，获取不同的内容，假设有该 zzf.com  域名\n\nzzf.com/docs 获取文档内容\nzzf.com/images 获取图片内容\n\n\n根据修改参数可以达到，同一页面不同内容\n\nwww.baidu.com/s \nwww.baidu.com/s \n\n\n可以使用锚点做到，同一内容不同位置\n\nzzf.com#教程 ，定位到该页面的「教程」位置\nzzf.com#参考书 ，定位到该页面的「参考书」位置\n\n\n\n注意事项：虽然锚点是在请求地址中的，但是锚点不会传给服务器。\ncurl 命令\n\ncurl -v baidu.com 输出通信的整个过程，包括获取 IP，建立 tcp 连接，发送请求，响应内容，关闭 tcp 链接，结束访问。\n\n更详细的使用规则可以访问链接"},"Spaces/Resources/博客/技术类/线程解惑":{"title":"线程解惑","links":[],"tags":[],"content":"CPU 线程，操作系统线程，Java 线程\nCPU 线程\nCPU 线程是属于硬件的范畴，他在硬件实现上就支持多线程。每个 CPU 都具有多个核心，并且每个核心都可以处理一个线程。\n但核心和线程的数量并不是 1:1 的，取决于 CPU 具体的架构实现。大多数服务器级别的处理器每个核心都支持多个线程，你经常能听到 8 核心 16 线程诸如此类的说法。\nCPU 的核心就像人的嘴巴，处理的线程就是人的手。手去拿食物（任务），嘴巴开始吃拿到的食物，假如你吃的比手拿的快，理论上你可增加手的数量，即支持更多的线程。\n但实际上，这个是有瓶颈的。当嘴巴还没吃完食物，手上已经拿到食物并等待，这个时候手就只能等嘴巴吃完食物。因此，每个核心处理的线程数量并不是越多越好。\n目前每个 CPU 核心处理的最佳线程数量是 2 个，就像人一样，一张嘴和两只手。\n操作系统线程\n参考资料\n\n维基百科\n\n"},"Spaces/Resources/博客/技术类/计算机原理":{"title":"计算机原理","links":[],"tags":[],"content":"CPU 执行过程（简述）\nCPU 的本质就是一个执行指令的工人。\n上面的概述引发了几个问题，什么是指令？指令从哪里来？CPU 如何执行和加载这些指令？\n指令，顾名思义指示和命令。这个命令和指示的对象是 CPU，CPU 可以明白它的意图，并执行。\n现代 CPU 识别的指令都是由字节码组成，即一长串的 0 和 1。\n还记得远古计算机是如何编写和执行指令的吗？没错，是一条条穿孔的纸带，带孔为 1，无孔为 0。那个时候就是用这种朴素的方式来组成一条条指令。但是现在已经被晶体管代替了。\nCPU 从内存中读取指令，并执行指令内容。指令执行的中间结果会保存到相应的寄存器中。\n\nTips:  像这种指令和数据存储在一起的结构称作 冯·诺伊曼结构\n程序装载与执行\nCPU 能够执行指令，但一般都是给一组指令交给 CPU  去执行。该组指令中可以构成简单的逻辑跳转，例如：C 指令执行成功，则跳转到 F 指令执行，否则跳转到 D 指令。\n程序就是一组指令和数据的集合，在 Windows 中就是我们常见的 exe 文件。\n当我们在电脑中打开多个记事本时，内存中为多个记事本进程开辟了不同的空间，对于每个记事本来说，自己所处和所使用的的内存地址都是一样的，进程之间互不干扰。但是通过「上帝视角」可以发现每个记事本进程只是占用内存的一段空间而已。\nQ: 不同 CPU 架构，为什么不能运行同一个程序 ？\nA: 不同 CPU 架构对于，指令集的理解不同。因此程序需要在不同的 CPU 架构中使用不同的指令集。\nQ: 同 CPU 架构，不同操作系统，不能运行同一个程序 （Linux  和 Windows）？\nA: 同 CPU 架构 对于程序指令集的理解是相同的。\n不同之处在于，系统提供的 API 不同。例如，Windows 提供了 createProcess 方法创建进程，但对应 Liunx 上就不存在该方法。\n不同系统内存布局也不相同，导致装载程序的方式也存在差异。因此，程序跨平台性存在问题。\n解决跨平台\n为了解决跨平台问题，于是在操作系统之上维护了一个虚拟机 JVM。\nJVM 负责把统一的中间语言，转换成对应操作系统的能识别的语言。而这个中间语言之上就是高级语言，像 Java，Python 等。这些高级语言的作用就是把我们编写的代码，编译成中间语言，然后交给 JVM 执行。这也是为什么 Java 和 Python 具有跨平台性。\n但并非所有的语言都需要转化成中间语言，像 Go 编译之后就是 native 的，因此不需要 JVM，直接交给操作系统执行。由于省去了一个 JVM 虚拟机中间操作，因此性能会极大的增强，但跨平台方面就会收到限制，需要对不同操作系统编译。\n动态链接库\n假如所有程序都需要调用一个指令 A，为了避免重复，可以把 A 和一些经常使用的指令封装成库。这样程序中就不需要完整地写入 A 指令，只需要引用 A 指令即可。这样CPU 就会在程序之外去调用 A 指令，完成操作。\n把这个引用库的行为称作「动态链接库」\n这样做的好处显而易见，可以省空间，程序都从一个地方调用执行。还有就是，需要升级的话，只需要升级引用的库即可。\n缺点也很明显，当程序引用的库，找不到时。就会提示「缺少 xxx」，比如一些游戏启动的时候。存在库，但是不兼容也是很要命，例如程序需要 1.0 版本的库，但是系统只有 2.0 的库。程序在刚开始启动可能不会有问题，但是当执行到需要引用 1.0 版本的库命令时，程序就会崩溃。\n程序时分复用\n日常生活中，经常会一边听着歌，一边敲着代码。有没想过，为什么听歌和我写代码可以同时执行？\n这是因为，虽然 CPU 只有一个，他只能按照顺序一个一个执行，但是架不住他快啊。你这一眨眼的功夫，他已经在几个程序中切换执行了很多遍，给你的感觉这几个程序在同时进行，计算执行效率快的离谱。\n时间片\n正如上所说，CPU 会再程序中切换执行，相当于每个程序在轮流占用 CPU 时间，占用的时间称为「时间片」。只有线程和进程能占用 CPU 时间。\n程序进程能占用 CPU 时间，但是并不能一直占用 CPU，否则其他程序便无法继续执行了。当程序的时间片结束了之后，CPU 便往下执行下一个程序的时间片。\n请求慢速设备时，也会例如我们用记事本编写一段文字后，点击「保存」。这个时候需要将我们写的内容存储到磁盘上，由于 IO 操作和 CPU 的执行速度相比实在是太慢了，因此 CPU 并不会傻傻等待 IO 保存，而是继续往下执行下一个指令。\n这可能与你理解的不相符，有的应用程序保存后，会弹出「保存成功」的框，如果 CPU 不等待 IO 的话，那他怎么及时处理这个弹框呢？这就涉及到另一个知识了「中断」。CPU 会对中断请求进行「特殊处理」，当 IO 操作结束后，就会向 CPU 发起一个中断请求，CPU 会放下手头的活，优先处理这个中断请求。\n总结，以下三种情况会放弃 CPU。当前程序的时间片执行完成之后，当需要请求一个慢速设备时（IO 操作），存在中断请求时。\n上下文切换\n当占有 CPU 的程序，时间片到了后，CPU 开始执行下一个程序了。当 CPU 再次执行原来的程序时，他是怎么知道原来的程序执行到哪一步了，换句话说，如何恢复程序执行的状态。\n时间片快要结束时，CPU 会将当前程序的数据，执行步骤等信息保存起来，当再次执行到该程序时，就会加载保存的数据，恢复之前的状态继续执行。和打游戏一样，打着打着，突然被爸妈喊去吃饭，这个时候就要把游戏存档，等下次打开游戏直接读档，继续游戏即可。这个「存档」和「读档」过程，就叫做上下文切换。\n由于 CPU 频繁的切换上下文，这个性能开销虽然对于普通用户感知不到，但是对于 CPU 执行来说确是巨大的。这也是为什么有「用户态线程」的概念，即程序自身去维护内部的线程调度，这样就会大大减少 CPU 上下文切换，这也正是 Go 语言所使用的的协程。"},"Spaces/Resources/博客/生活类/改变身份认同":{"title":"改变身份认同","links":["Spaces/Resources/博客/生活类/财富流---个人觉察"],"tags":["提升"],"content":"工作三年的感悟\n不知不觉，已经出来工作三年了。三年来我也有过很多思考，像：技术能有什么大的突破、优秀的程序员都在干嘛、我以后的生活会更好吗？我以后怎么找到远程工作等等。\n我发现自己的精力都是在思考：作为程序员的我是如何规划自己的未来的。别人常说有职业规划是好事情，但在我身上我却发现这种规划成了束缚自我的枷锁，我更少的关注生活，更少的社交，更少的有突破舒适圈的行为。\n一直到最后我惊奇的发现，我好像什么事情都没有做成，还让自己陷入了内耗深渊。\n最近一两个月来，为了不让自己过多内耗，不让自己受原生家庭自卑的影响，阅读和收藏了一些经典的心里学书籍《不再害羞》《被讨厌的勇气》《当下的力量》，看过油管和 B 站大大小小数百个让你变得更好的自己的视频，所有的点最后都会指向「勇气」。\n「勇气」？当我看《被讨厌的勇气》最后几章的时，作者就提到了勇气，当时就在想可能又是一部理论书籍，因为道理我都懂但真要付诸实践还是算了。这些道理像麻醉剂一样，麻痹着我，我以为只要理解了这些就会变得更好。\n直到一个月前，我开始走出去，我才找到了我的生活。丰富的生活占据着我的精力，平日里莫名紧绷的神经在那一次得到了释放，出来后第一次感受到生活的美好。\n在 10 月 5 号参加的财富流游戏让我有了更多的感悟和思考。一个思考的点就是「身份认同」，我了解完之后发现了这个东西其实一直在影响着我，只是我一直没有察觉到。\n什么是身份认同\n维基百科中是这样定义：\n\n身份认同（英语：self-identity），又称为自我认同，是心理学和社会学的一个概念，指一个人对于自我特性的表现，以及与某一群体之间所共有观念（国籍或者文化）的表现。身份认同的类型大致可分为：拒绝、漂流、搜寻、保卫和坚定。身份与鉴定不同，身份是自我的标签，而鉴定是指一个分类的过程。身份是在心理学上构成一个人（自我身份）或群体（特定的社会类别或社会群体）的特质，信念，个性，相貌和/或表达。身份认同会因历史、文化和政治而改变。对身份进行分类可以是正面的或具有破坏性的\n\n我们每个人都有很多身份，像「儿子」「程序员」「司机」「老板」等等，把自己置身一个场景中，你就会开始诠释这个身份。\n例如：当你在工作中，你会是一个程序员，你就会做你认为程序员该做的事情，学技术，改bug 等等。在家庭中，你是一个儿子，你就会做儿子这个身份该做的事情。\n发现了吗？身份认同在影响着你的行为，甚至让你产成行为依赖，你会慢慢开始理解不了别人做的身份以外的尝试，慢慢你会发展成讥讽，嫉妒等心里。\n所以此时此刻，你需要好好想一想，身份认同给你带来了什么？好的一面是什么？坏的一面又是什么？\n身份认同会给你带来什么\n身份认同在我身上的体现就是，我强烈的认同自己程序员的身份。\n我发现，我做任何事情都喜欢用「程序员」的思维去思考问题，用程序员思维思考没有问题，相反，还能帮我挖掘事情的底层逻辑。\n但是，我发现自己好像只会用「程序员思维」去思考问题，所以看任何事情只有一个角度，这还不是要命的。更要命的是，我没有意识到自己一直以来只使用一种方式来思考，仿佛全世界只剩下这种思考方式。我还曾固执的以为程序员思维是高于其他思维方式的，因此也会拒绝或者是不屑使用其他方式思考，最终一直被「程序员」这个身份裹挟着前进。\n当然，身份认同不是一件坏事，他能让我们有认同感并在该身份下做自我诠释。问题在于不断的在特定身份做自我诠释，你会熟悉这个身份并且越来越依赖这个身份，若你没有独立思考的能力的话，你只会越陷越深。当你不再拥有这个身份时，你会发现自己失去了前进的动力，不知所措。\n因此我们需要身份认同，但也不能太依赖他，需要经常脱离已有的身份，尝试一些新的身份，扮演一些新的角色，这些会带给你很新的思考。世界不能只有一种声音，同样也不能只有一种思考。\n身份认同让我诠释了「程序员」这个职业，帮助我在现在的工作中能够游刃有余。\n但相反的，强烈的认同让我觉得程序员就应该缺少社交、就应该不爱说话、就应该不擅长与人打交道、就应该不太擅长表达和演讲。「就应该」3 个字是多么可怕，让我理所当然的认为自己所做的事情是对的，却毫无察觉到，我已经离「拥有优秀品质的人」这个目标越来越远了。\n如何去改变自己的身份认同\n在做改变之前，你必须得先意识到自己的身份认同，以及想要做改变的决心。身份认同可能会让你产生强烈的依赖，会成为你逃避或害怕改变的枷锁，当你需要跳脱当前身份时，你往往会退缩，然后给自己找借口安慰自己，更进一步强化自己不愿改变身份的意愿。最终自己囚禁在自己编织的茧房里面，越缠越紧。\n我一直都是以「程序员」这个身份自居，甚至会有点引以为傲，对其他行业的事情不太关心，甚至有的时候会有一些鄙视。我也不太清楚自己为什么会有这种行为，我好像很认同自己程序员的身份，后来发现强烈的身份认同是导致我自傲的原因，我决定要改变这种情况。\n说到改变，无一例外都是不舒服甚至是痛苦的过程。理论其实大家都知道，只是真要付诸行动，会发现怯懦无比。因此寻求改变也不能急于求成，需要通过完成一个一个的小挑战，突破一次又一次突破舒适圈，等你积累到战胜困难的自信，在向下一个更大的困难去发起挑战，此时改变已在你的身上悄无声息的发生了。\n小的挑战可以是很多日常的行为，例如：\n\n经常换早餐店吃早餐\n与陌生人打一个招呼\n换一种穿搭风格\n一个人去图书馆看书\n\n以上这些都是一些有一点难度，需要打破你原有的舒适圈，但是又不会让你想要放弃。当你积少成多，你也就有了脱离当前身份的勇气，走出去最大的收获在于「走出去」，So just do it。\n身份认同带来的思考\n安于现状和不断地做重复的事情，就是在编织自己的茧房。世界是多元的，人也应该是丰富的。\n我希望程序员的你，万一不幸被裁，你会像多啦 A 梦一样，从口袋里拿出一个新的赚钱的技能，来应对这个多变的社会。\nRelated\n身份认同 - 维基百科，自由的百科全书"},"Spaces/Resources/博客/生活类/肠胃镜的经验分享":{"title":"肠胃镜的经验分享","links":[],"tags":["肠胃镜"],"content":"肠胃镜的经验分享\n外卖，重口味，压力，情绪，工作都是你得肠胃病的诱因，年轻人的身体越来越扛不住了。2022 年 5 月 3 号晚，照常点了一份重庆红烧牛肉面，又点了一些煌上煌的零嘴，快吃完时突感不适。\n咽喉仿佛被卡住，一直想打嗝却打不出，胃胀气难受，一晚上都在折腾，之后一直都没有好。中途看过一两次中医，一次在老家一个岁数大的中医，另一次是深圳市三甲医院的中医（医学博士），喝了很长一段时间的中药，钱也花了不少，服药期间好一些，断药后症状依然还在。\n至此，对中医产生了极大的怀疑。一直到 2023 年的 3 月份去深圳市第二人民医院做了肠胃镜，拿了报告，医生开了一点药，这才好了。\n如果长时间胃部感到不适，且整天担心自己的胃病，强烈建议去做一个肠胃镜，肠胃镜不但能治你的胃病，也能治你的心病。\n肠胃镜预约流程\n本人是在「深圳市第二人名医院」就诊的。\n挂号基本上都是通过小程序或者公众号，微信上搜医院的名称就有。\n首先，需要去挂「消化内科」的号，已经决定接做肠胃镜，就找一个最便宜的医生挂号，让医生给你开个肠胃镜检查的单子，就可以了。\n开的单子包含：胃镜单、肠镜单、麻醉药品、清肠药物、除泡剂。不同医院给的可能会有不同。\n由于人多，预约肠胃镜的时间可能需要 7 ~ 10 天，不绝对，取决于你就诊的医院。若预约的是无痛肠胃镜，医生可能还会让你做一个麻醉评估，遵循医嘱就好了。\n选择正常的还是无痛的？\n看个人体质，建议无痛。我也是看过很多人分享肠胃镜的体验，才做无痛的，真的就是和睡觉一样，没一点感觉。据说肠镜往菊花灌气时会非常痛苦。\n肠镜要一起做吗？\n建议还是一起，除非你能判断或者医生帮你判断不需要做肠镜。如果是无痛的，肠胃镜一起做更方便，只需一次麻醉即可。当然肠镜的费用也要加进去。\n无痛肠胃镜体验\n约好之后，医生会告诉你如何用药。一般是在检查的前一晚用药，需要服用「泻药」，泻药不难喝（因人而异），味道像菠萝味的脉动，难受的点是需要大量饮水。喝玩泻药之后，半小时感觉就来了，之后会连上好几次，另外建议备一些湿厕纸，保护好菊花。\n清肠准备妥当之后，去医院准备。在做之前，医生还会给你一个服用一个麻药，很小一瓶但是巨难喝，麻药作用在你的喉咙，做胃镜的时候身体不会有异物感。\n进入肠胃镜室，让你侧躺在床上，医生给你打麻药，感觉有一股凉嗖嗖的液体进入，随着 1.2 次深呼吸你就进入昏迷状态。\n等醒来的时候，已经在等待室了。整个感觉像睡了一个很舒服的觉，刚醒的时候医护还会让你多坐一会，醒醒麻药，清醒之后就可以走了，整个过程都是无感的，并且身体上也不会有明显的不适。\n活检和息肉\n肠胃镜过程中医生发现有 息肉 或者 糜烂处 ，都会做一些处理。当然这个是在做之前需要签一个同意书的，若不同意医生也不会处理。息肉一般都是直接切除，以防息肉变大引起癌变。糜烂处也是需要取一点肉去做活检，检查该部分病变的情况。\n过程听起来很吓人，都但是实际上一点感觉都没有，本人就取过活检，无不适感。取了活检还需要等待活检报告，方便医生判断病情。\n总之，无痛体验真的很爽。我是上午做完的肠胃镜，当天下午就可以去上班，只是迫于自己太懒，就打了一下午游戏。\n费用\n本人深圳一档社保，总费用大概 1700 多，包含：药品费，多次的挂号费，肠镜，胃镜，麻醉费，取活检费用（肠胃健康则无该项费用）。\n最终个人自付 230 多，其中取活检的费用是 220 多，因为本人在昏迷状态，所以活检费用是朋友帮忙交的，没有走医保。所以实际上医保基本报销完了，力度还是挺大的。\n完。"},"Spaces/Resources/博客/生活类/肾结石的治疗经验分享":{"title":"肾结石的治疗经验分享","links":[],"tags":["todo","肾结石"],"content":""},"Spaces/Resources/博客/生活类/财富流---个人觉察":{"title":"财富流 - 个人觉察","links":[],"tags":["提升"],"content":"我没有想到一款「游戏」能让我有非常不一样的体验。\n接触之前\n我像大多数人一样，初听这个名字会以为这仅仅是一个教你如何积累财富的「骗局」。\n我为什么会认为是「骗局」？因为我觉的这是成功人士，为了教你成功，创建的一款游戏仅此而已。我认为每个人的成功都不可复制的，所以他们给出成功经验更像是一种安慰穷人的做法，让你以为你可以成功。\n正式因为持有这样的「偏见」，我一开始才会有一些抵触甚至是讨厌。但迫于朋友的邀请，以及自己想要突破舒适圈的渴望，还是如约的参加这个游戏。\n\n写下这些的时候，又引发了我的思考🤔？\n\n为什么我会对自己不熟悉的领域有偏见？\n我的偏见是怎么来的？\n为什么有的时候我愿意为自己的偏见买单？\n这些偏见阻碍了我什么？\n\n\n游戏前期的体验\n来都来了是吧，该做的事情还是要做。听完游戏介绍和规则后随机抽取自己的角色（抽到了医生），开始了游戏。\n游戏有两个目标\n\n出圈：从平民的圈子跳出来成为富人圈（被动收入和精力达到角色要求即可）\n终极梦想：实现自己所追求的梦想。（钱 + 精力）\n\n游戏的终极目标实现自己的梦想（万人演讲、环球旅行等），从平民的圈子跳出来成为富人也是可以的，因为跳出来之后，富人想要去实现自己的梦想会很简单，大多都是时间和精力问题。\n游戏是分为三个人生阶段的：20 ~ 30（青年）、30 ~ 50（中年）、50 ~ 60（老年）。每个时期能做的事情有限制，每个人都是拿着自己的薪水和初始的精力，以及少许银行存款开始自己的游戏，游戏中的设定和规则都是贴近真实生活的。\n一开始还在熟悉规则，以及处于一个陌生的圈子中，触发了我的社恐 buff，表现的会比较拘束一点，遇到不懂的地方,也是大多数去问我旁边的审计（朋友）。\n\n写到「触发我的社恐 buff」的时候，我又发现自己将自己定义成了一个「社恐人士」，虽然我之前确实有社恐，但是我好想一直都喜欢给自己贴上这个标签，哪怕别人都不这么觉得。所以标签有的时候是你意识不到的，你想摘却看不见。\n\n在游戏的青年时期和中年时期，经历了人生低谷「失业」、也迎来了自己的高光「结婚」、「生娃」。但是对于「出圈」这个目标还是差的很远，因为自己的「被动收入」为 0，而恰巧自己的角色对被动收入的要求更高。但是值得庆幸的是，自己累积了一些收入、以及有足够的精力去做足够多的事情，还与其他玩家建立了合作关系，有了一定的人脉基础，只是自己还从未使用过。\n在前中期复盘的时候发现了自己的问题：虽然与其他玩家建立了人脉，但是缺少合作，以及开口的勇气，导致机会从自己手上流失，自己却没有察觉到。到了自己老年的时候，就需要善用已经存在的资源，否则单靠自己去实现破圈的目标是非常难的。\n不过好在前中期已经也有积累，现在只需要主动出击便可以将机会利用起来，帮助自己破圈。\n游戏后期的体验\n游戏后期，到了自己的老年时期了。直到这个时候我才真正的有目标感，想要为了破圈去做一些努力，向建立关系的玩家进行借贷，以及通过自己的努力去争取那最后的破圈机会。都说厚积薄发，我成为全场剩余的平民中最适合出圈的人，我拿到了最后出圈的机会，顺利出圈。\n在富人圈中与其他富人合作，开启了一场豪赌，最后直接赢得两个亿，此时终极目标已经显的没有那么重要了，追逐的过程已经证明了一切。\n游戏结束后，每个玩家都开始了对自己游戏的复盘。\n我的复盘\n「人脉」：我知道需要达到破圈的目的是避免不了与他人合作的，因此「人脉」在游戏一开始我遇到能够成就别人的机会就会积极的给到别人，从而建立起人脉关系。\n「自信」：虽然我早早的与他人建立了关系，但是却一直没有使用过，因为自己缺乏一些自信，不太敢与他人开口这也就导致别人不清楚你的情况，即使他能够帮助你，但你不开口她就永远不知道。收获了一个经典句子：开口就有 50% 的机会。\n「厚积薄发」：当你像我一样，前中期没有把握好机会的话，不要放弃不要怨天尤人，做好自己的积累与提升，这样机会来的时候才能把握住。只需要从自己身上做一些突破，便可以使用积累的资源实现破圈。\n「放平心态」：不以物喜，不以己悲，酸甜苦辣咸才是人生百味，只品尝一个味道就太单调了。生活就是这样可以很丰富也可以很平淡，选择固然重要，面对选择之后带来的不确定性更重要。\n我的收获，以及引申的思考\n在我总结了自己复盘之后，在场的玩家也给了我很多可能性，让我开始思考一些事情。\n教练通过他的上帝视角给与我的建议:\n\n你意识到自己是有价值的，变得越来越自信，机会也随之多了起来\n你意识到自己是一切问题的根源，于是不再抱怨，开始负担起责任，机会也越来越多\n\n收获到一些其他小伙伴的建议：\n\n身份认同\n场的概念\n机会的给与\n敢于试错\n\n上面的建议，有些有意识到的，有些则从来没有了解的，但是建议好像都没有转成实践。因此虽然我懂得一些道理，但还是在原地踏步，就像油箱里面装满了油，但是你却不启动发动机，尽管不会离目的地越来越远，却也永远达不到目标。\n写到最后，再再一次引发了我的思考，除了旁观者清外，为什么别人能够发现你的问题，并且给出恰到好处的建议。而当我去评价别人的时候，好像觉得别人很完美了，但其他人评价他的时候我也非常认同这个评价。\n简而言之，就是发现不了问题，或者意识不到问题所在。说起来会觉得有点可笑，认知不够连存在的问题都会看不到。因此提升自己的认知很有必要，他会让你意识到什么是问题，以及如何处理这些问题。\n最后的最后，也是非常感谢邀请我参加活动的小伙伴，没有他的邀请我也不会参加这个活动，也不会带给我这么多的思考了。"},"Spaces/关于-Spaces":{"title":"关于 Spaces","links":[],"tags":[],"content":"Spaces 中包含自己个人计划和回顾。可以是正在学习的新领域，分享的一些实用工具，以及任何需要拥有自己空间的事物。\nSpaces 包含内容如下（示例）：\n\n个人财务笔记\n学习的新领域\n有趣的工作\n分享的工具集\n个人的计划和回顾\n"},"index":{"title":"花园首页","links":["/","Atlas/Travel-MOC","Atlas/深圳咖啡馆MOC","Atlas/数字花园主页🪴/读书笔记","穿搭日记","Atlas/数字花园主页🪴/Blog-MOC","🍀-花园导览"],"tags":["home"],"content":"hello 👋，我系 Felix 渣渣丰，会写一点 Java 代码。\n喜欢漫无目的的徒步、喜欢穿搭设计、喜欢听播客、喜欢看电影 🎬、喜欢创造与冒险、喜欢生活赋予我的一切。\n这里是一座开放式的数字花园，所有的组成都是来自于自己的大脑🧠。目前主要在浇灌这几个领域 ⭕：\n\n👟户外 walk 日记\n☕️深圳咖啡馆\n🎬 电影\n📚读书笔记\n👖穿搭日记\n✍🏻我的博客\n\n既然你诚心诚意地🌟，闯入了我的花园🌺，那我就大发慈悲地🙏，给你一张地图：🍀 花园导览。\n这不是传统的博客📚，这是我思考的过程容器，所以可能有很多看起来令人费解的半成品内容🧩，也会颠覆你传统的长文阅读习惯📖。当您漫步花园时🚶‍♂️，这里有 2 个不成熟的小建议 💁：\n\n尽量通过鼠标悬浮预览🖱️进行上下文不中断的阅读👀。\n尽量通过底部反向链接🔗找回来时的路。\n\n这座数字花园🌐使用 Obsidian 写作和发布📝，如果你想搭建属于自己的数字花园，可以参考🌱 oldwinterの数字花园。\n你还可以在这里找到我 🌏 GitHub 🌻 🍠 小红书 🌻 ✍🏻 博客"}}